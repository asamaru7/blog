<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

<title>이 세상에 하나는 남기고 가자</title><id>https://blog.asamaru.net/</id><updated>2017-01-25T09:13:09+00:00</updated><subtitle>세상에 필요한 소스코드 한줄 남기고 가자</subtitle><link href="https://blog.asamaru.net/" rel="alternate" type="text/html" /><link href="https://blog.asamaru.net/atom.xml" rel="self" type="application/atom+xml" /><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author>
<entry><id>https://blog.asamaru.net/2017/01/25/php-regex-epilogue/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 에필로그</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/25/php-regex-epilogue/"/><published>2017-01-25T11:45:13+00:00</published><updated>2017-01-25T11:45:13+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[앞선 글들에서 PCRE에 대한 전반적인 내용을 소개 했다. 일부는 내용이 이해하기 어려울 수 있다. 나름 이해가 어려운 부분은 예시를 추가해서 이해를 돕고자 했으나 부족할 것으로 보인다. PCRE를 익히는 가장 좋은 방법은 직접 패턴을 만들어 보면서 학습하는 것이다. PCRE에 대한 소개를 마치며 학습 및 활용에 도움이 될 수 있는 몇가지 사이트와 예시들을 남겨둔다. 정규식을 웹 상에서 테스트해 볼 수 있는 사이트를 소개한다(검색해보면 더 많은 사이트들이 존재하니 자신에게 맞는 사이트를 사용하면 된다). regular xpressions 101 : PHP, PCRE, Python, Golang, JavaScript 정규식을 테스트 할 수 있다. 그리고 입력한 정규식 패턴에 대한 설명과 매칭 결과를 상세히 보여줘서 상당히 유용하다. PHP Live Regex : PHP 정규식(PCRE)만 지원하지만 preg_match, preg_replace 등의 함수 등의 실행 결과를 바로 확인 할 수 있어 편리하다. REGEXPER : 정규식을 Railroad Diagrams으로 보여준다. 단, PCRE와 완전히 호환되지 않기 때문에 PCRE 문법이 포함된 정규식은 오류가 난다. 다음은 정규식 사용 예시를 몇가지 남겨둔다. 웹 상에서 공개되어 있는 예시들도 있고 직접 만들어 사용했던 정규식도 포함되어 있다. 유니코드 공백 문자들을 일반 공백 문자(0x20)로 치환 <?php $result = trim(preg_replace('/[\\pZ\\pC]+/u', ' ', $str)); 이와 관련된 유사한 내용은 htmlspecialchars_decode와 html_entity_decode의 문자열 처리의 다른 점을 참고하자. 한글 추출 / 제외 <?php // http://phpschool.com/link/tipntech/77239 $text = '!@#$%^&*()_+ 가나다라 1234567890 abcdefgh'; echo preg_replace('/\p{Hangul}/u', '', $text) . "\n"; // 한글 제외 echo preg_replace('/\P{Hangul}/u', '', $text) . "\n"; // 한글만 남김 // !@#$%^&*()_+ 1234567890 abcdefgh // 가나다라 // 한글 범위 // [\x{ac00}-\x{d7a3}] 가-힣 // [\x{3131}-\x{314e}] ㄱ-ㅎ // [\x{314f}-\x{3163}] ㅏ-ㅣ // 무슨 문자가 더 있나 찍어보기 // for($i = 0x31; $i < 0xff; $i ++) { // echo iconv('UCS-2BE', 'UTF-8', pack('H*', '31'.strtolower(dechex($i)))); // } 대상 내에서 문자열로 정의된 영역을 추출하는 예시 <?php $string = <<<STR \$a = "123test-string"; "test-string\"test-string" 'test-string"test-string\'test-string' 'test-string" test-string\'test-string' sample "" '"' '' STR; $regex = '/(?P<string>(["\'])(?s:(?=(\\\\?))\g{-1}.)*?\g{-2})/'; preg_match_all($regex, $string, $matches); print_r($matches['string']); 위 예시를 응용해서 html에서 이미지 url만 추출하는 예시다. <?php $string = <<<STR <img src="test url" /> <img alt="ver" src="http://test/\"'url" /> <img alt="v\"er" src="test url" /> STR; $regex = '/<img\s+[^>]*src\s*=\s*(?P<images>(["\'])(?s:(?=(\\\\?))\g{-1}.)*?\g{-2})/'; preg_match_all($regex, $string, $matches); print_r($matches['images']); 더 간단히 아래와 같이 해도 상관없다(url 내에 ' 또는 " 가 나올 수 없으므로). <?php preg_match_all('/<img\s+[^>]*src\s*=\s*[\'"]([^\'"]+)[\'"][^>]*>/', $string, $matches); 기타 간단한 정규식 이하 내용은 예시로 웹 상에 공개된 정규식들로 검증을 거치지 않았으니 참고만 하자. 숫자만 체크 정규식 /^[0-9]+$/ 이메일 체크 정규식 /^[0-9A-Z]([-_\.]?[0-9A-Z])*@[0-9A-Z]([-_\.]?[0-9A-Z])*\.[A-Z]{2,20}$/i 전화번호 정규식 /^\d{3}-\d{3,4}-\d{4}$/ : 휴대전화 /^01([0|1|6|7|8|9]?)-?([0-9]{3,4})-?([0-9]{4})$/ : 휴대전화 /^\d{2,3}-\d{3,4}-\d{4}$/ : 일반 전화번호 아이디나 비밀번호 정규식 /^[a-z0-9_]{4,20}$/ : 4자 이상 20자 이하 영소문자/숫자/_ 허용 태그(#) / 맨션(@) 추출 /(?:@|#)[^\s\t\n\r]+/ : @나 #으로 시작되는 문자열 추출 PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) > PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<p>앞선 글들에서 PCRE에 대한 전반적인 내용을 소개 했다. 일부는 내용이 이해하기 어려울 수 있다. 나름 이해가 어려운 부분은 예시를 추가해서 이해를 돕고자 했으나 부족할 것으로 보인다. PCRE를 익히는 가장 좋은 방법은 직접 패턴을 만들어 보면서 학습하는 것이다.</p>
<p>PCRE에 대한 소개를 마치며 학습 및 활용에 도움이 될 수 있는 몇가지 사이트와 예시들을 남겨둔다.</p>
<hr />
<p>정규식을 웹 상에서 테스트해 볼 수 있는 사이트를 소개한다(검색해보면 더 많은 사이트들이 존재하니 자신에게 맞는 사이트를 사용하면 된다).</p>
<ul>
<li><a href="https://regex101.com/">regular xpressions 101</a> : PHP, PCRE, Python, Golang, JavaScript 정규식을 테스트 할 수 있다. 그리고 입력한 정규식 패턴에 대한 설명과 매칭 결과를 상세히 보여줘서 상당히 유용하다.</li>
<li><a href="http://www.phpliveregex.com/">PHP Live Regex</a> : PHP 정규식(PCRE)만 지원하지만 preg_match, preg_replace 등의 함수 등의 실행 결과를 바로 확인 할 수 있어 편리하다.</li>
<li><a href="https://regexper.com/">REGEXPER</a> : 정규식을 <a href="http://tiddlywiki.com/languages/ko-KR/static/Railroad%2520Diagrams.html">Railroad Diagrams</a>으로 보여준다. 단, PCRE와 완전히 호환되지 않기 때문에 PCRE 문법이 포함된 정규식은 오류가 난다.</li>
</ul>
<hr />
<p>다음은 정규식 사용 예시를 몇가지 남겨둔다. 웹 상에서 공개되어 있는 예시들도 있고 직접 만들어 사용했던 정규식도 포함되어 있다.</p>
<h4>유니코드 공백 문자들을 일반 공백 문자(0x20)로 치환</h4>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$result</span> = trim(preg_replace(<span class="hljs-string">'/[\\pZ\\pC]+/u'</span>, <span class="hljs-string">' '</span>, <span class="hljs-variable">$str</span>));</pre>
<p>이와 관련된 유사한 내용은 <a href="/2015/09/10/htmlspecialchars-decode-html-entity-decode-spaces/">htmlspecialchars_decode와 html_entity_decode의 문자열 처리의 다른 점</a>을 참고하자.</p>
<h3>한글 추출 / 제외</h3>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-comment">// http://phpschool.com/link/tipntech/77239</span>
<span class="hljs-variable">$text</span> = <span class="hljs-string">'!@#$%^&amp;*()_+ 가나다라 1234567890 abcdefgh'</span>;
<span class="hljs-keyword">echo</span> preg_replace(<span class="hljs-string">'/\p{Hangul}/u'</span>, <span class="hljs-string">''</span>, <span class="hljs-variable">$text</span>) . <span class="hljs-string">"\n"</span>;   <span class="hljs-comment">// 한글 제외</span>
<span class="hljs-keyword">echo</span> preg_replace(<span class="hljs-string">'/\P{Hangul}/u'</span>, <span class="hljs-string">''</span>, <span class="hljs-variable">$text</span>) . <span class="hljs-string">"\n"</span>;   <span class="hljs-comment">// 한글만 남김</span>

<span class="hljs-comment">// !@#$%^&amp;*()_+  1234567890 abcdefgh</span>
<span class="hljs-comment">// 가나다라</span>

<span class="hljs-comment">// 한글 범위</span>
<span class="hljs-comment">// [\x{ac00}-\x{d7a3}] 가-힣</span>
<span class="hljs-comment">// [\x{3131}-\x{314e}] ㄱ-ㅎ</span>
<span class="hljs-comment">// [\x{314f}-\x{3163}] ㅏ-ㅣ</span>

<span class="hljs-comment">// 무슨 문자가 더 있나 찍어보기</span>
<span class="hljs-comment">// for($i = 0x31; $i &lt; 0xff; $i ++) {</span>
<span class="hljs-comment">//     echo iconv('UCS-2BE', 'UTF-8', pack('H*', '31'.strtolower(dechex($i))));</span>
<span class="hljs-comment">// }</span></pre>
<h4>대상 내에서 문자열로 정의된 영역을 추출하는 예시</h4>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">&lt;&lt;&lt;STR
\$a = "123test-string";
"test-string\"test-string"
'test-string"test-string\'test-string'

'test-string"
        test-string\'test-string'

sample</span>

<span class="hljs-string">""</span>
<span class="hljs-string">'"'</span>
<span class="hljs-string">''</span>
STR;

<span class="hljs-variable">$regex</span> = <span class="hljs-string">'/(?P&lt;string&gt;(["\'])(?s:(?=(\\\\?))\g{-1}.)*?\g{-2})/'</span>;
preg_match_all(<span class="hljs-variable">$regex</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>[<span class="hljs-string">'string'</span>]);</pre>
<h4>위 예시를 응용해서 html에서 이미지 url만 추출하는 예시다.</h4>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">&lt;&lt;&lt;STR
&lt;img src="test url" /&gt;
&lt;img alt="ver" src="http://test/\"'url" /&gt;
&lt;img alt="v\"er" src="test url" /&gt;
STR;</span>

<span class="hljs-variable">$regex</span> = <span class="hljs-string">'/&lt;img\s+[^&gt;]*src\s*=\s*(?P&lt;images&gt;(["\'])(?s:(?=(\\\\?))\g{-1}.)*?\g{-2})/'</span>;
preg_match_all(<span class="hljs-variable">$regex</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>[<span class="hljs-string">'images'</span>]);</pre>
<p>더 간단히 아래와 같이 해도 상관없다(url 내에 ' 또는 &quot; 가 나올 수 없으므로).</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
preg_match_all(<span class="hljs-string">'/&lt;img\s+[^&gt;]*src\s*=\s*[\'"]([^\'"]+)[\'"][^&gt;]*&gt;/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);</pre>
<h4>기타 간단한 정규식</h4>
<p>이하 내용은 예시로 웹 상에 공개된 정규식들로 검증을 거치지 않았으니 참고만 하자.</p>
<ul>
<li>
<p>숫자만 체크 정규식</p>
<ul>
<li><code>/^[0-9]+$/</code></li>
</ul>
</li>
<li>
<p>이메일 체크 정규식</p>
<ul>
<li><code>/^[0-9A-Z]([-_\.]?[0-9A-Z])*@[0-9A-Z]([-_\.]?[0-9A-Z])*\.[A-Z]{2,20}$/i</code></li>
</ul>
</li>
<li>
<p>전화번호 정규식</p>
<ul>
<li><code>/^\d{3}-\d{3,4}-\d{4}$/</code> : 휴대전화</li>
<li><code>/^01([0|1|6|7|8|9]?)-?([0-9]{3,4})-?([0-9]{4})$/</code> : 휴대전화</li>
<li><code>/^\d{2,3}-\d{3,4}-\d{4}$/</code> : 일반 전화번호</li>
</ul>
</li>
<li>
<p>아이디나 비밀번호 정규식</p>
<ul>
<li><code>/^[a-z0-9_]{4,20}$/</code> : 4자 이상 20자 이하 영소문자/숫자/_ 허용</li>
</ul>
</li>
<li>태그(#) / 맨션(@) 추출
<ul>
<li><code>/(?:@|#)[^\s\t\n\r]+/</code> : <code>@</code>나 <code>#</code>으로 시작되는 문자열 추출</li>
</ul></li>
</ul>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 에필로그</strong></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/24/php-regex-recursive-patterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/24/php-regex-recursive-patterns/"/><published>2017-01-24T11:22:11+00:00</published><updated>2017-01-24T11:22:11+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Recursive patterns (재귀 패턴) 무한대의 중첩 괄호를 허용하면서 괄호 안의 문자열을 일치시키는 문제를 고려해 보자. 재귀를 사용하지 않고 수행 할 수 있는 최상의 방법은 중첩의 고정된 깊이까지 일치하는 패턴을 사용하는 것이다. 임의의 중첩 깊이는 처리 할 수 ​​없다. Perl 5.6은 정규식을 반복 할 수 있는 실험적 기능을 제공한다. 특수 항목 (?R)은 재귀의 특정 경우에 대해 제공된다. \( ( (?>[^()]+) | (?R) )* \) 이 PCRE 패턴은 괄호 문제를 해결한다(공백을 무시하도록 PCRE_EXTENDED 옵션이 설정되어 있다고 가정한다). 먼저 여는 괄호와 일치한다. 그런 다음 괄호가 아닌 시퀀스 또는 패턴 자체의 재귀 일치 (예 : 올바르게 괄호로 묶은 부분 문자열)가 될 수 있는 임의의 수의 하위 문자열을 찾는다. 마지막으로 닫는 괄호가 있다. 이 특정 예제 패턴에는 중첩된 무제한 반복이 포함되어 있으므로 일치하지 않는 문자열에 패턴을 적용 할 때 괄호가 아닌 문자열을 일치 시키는데 한 번만 사용하는 서브 패턴을 사용하는 것이 중요하다. 예를 들어 "(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()"에 적용하면 신속하게 "일치하지 않음"을 나타낸다. 그러나 once-only 서브 패턴이 사용되지 않으면 매우 오랜 시간 동안 검사가 실행된다. + 및 *의 반복은 모든 경우의 수에 대해 실패할 때까지 테스트해야 하기 때문이다. 캡춰 서브 패턴에 설정되는 값은 서브 패턴 값이 설정되어 있는 재귀의 최외각 레벨의 값이다. 위의 패턴이 (ab(cd)ef)와 일치하면 캡처 괄호의 값은 최상위 수준에서 마지막으로 취해진 값인 "ef"이다. 추가 괄호가 추가되면 \( ( ( (?>[^()]+) | (?R) )* ) \) 다음에 캡처하는 문자열은 "ab(cd)ef" 수준 괄호 패턴에 15개 이상의 캡처 괄호가 있는 경우 PCRE는 재귀 중에 데이터를 저장하기 위해 추가 메모리를 확보해야 한다. 재귀는 pcre_malloc을 사용하여 수행 한 후 나중에 pcre_free를 통해 해제 한다. 메모리를 확보 할 수 없으면 재귀 내에서 메모리 부족 오류를 제공 할 방법이 없기 때문에 처음 15개의 캡처링 괄호에 대한 데이터만 저장한다. (?1), (?2) 등은 재귀 서브 패턴에도 사용될 수있다. 또한 이름이 지정된 서브 패턴 (?P>name) 또는 (?P&name)을 사용할 수도 있다. 재귀적 서브 패턴 참조 (숫자 또는 이름 기준)의 구문이 참조되는 괄호 밖에서 사용되면 프로그래밍 언어의 서브 루틴처럼 작동한다. 앞의 예는 패턴 (sens|respons)e and \1ibility가 "sense and sensibility", "response and responsibility"와 일치하지만 "sense and responsibility"와는 일치하지 않는다고 지적했다. 대신에 패턴 (sens|respons)e and (?1)ibility가 사용되면 다른 두 문자열과 마찬가지로 "sense and responsibility"와 일치한다. 그러나 이러한 참조는 참조하는 서브 패턴을 따라야 한다. 문자열의 최대 길이는 정수 변수가 가질 수 있는 최대 양수이다. 그러나 PCRE는 재귀를 사용하여 서브 패턴과 무한 반복을 처리한다. 이는 사용 가능한 스택 공간이 특정 패턴으로 처리 할 수 있는 제목 문자열의 크기를 제한 할 수 있음을 의미한다. 아래의 예시는 주어진 문장이 회문(palindrome)인지를 판별하는 정규식 예시이다. <?php $strs = ["saippuakauppias", "A man, a plan, a canal: Panama!"]; foreach ($strs as $str) { if (preg_match('/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix', $str)) { printf("'%s' is a palindrome\n", $str); } else { printf("'%s' is not a palindrome\n", $str); } } // 'saippuakauppias' is a palindrome // 'A man, a plan, a canal: Panama!' is a palindrome 다음의 예시는 중첩된 balanced text(좌우에 대칭되는 표식에 의해 둘러싸여 있는 text)를 추출하는 정규식에 대한 예시이다. Can I use Perl regular expressions to match balanced text? <?php $str = <<<STR I have some <brackets in <nested brackets> > and <another group <nested once <nested twice> > > and that's it. <div>sfsd</div> STR; $regex = '/ ( (?# 캡처 버퍼 1의 시작) < (?# 여는 부등호에 매치) (?: [^<>]++ (?# 부등호를 제외한 문자들이 반복, 백트래킹하지 않음) | (?1) (?# < 또는 > 발견, 캡처 버퍼 1을 재귀적으로 부름) )* > (?# 닫는 부등호에 매치) ) (?# 캡처 버퍼 1의 끝) /ix'; preg_match_all($regex, $str, $matches); print_r($matches); //Array //( // [0] => Array // ( // [0] => <brackets in <nested brackets> > // [1] => <another group <nested once <nested twice> > > // [2] => <div> // [3] => </div> // ) // [1] => Array // ( // [0] => <brackets in <nested brackets> > // [1] => <another group <nested once <nested twice> > > // [2] => <div> // [3] => </div> // ) //) PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) > PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.recursive.php">Recursive patterns</a> (재귀 패턴)</h3>
<p>무한대의 중첩 괄호를 허용하면서 괄호 안의 문자열을 일치시키는 문제를 고려해 보자. 재귀를 사용하지 않고 수행 할 수 있는 최상의 방법은 중첩의 고정된 깊이까지 일치하는 패턴을 사용하는 것이다. 임의의 중첩 깊이는 처리 할 수 ​​없다. Perl 5.6은 정규식을 반복 할 수 있는 실험적 기능을 제공한다. 특수 항목 <code>(?R)</code>은 재귀의 특정 경우에 대해 제공된다.</p>
<p><code>\( ( (?&gt;[^()]+) | (?R) )* \)</code></p>
<p>이 PCRE 패턴은 괄호 문제를 해결한다(공백을 무시하도록 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션이 설정되어 있다고 가정한다).</p>
<p>먼저 여는 괄호와 일치한다. 그런 다음 괄호가 아닌 시퀀스 또는 패턴 자체의 재귀 일치 (예 : 올바르게 괄호로 묶은 부분 문자열)가 될 수 있는 임의의 수의 하위 문자열을 찾는다. 마지막으로 닫는 괄호가 있다.</p>
<p>이 특정 예제 패턴에는 중첩된 무제한 반복이 포함되어 있으므로 일치하지 않는 문자열에 패턴을 적용 할 때 괄호가 아닌 문자열을 일치 시키는데 한 번만 사용하는 서브 패턴을 사용하는 것이 중요하다. 예를 들어 &quot;(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()&quot;에 적용하면 신속하게 &quot;일치하지 않음&quot;을 나타낸다. 그러나 once-only 서브 패턴이 사용되지 않으면 매우 오랜 시간 동안 검사가 실행된다. <code>+</code> 및 <code>*</code>의 반복은 모든 경우의 수에 대해 실패할 때까지 테스트해야 하기 때문이다.</p>
<p>캡춰 서브 패턴에 설정되는 값은 서브 패턴 값이 설정되어 있는 재귀의 최외각 레벨의 값이다. 위의 패턴이 <code>(ab(cd)ef)</code>와 일치하면 캡처 괄호의 값은 최상위 수준에서 마지막으로 취해진 값인 &quot;ef&quot;이다. 추가 괄호가 추가되면 <code>\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</code> 다음에 캡처하는 문자열은 &quot;ab(cd)ef&quot; 수준 괄호 패턴에 15개 이상의 캡처 괄호가 있는 경우 PCRE는 재귀 중에 데이터를 저장하기 위해 추가 메모리를 확보해야 한다. 재귀는 pcre_malloc을 사용하여 수행 한 후 나중에 pcre_free를 통해 해제 한다. 메모리를 확보 할 수 없으면 재귀 내에서 메모리 부족 오류를 제공 할 방법이 없기 때문에 처음 15개의 캡처링 괄호에 대한 데이터만 저장한다.</p>
<p><code>(?1)</code>, <code>(?2)</code> 등은 재귀 서브 패턴에도 사용될 수있다. 또한 이름이 지정된 서브 패턴 <code>(?P&gt;name)</code> 또는 <code>(?P&amp;name)</code>을 사용할 수도 있다.</p>
<p>재귀적 서브 패턴 참조 (숫자 또는 이름 기준)의 구문이 참조되는 괄호 밖에서 사용되면 프로그래밍 언어의 서브 루틴처럼 작동한다. 앞의 예는 패턴 <code>(sens|respons)e and \1ibility</code>가 &quot;sense and sensibility&quot;, &quot;response and responsibility&quot;와 일치하지만 &quot;sense and responsibility&quot;와는 일치하지 않는다고 지적했다. 대신에 패턴 <code>(sens|respons)e and (?1)ibility</code>가 사용되면 다른 두 문자열과 마찬가지로 &quot;sense and responsibility&quot;와 일치한다. 그러나 이러한 참조는 참조하는 서브 패턴을 따라야 한다.</p>
<p>문자열의 최대 길이는 정수 변수가 가질 수 있는 최대 양수이다. 그러나 PCRE는 재귀를 사용하여 서브 패턴과 무한 반복을 처리한다. 이는 사용 가능한 스택 공간이 특정 패턴으로 처리 할 수 있는 제목 문자열의 크기를 제한 할 수 있음을 의미한다.</p>
<p>아래의 예시는 주어진 문장이 회문(palindrome)인지를 판별하는 정규식 예시이다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$strs</span> = [<span class="hljs-string">"saippuakauppias"</span>, <span class="hljs-string">"A man, a plan, a canal: Panama!"</span>];
<span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$strs</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$str</span>) {
    <span class="hljs-keyword">if</span> (preg_match(<span class="hljs-string">'/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix'</span>, <span class="hljs-variable">$str</span>)) {
        printf(<span class="hljs-string">"'%s' is a palindrome\n"</span>, <span class="hljs-variable">$str</span>);
    } <span class="hljs-keyword">else</span> {
        printf(<span class="hljs-string">"'%s' is not a palindrome\n"</span>, <span class="hljs-variable">$str</span>);
    }
}
<span class="hljs-comment">// 'saippuakauppias' is a palindrome</span>
<span class="hljs-comment">// 'A man, a plan, a canal: Panama!' is a palindrome</span></pre>
<p>다음의 예시는 중첩된 balanced text(좌우에 대칭되는 표식에 의해 둘러싸여 있는 text)를 추출하는 정규식에 대한 예시이다.</p>
<p><a href="http://learn.perl.org/faq/perlfaq6.html#Can-I-use-Perl-regular-expressions-to-match-balanced-text">Can I use Perl regular expressions to match balanced text?</a></p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$str</span> = <span class="hljs-string">&lt;&lt;&lt;STR
I have some &lt;brackets in &lt;nested brackets&gt; &gt; and &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
and that's it.
&lt;div&gt;sfsd&lt;/div&gt;
STR;</span>

<span class="hljs-variable">$regex</span> = <span class="hljs-string">'/
        (                   (?# 캡처 버퍼 1의 시작)
        &lt;                   (?# 여는 부등호에 매치)
            (?:
                [^&lt;&gt;]++     (?# 부등호를 제외한 문자들이 반복, 백트래킹하지 않음)
                  |
                (?1)        (?# &lt; 또는 &gt; 발견, 캡처 버퍼 1을 재귀적으로 부름)
            )*
        &gt;                   (?# 닫는 부등호에 매치)
        )                   (?# 캡처 버퍼 1의 끝)
        /ix'</span>;
preg_match_all(<span class="hljs-variable">$regex</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);

<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; Array</span>
<span class="hljs-comment">//      (</span>
<span class="hljs-comment">//          [0] =&gt; &lt;brackets in &lt;nested brackets&gt; &gt;</span>
<span class="hljs-comment">//            [1] =&gt; &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;</span>
<span class="hljs-comment">//            [2] =&gt; &lt;div&gt;</span>
<span class="hljs-comment">//          [3] =&gt; &lt;/div&gt;</span>
<span class="hljs-comment">//      )</span>
<span class="hljs-comment">//    [1] =&gt; Array</span>
<span class="hljs-comment">//      (</span>
<span class="hljs-comment">//          [0] =&gt; &lt;brackets in &lt;nested brackets&gt; &gt;</span>
<span class="hljs-comment">//            [1] =&gt; &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;</span>
<span class="hljs-comment">//            [2] =&gt; &lt;div&gt;</span>
<span class="hljs-comment">//          [3] =&gt; &lt;/div&gt;</span>
<span class="hljs-comment">//      )</span>
<span class="hljs-comment">//)</span>
</pre>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</strong></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/23/php-regex-comments/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/23/php-regex-comments/"/><published>2017-01-23T14:12:12+00:00</published><updated>2017-01-23T14:12:12+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Comments (주석) 시퀀스 (?#는 다음 닫는 괄호까지 이어지는 주석의 시작을 표시한다. 중첩된 괄호는 허용되지 않으며 주석을 구성하는 문자는 패턴 일치에 전혀 영향을 미치지 않는다. PCRE_EXTENDED 옵션을 설정하면 캐릭터 클래스 외부의 이스케이프 처리되지 않은 # 문자가 패턴의 다음 줄바꿈 문자까지 이어지는 주석을 나타냅니다. <?php $string = 'test'; echo preg_match('/te(?# 주석테스트)st/', $string) . "\n"; echo preg_match('/te#~~~~ st/', $string) . "\n"; echo preg_match('/te#~~~~ st/x', $string) . "\n"; // result // 1 // 0 // 1 // 두번째 정규식의 경우 x(PCRE_EXTENDED) 옵션이 없으므로 #~~~~을 주석으로 인정하지 않아 실패를 반환 PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) > PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.comments.php">Comments</a> (주석)</h3>
<p>시퀀스 <code>(?#</code>는 다음 닫는 괄호까지 이어지는 주석의 시작을 표시한다.
중첩된 괄호는 허용되지 않으며 주석을 구성하는 문자는 패턴 일치에 전혀 영향을 미치지 않는다.</p>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션을 설정하면 <a href="/2017/01/14/php-regex-character-classes/">캐릭터 클래스</a> 외부의 <a href="/2017/01/10/php-regex-escape-sequences/">이스케이프</a> 처리되지 않은 <code>#</code> 문자가 패턴의 다음 줄바꿈 문자까지 이어지는 주석을 나타냅니다.</p>
<pre><code>&lt;?php
$string = 'test';
echo preg_match('/te(?# 주석테스트)st/', $string) . "\n";
echo preg_match('/te#~~~~
st/', $string) . "\n";
echo preg_match('/te#~~~~
st/x', $string) . "\n";

// result
// 1
// 0
// 1
// 두번째 정규식의 경우 x(PCRE_EXTENDED) 옵션이 없으므로 #~~~~을 주석으로 인정하지 않아 실패를 반환</code></pre>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</strong></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/22/php-regex-conditional-subpatterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/22/php-regex-conditional-subpatterns/"/><published>2017-01-22T09:18:45+00:00</published><updated>2017-01-22T09:18:45+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Conditional subpatterns (조건부 서브 패턴) 조건부로 서브 패턴을 따르거나 어설션의 결과에 따라 두 개의 대체 서브 패턴 중 하나를 선택하거나 이전 캡처 서브 패턴이 일치하는지 여부를 결정할 수 있다. 조건부 서브 패턴의 가능한 두 가지 형태는 다음과 같다. (?(condition)yes-pattern) (?(condition)yes-pattern|no-pattern) 조건이 충족되면 "yes-pattern"이 사용된다. 그렇지 않으면 "no-pattern"(존재한다면)이 사용된다. 서브 패턴에 두 개 이상의 대안이있는 경우 컴파일 타임 오류가 발생한다. 아래에 두 가지 종류의 조건이 있다. 괄호 사이의 텍스트가 일련의 숫자로 구성되어 있으면 해당 숫자의 캡처 서브 패턴이 이전에 일치 한 경우 조건이 충족된다. 읽기 쉽도록 하기 위해 의미 없는 공백을 포함해서 세 부분으로 나눈 다음 패턴을 고려해 보자(PCRE_EXTENDED 옵션을 가정). ( \( )? [^()]+ (?(1) \) ) 첫 번째 부분은 선택적 여는 괄호와 일치하며, 해당 문자가 있는 경우 첫 번째 부분 문자열로 설정한다. 두 번째 부분은 괄호가 아닌 하나 이상의 문자와 일치한다. 세 번째 파트는 첫 번째 괄호 세트가 일치하는지 여부를 테스트하는 조건부 서브 패턴이다. 만약 그렇다면, 즉, 시작 괄호로 시작한 문자열은 조건이 참이므로 "yes-pattern"이 실행되고 닫는 괄호가 필요하다. 그렇지 않으면 "no-pattern"이 없으므로 서브 패턴은 아무것도 일치하지 않는다. 즉, 이 패턴은 괄호 안에 괄호로 묶지 않은 비괄호의 시퀀스와 일치한다. 조건이 문자열 "(R)" 인 경우 패턴 또는 서브 패턴에 대한 재귀 호출이 수행되면 만족된다. "top level"에서 조건은 거짓이다. 조건이 일련의 숫자나 "(R)"이 아닌 경우 조건이 어설션이어야 한다. 이것은 positive 또는 negative lookahead 또는 lookbehind assertion 일 수 있다. 중요하지 않은 공백을 포함하는 이 패턴을 고려하고 두 번째 줄에 있는 두 가지 대안을 고려하자. (?(?=[^a-z]*[a-z]) \d{2}-[a-z]{3}-\d{2} | \d{2}-\d{2}-\d{2} ) 조건은 비문자와 문자가 뒤에 붙는 선택적 순서와 일치하는 positive lookahead이다. 즉, 문자열에 적어도 하나의 문자가 있는지 테스트 한다. 문자가 발견되면, 첫 번째 대안에 대해 대상이 대조된다. 그렇지 않으면 두 번째와 일치한다. 이 패턴은 두 형식 "dd-aaa-dd" 또는 "dd-dd-dd" 중 하나의 문자열을 일치시킨다. 여기서 "aaa"는 문자이고 "dd"는 숫자다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) > PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.conditional.php">Conditional subpatterns</a> (조건부 서브 패턴)</h3>
<p>조건부로 서브 패턴을 따르거나 <a href="/2017/01/15/php-regex-alternation/">어설션</a>의 결과에 따라 두 개의 대체 서브 패턴 중 하나를 선택하거나 이전 캡처 서브 패턴이 일치하는지 여부를 결정할 수 있다. 조건부 서브 패턴의 가능한 두 가지 형태는 다음과 같다.</p>
<pre><code>(?(condition)yes-pattern)
(?(condition)yes-pattern|no-pattern)</code></pre>
<p>조건이 충족되면 &quot;yes-pattern&quot;이 사용된다. 그렇지 않으면 &quot;no-pattern&quot;(존재한다면)이 사용된다. 서브 패턴에 두 개 이상의 대안이있는 경우 컴파일 타임 오류가 발생한다.</p>
<p>아래에 두 가지 종류의 조건이 있다.</p>
<p>괄호 사이의 텍스트가 일련의 숫자로 구성되어 있으면 해당 숫자의 캡처 서브 패턴이 이전에 일치 한 경우 조건이 충족된다. 읽기 쉽도록 하기 위해 의미 없는 공백을 포함해서 세 부분으로 나눈 다음 패턴을 고려해 보자(<a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션을 가정).</p>
<p><code>( \( )? [^()]+ (?(1) \) )</code></p>
<ul>
<li>첫 번째 부분은 선택적 여는 괄호와 일치하며, 해당 문자가 있는 경우 첫 번째 부분 문자열로 설정한다.</li>
<li>두 번째 부분은 괄호가 아닌 하나 이상의 문자와 일치한다.</li>
<li>세 번째 파트는 첫 번째 괄호 세트가 일치하는지 여부를 테스트하는 조건부 서브 패턴이다.</li>
</ul>
<p>만약 그렇다면, 즉, 시작 괄호로 시작한 문자열은 조건이 참이므로 &quot;yes-pattern&quot;이 실행되고 닫는 괄호가 필요하다. 그렇지 않으면 &quot;no-pattern&quot;이 없으므로 서브 패턴은 아무것도 일치하지 않는다. 즉, 이 패턴은 괄호 안에 괄호로 묶지 않은 비괄호의 시퀀스와 일치한다.</p>
<p>조건이 문자열 &quot;(R)&quot; 인 경우 패턴 또는 서브 패턴에 대한 재귀 호출이 수행되면 만족된다. &quot;top level&quot;에서 조건은 거짓이다.</p>
<p>조건이 일련의 숫자나 &quot;(R)&quot;이 아닌 경우 조건이 <a href="/2017/01/15/php-regex-alternation/">어설션</a>이어야 한다. 이것은 positive 또는 negative lookahead 또는 lookbehind assertion 일 수 있다. 중요하지 않은 공백을 포함하는 이 패턴을 고려하고 두 번째 줄에 있는 두 가지 대안을 고려하자.</p>
<pre><code>(?(?=[^a-z]*[a-z])
\d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )</code></pre>
<p>조건은 비문자와 문자가 뒤에 붙는 선택적 순서와 일치하는 positive lookahead이다. 즉, 문자열에 적어도 하나의 문자가 있는지 테스트 한다. 문자가 발견되면, 첫 번째 대안에 대해 대상이 대조된다. 그렇지 않으면 두 번째와 일치한다. 이 패턴은 두 형식 &quot;dd-aaa-dd&quot; 또는 &quot;dd-dd-dd&quot; 중 하나의 문자열을 일치시킨다. 여기서 &quot;aaa&quot;는 문자이고 &quot;dd&quot;는 숫자다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</strong></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/21/php-regex-once-​only-subpatterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/21/php-regex-once-​only-subpatterns/"/><published>2017-01-21T18:25:01+00:00</published><updated>2017-01-21T18:25:01+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Once-​only subpatterns (단일 서브 패턴) 반복을 최대/최소화하면서 매치가 실패하면 반복되는 항목을 재평가하여 다른 반복 횟수로 나머지 패턴을 일치시킬 수 있는지 확인한다. 때로는 패턴의 작성자가 반복적인 매치를 수행 할 필요가 없음을 알 때는 이를 방지하거나 매치 성질을 변경하거나 다른 방법보다 먼저 실패하게하는 것이 유용하다. 예를 들어, 문자열 "123456bar"에 \d+foo 패턴을 적용하는 것을 고려해 보자. 6자리 모두를 매치한 다음 "foo"와 일치하지 않으면, 정규식의 정상적인 동작은 \d+ 항목과 일치하는 5자리 숫자로 다시 시도한다. 그리고는 4자리로 다시 시도하여 궁극적으로 실패한다. Once-only 서브 패턴은 패턴의 일부가 매치되면 이 방법으로 재평가 되지 않게하기 위해서 최초로 "foo"와의 매치가 실패 했을 경우는 즉시 포기할 것을 지정하는 수단을 제공한다. 이 표기법은 또 다른 종류의 특수 괄호로 (?>\d+)bar와 같이 (?>로 시작한다. 이런 종류의 괄호는 패턴이 일치하면 패턴의 일부를 잠근다("locks up"). 그리고 패턴이 더 이상의 실패하는 패턴으로 되돌아가는 것을 방지한다. 그러나 이전 항목으로 이동(Backtracking)하면 정상적으로 작동한다. 또 다른 설명은 이 유형의 서브 패턴이 문자열의 현재 위치에 고정되어 있으면 동일한 독립형 패턴이 일치하는 문자의 문자열과 일치한다는 것이다. Once-only 서브 패턴은 서브 패턴을 캡처하지 않는다. 위의 예제와 같은 간단한 경우는 가능한 모든 것을 매치 해야하는 최대화 반복으로 생각할 수 있다. 그래서 \d+와 \d+?는 둘 다 나머지 패턴을 일치시키기 위해 일치하는 자릿수를 조정할 준비가되어 있다. 물론이 구조는 임의로 복잡한 서브 패턴을 포함할 수 있으며 중첩 될 수 있다. Once-only 서브 패턴은 look-behind 어설션과 함께 사용하여 문자열 끝에 효율적인 일치를 지정한다. 일치하지 않는 긴 문자열에 적용 할 때 abcd$와 같은 간단한 패턴을 고려하자. 매칭은 왼쪽에서 오른쪽으로 진행되기 때문에, PCRE는 대상의 각 "a"를 찾아 다음 패턴이 나머지 패턴과 일치하는지 확인한다. 패턴이 ^.*abcd$로 지정되면 초기 .*는 처음에는 전체 문자열과 일치한다. 그러나 이것이 실패 할 때(다음 "a"가 없기 때문에) 마지막 문자를 제외한 모든 문자와 일치하도록 역 추적하고, 마지막 문자는 제외하고 모두 반복합니다. 다시 한 번 "a"에 대한 검색은 오른쪽에서 왼쪽으로 전체 문자열을 포함하므로 더 나아지지 않는다. 그러나 패턴이 ^(?>.*)(?<=abcd)로 쓰여진 경우 .* 항목에 대해 역 추적이 불가능 할 수 있다. 그것은 전체 문자열만 일치시킬 수 있다. 후속 look-behind 어설션은 마지막 네 문자에 대해 단일 테스트를 수행한다. 실패하면 즉시 일치하지 않는다. 긴 문자열의 경우 이 접근 방식은 처리 시간에 중요한 차이를 만든다. 패턴이 무한히 반복 될 수 있는 서브 패턴 내부에 무제한 반복을 포함하는 패턴은 한 번만 서브 패턴을 사용하는 것이 매우 오랜 시간 동안 실패한 일부 일치를 피할 수 있는 유일한 방법이다. 패턴 (\D+|<\d+>)*[!?]는 숫자가 아닌 문자 또는 <>로 묶인 숫자 뒤에 ! 또는 ? 문자가 일치하는 부분 문자열을 무제한으로 매치한다. 이 매치가 성공한다면 빠르게 실행이 완료된다. 그러나 "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"에 적용되면 실패를 보고 하기까지 시간이 오래 걸린다. 이것은 문자열이 여러 가지 방법으로 두 반복 사이에서 나눌 수 있기 때문에 모두 시도해야한다. (PCRE와 Perl은 단일 문자가 사용될 때 빠른 오류를 허용하는 최적화 기능을 가지고 있기 때문에 끝에 있는 단일 문자 대신 [!?]를 사용한다. 패턴이 ((?>\D+)|<\d+>)*[!?]로 변경되면 일치하는데 필요한 마지막 단일 문자를 기억하고 숫자가 아닌 시퀀스는 깨질 수 없으므로 오류가 빠르게 발생한다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) > PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.onlyonce.php">Once-​only subpatterns</a> (단일 서브 패턴)</h3>
<p>반복을 최대/최소화하면서 매치가 실패하면 반복되는 항목을 재평가하여 다른 반복 횟수로 나머지 패턴을 일치시킬 수 있는지 확인한다. 때로는 패턴의 작성자가 반복적인 매치를 수행 할 필요가 없음을 알 때는 이를 방지하거나 매치 성질을 변경하거나 다른 방법보다 먼저 실패하게하는 것이 유용하다.</p>
<p>예를 들어, 문자열 &quot;123456bar&quot;에 <code>\d+foo</code> 패턴을 적용하는 것을 고려해 보자.</p>
<p>6자리 모두를 매치한 다음 &quot;foo&quot;와 일치하지 않으면, 정규식의 정상적인 동작은 <code>\d+</code> 항목과 일치하는 5자리 숫자로 다시 시도한다. 그리고는 4자리로 다시 시도하여 궁극적으로 실패한다.
Once-only 서브 패턴은 패턴의 일부가 매치되면 이 방법으로 재평가 되지 않게하기 위해서 최초로 &quot;foo&quot;와의 매치가 실패 했을 경우는 즉시 포기할 것을 지정하는 수단을 제공한다. 이 표기법은 또 다른 종류의 특수 괄호로 <code>(?&gt;\d+)bar</code>와 같이 <code>(?&gt;</code>로 시작한다.</p>
<p>이런 종류의 괄호는 패턴이 일치하면 패턴의 일부를 잠근다(&quot;locks up&quot;). 그리고 패턴이 더 이상의 실패하는 패턴으로 되돌아가는 것을 방지한다. 그러나 이전 항목으로 이동(Backtracking)하면 정상적으로 작동한다.</p>
<p>또 다른 설명은 이 유형의 서브 패턴이 문자열의 현재 위치에 고정되어 있으면 동일한 독립형 패턴이 일치하는 문자의 문자열과 일치한다는 것이다.</p>
<p>Once-only 서브 패턴은 서브 패턴을 캡처하지 않는다. 위의 예제와 같은 간단한 경우는 가능한 모든 것을 매치 해야하는 최대화 반복으로 생각할 수 있다. 그래서 <code>\d+</code>와 <code>\d+?</code>는 둘 다 나머지 패턴을 일치시키기 위해 일치하는 자릿수를 조정할 준비가되어 있다.</p>
<p>물론이 구조는 임의로 복잡한 서브 패턴을 포함할 수 있으며 중첩 될 수 있다.</p>
<p>Once-only 서브 패턴은 look-behind <a href="/2017/01/15/php-regex-alternation/">어설션</a>과 함께 사용하여 문자열 끝에 효율적인 일치를 지정한다. 일치하지 않는 긴 문자열에 적용 할 때 <code>abcd$</code>와 같은 간단한 패턴을 고려하자. 매칭은 왼쪽에서 오른쪽으로 진행되기 때문에, PCRE는 대상의 각 &quot;a&quot;를 찾아 다음 패턴이 나머지 패턴과 일치하는지 확인한다.</p>
<p>패턴이 <code>^.*abcd$</code>로 지정되면 초기 <code>.*</code>는 처음에는 전체 문자열과 일치한다. 그러나 이것이 실패 할 때(다음 &quot;a&quot;가 없기 때문에) 마지막 문자를 제외한 모든 문자와 일치하도록 역 추적하고, 마지막 문자는 제외하고 모두 반복합니다. 다시 한 번 &quot;a&quot;에 대한 검색은 오른쪽에서 왼쪽으로 전체 문자열을 포함하므로 더 나아지지 않는다. 그러나 패턴이 <code>^(?&gt;.*)(?&lt;=abcd)</code>로 쓰여진 경우 <code>.*</code> 항목에 대해 역 추적이 불가능 할 수 있다. 그것은 전체 문자열만 일치시킬 수 있다. 후속 look-behind <a href="/2017/01/15/php-regex-alternation/">어설션</a>은 마지막 네 문자에 대해 단일 테스트를 수행한다. 실패하면 즉시 일치하지 않는다. 긴 문자열의 경우 이 접근 방식은 처리 시간에 중요한 차이를 만든다.</p>
<p>패턴이 무한히 반복 될 수 있는 서브 패턴 내부에 무제한 반복을 포함하는 패턴은 한 번만 서브 패턴을 사용하는 것이 매우 오랜 시간 동안 실패한 일부 일치를 피할 수 있는 유일한 방법이다. 패턴 <code>(\D+|&lt;\d+&gt;)*[!?]</code>는 숫자가 아닌 문자 또는 <code>&lt;&gt;</code>로 묶인 숫자 뒤에 <code>!</code> 또는 <code>?</code> 문자가 일치하는 부분 문자열을 무제한으로 매치한다. 이 매치가 성공한다면 빠르게 실행이 완료된다. 그러나 &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;에 적용되면 실패를 보고 하기까지 시간이 오래 걸린다. 이것은 문자열이 여러 가지 방법으로 두 반복 사이에서 나눌 수 있기 때문에 모두 시도해야한다. (PCRE와 Perl은 단일 문자가 사용될 때 빠른 오류를 허용하는 최적화 기능을 가지고 있기 때문에 끝에 있는 단일 문자 대신 <code>[!?]</code>를 사용한다. 패턴이 <code>((?&gt;\D+)|&lt;\d+&gt;)*[!?]</code>로 변경되면 일치하는데 필요한 마지막 단일 문자를 기억하고 숫자가 아닌 시퀀스는 깨질 수 없으므로 오류가 빠르게 발생한다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</strong></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/20/php-regex-assertions/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/20/php-regex-assertions/"/><published>2017-01-20T19:54:12+00:00</published><updated>2017-01-20T19:54:12+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[[Assertions] (http://php.net/manual/kr/regexp.reference.assertions.php) (어설션) 어설션은 실제로 어떤 문자도 사용하지 않고 현재 일치 지점의 앞/뒤 문자에 대한 테스트이다. \b, \B, \A, \Z, \z, ^ 및 $로 코딩된 간단한 어설션은 앞서 설명했다. 더 복잡한 어서션은 서브 패턴으로 코딩 된다. 이 어설션은 대상 문자열의 현재 위치보다 앞을 검사하는 look-ahead와 뒤를 검사하는 look-behind 두 가지 종류가 있다. 어설션 서브 패턴은 현재 일치하는 위치가 변경되지 않는다는 점을 제외하면 일반적인 방법으로 매치된다. Look-ahead 어설션은 (?= 긍정 어설션, (?!은 부정 어설션을 나타낸다. 예를 들어, \w+(?=;)는 단어 뒤에 세미콜론이 있는 단어를 매치하지만 세미콜론은 포함하지 않는다. <?php $str = 'abc;def'; preg_match('/\w+(?=;)/', $str, $matches); print_r($matches); // Array // ( // [0] => abc // ) foo(?!bar)는 "bar"가 뒤에 붙지 않는 "foo"와 매치된다. 기억할 점은 유사한 패턴인 (?!foo)bar는 "foo"로 시작되지 않는 "bar" 항목을 찾지 않는다는 것이다. 다음 3개의 문자가 "bar"일 때 어설션 (?!foo)은 항상 TRUE 이므로 모든 항목을 찾는다. 아래의 예시를 참고하자. <?php $string = "fooXbar"; echo preg_match('/foo(?!bar)/', $string) . "\n"; // 1 $string = "foobar"; echo preg_match('/(?!foo)bar/', $string) . "\n"; // 1 원하는 결과를 얻으려면 look-behind 어설션이 필요하다. look-behind 어설션은 (?<= 긍정 어설션, (?<!은 부정 어설션을 나타낸다. 예를 들어, (?<!foo)bar는 "foo"가 앞에 붙지 않는 "bar"의 항목을 찾는다. look-behind 어설션은 일치하는 모든 문자열이 고정 길이가 되도록 제한되지만, 여러 가지 대안이 있는 경우 모든 대안이 동일한 고정 길이를 가져야 하는 것은 아니다. 따라서 (?<=bullock|donkey)는 허용된다. 그러나 (?<!dogs?|cats?)는 컴파일 타임에 오류가 발생한다. 다른 길이의 문자열에 일치하는 분기는 look-behind 어설션의 최상위 수준에서만 허용된다. 이것은 모든 분기에서 동일한 길이를 요구하는 Perl 5.005와 비교되는 확장이다. (?<=ab(c|de))와 같은 어설션은 허용되지 않는다. 왜냐하면 단일 최상위 분기가 두 개의 다른 길이를 일치시킬 수 있기 때문이다. 그러나 두 개의 최상위 레벨 분기를 사용하도록 (?<=abc|abde)로 다시 작성하면 허용된다. look-behind 어설션의 구현은 각 대안에 따라 현재 위치를 고정폭만큼 임시로 이동시킨 다음 일치시키려고 시도한다. 현재 위치 앞에 문자가 충분하지 않으면 일치가 실패한 것으로 간주된다. 한 번만 사용 할 수 있는 서브 패턴과 관련된 look-behind는 특히 문자열 끝에 매칭하는데 유용 할 수 있다. once-only subpatterns에 대한 섹션에 예제가 있다. 여러 어설션이 연속해서 발생할 수 있다. 예를 들어, (?<=\d{3})(?<!999)foo는 "foo" 앞에 "999"가 아닌 세 자리를 찾는다. 각 어설션은 주제 문자열의 동일한 지점에서 독립적으로 적용된다. 먼저 앞의 세 문자가 모두 숫자임을 확인한 다음 동일한 세 문자가 "999"가 아닌지 확인한다. 이 패턴은 "foo"와 6 문자 앞의 문자는 일치하지 않는다. 첫 번째 문자는 숫자이고 마지막 세 문자는 "999"가 아니다. 예를 들어, "123abcfoo"와 일치하지 않는다((?<=\d{3}...)(?<!999)foo를 사용하면 매치된다). <?php $string = "123abcfoo"; echo preg_match('/(?<=\d{3})(?<!999)foo/', $string) . "\n"; // 0 echo preg_match('/(?<=\d{3}...)(?<!999)foo/', $string) . "\n"; // 1 이번에는 첫 번째 어설션은 앞의 여섯개 문자를 살펴보고 첫 번째 세 개가 숫자 임을 확인한 다음 두 번째 어설션은 앞의 세 문자가 "999"가 아님을 확인한다. 어설션은 임의의 조합으로 중첩 될 수 있다. 예를 들어 (?<=(?<!foo)bar)baz는 앞에 "foo"가 없는 "bar"가 앞에 오는 "baz"의 발생과 일치하지만 (?<=\d{3}...(?<!999))foo는 "foo"앞에 3 자리 숫자와 "999"가 아닌 3 자와 일치하는 다른 패턴이다. 어설션 서브 패턴은 서브 패턴을 캡쳐하지 않으며 반복되지 않을 수 있다. 동일한 것을 여러 번 선언하는 것은 의미가 없기 때문이다. 임의의 종류의 어설션에 서브 패턴 캡처가 포함되어 있으면 이러한 패턴은 전체 패턴에서 캡처하는 서브 패턴에 번호를 매기는 목적으로 계산된다. 그러나 부분 문자열 캡처는 긍정적인 어설션에 대해서만 수행된다. 왜냐하면 부정적인 어설션에 대해서는 의미가 없기 때문이다. 어설션은 최대 200개의 괄호로 묶은 서브 패턴으로 계산된다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) > PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3>[Assertions] (<a href="http://php.net/manual/kr/regexp.reference.assertions.php">http://php.net/manual/kr/regexp.reference.assertions.php</a>) (어설션)</h3>
<p>어설션은 실제로 어떤 문자도 사용하지 않고 현재 일치 지점의 앞/뒤 문자에 대한 테스트이다. <code>\b</code>, <code>\B</code>, <code>\A</code>, <code>\Z</code>, <code>\z</code>, <code>^</code> 및 <code>$</code>로 코딩된 간단한 어설션은 앞서 설명했다. 더 복잡한 어서션은 서브 패턴으로 코딩 된다. 이 어설션은 대상 문자열의 현재 위치보다 앞을 검사하는 look-ahead와 뒤를 검사하는 look-behind 두 가지 종류가 있다.</p>
<p>어설션 서브 패턴은 현재 일치하는 위치가 변경되지 않는다는 점을 제외하면 일반적인 방법으로 매치된다.</p>
<p>Look-ahead 어설션은 <code>(?=</code> 긍정 어설션, <code>(?!</code>은 부정 어설션을 나타낸다. 예를 들어, <code>\w+(?=;)</code>는 단어 뒤에 세미콜론이 있는 단어를 매치하지만 세미콜론은 포함하지 않는다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$str</span> = <span class="hljs-string">'abc;def'</span>;
preg_match(<span class="hljs-string">'/\w+(?=;)/'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">// Array</span>
<span class="hljs-comment">// (</span>
<span class="hljs-comment">//  [0] =&gt; abc</span>
<span class="hljs-comment">// )</span></pre>
<p><code>foo(?!bar)</code>는 &quot;bar&quot;가 뒤에 붙지 않는 &quot;foo&quot;와 매치된다. 기억할 점은 유사한 패턴인 <code>(?!foo)bar</code>는 &quot;foo&quot;로 시작되지 않는 &quot;bar&quot; 항목을 찾지 않는다는 것이다. 다음 3개의 문자가 &quot;bar&quot;일 때 어설션 <code>(?!foo)</code>은 항상 TRUE 이므로 모든 항목을 찾는다. 아래의 예시를 참고하자.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">"fooXbar"</span>;
<span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">'/foo(?!bar)/'</span>, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// 1</span>

<span class="hljs-variable">$string</span> = <span class="hljs-string">"foobar"</span>;
<span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">'/(?!foo)bar/'</span>, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// 1</span></pre>
<p>원하는 결과를 얻으려면 look-behind 어설션이 필요하다.</p>
<p>look-behind 어설션은 <code>(?&lt;=</code> 긍정 어설션, <code>(?&lt;!</code>은 부정 어설션을 나타낸다. 예를 들어, <code>(?&lt;!foo)bar</code>는 &quot;foo&quot;가 앞에 붙지 않는 &quot;bar&quot;의 항목을 찾는다. look-behind 어설션은 일치하는 모든 문자열이 고정 길이가 되도록 제한되지만, 여러 가지 대안이 있는 경우 모든 대안이 동일한 고정 길이를 가져야 하는 것은 아니다. 따라서 <code>(?&lt;=bullock|donkey)</code>는 허용된다. 그러나 <code>(?&lt;!dogs?|cats?)</code>는 컴파일 타임에 오류가 발생한다.
다른 길이의 문자열에 일치하는 분기는 look-behind 어설션의 최상위 수준에서만 허용된다. 이것은 모든 분기에서 동일한 길이를 요구하는 Perl 5.005와 비교되는 확장이다.
<code>(?&lt;=ab(c|de))</code>와 같은 어설션은 허용되지 않는다. 왜냐하면 단일 최상위 분기가 두 개의 다른 길이를 일치시킬 수 있기 때문이다. 그러나 두 개의 최상위 레벨 분기를 사용하도록 <code>(?&lt;=abc|abde)</code>로 다시 작성하면 허용된다.
look-behind 어설션의 구현은 각 대안에 따라 현재 위치를 고정폭만큼 임시로 이동시킨 다음 일치시키려고 시도한다. 현재 위치 앞에 문자가 충분하지 않으면 일치가 실패한 것으로 간주된다. 한 번만 사용 할 수 있는 서브 패턴과 관련된 look-behind는 특히 문자열 끝에 매칭하는데 유용 할 수 있다. <a href="/2017/01/21/php-regex-once-​only-subpatterns/">once-only subpatterns</a>에 대한 섹션에 예제가 있다.</p>
<p>여러 어설션이 연속해서 발생할 수 있다. 예를 들어, <code>(?&lt;=\d{3})(?&lt;!999)foo</code>는 &quot;foo&quot; 앞에 &quot;999&quot;가 아닌 세 자리를 찾는다. 각 어설션은 주제 문자열의 동일한 지점에서 독립적으로 적용된다. 먼저 앞의 세 문자가 모두 숫자임을 확인한 다음 동일한 세 문자가 &quot;999&quot;가 아닌지 확인한다. 이 패턴은 &quot;foo&quot;와 6 문자 앞의 문자는 일치하지 않는다. 첫 번째 문자는 숫자이고 마지막 세 문자는 &quot;999&quot;가 아니다. 예를 들어, &quot;123abcfoo&quot;와 일치하지 않는다(<code>(?&lt;=\d{3}...)(?&lt;!999)foo</code>를 사용하면 매치된다).</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">"123abcfoo"</span>;
<span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">'/(?&lt;=\d{3})(?&lt;!999)foo/'</span>, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// 0</span>

<span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">'/(?&lt;=\d{3}...)(?&lt;!999)foo/'</span>, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// 1</span></pre>
<p>이번에는 첫 번째 어설션은 앞의 여섯개 문자를 살펴보고 첫 번째 세 개가 숫자 임을 확인한 다음 두 번째 어설션은 앞의 세 문자가 &quot;999&quot;가 아님을 확인한다.</p>
<p>어설션은 임의의 조합으로 중첩 될 수 있다. 예를 들어 <code>(?&lt;=(?&lt;!foo)bar)baz</code>는 앞에 &quot;foo&quot;가 없는 &quot;bar&quot;가 앞에 오는 &quot;baz&quot;의 발생과 일치하지만 <code>(?&lt;=\d{3}...(?&lt;!999))foo</code>는 &quot;foo&quot;앞에 3 자리 숫자와 &quot;999&quot;가 아닌 3 자와 일치하는 다른 패턴이다.</p>
<p>어설션 서브 패턴은 서브 패턴을 캡쳐하지 않으며 반복되지 않을 수 있다. 동일한 것을 여러 번 선언하는 것은 의미가 없기 때문이다. 임의의 종류의 어설션에 서브 패턴 캡처가 포함되어 있으면 이러한 패턴은 전체 패턴에서 캡처하는 서브 패턴에 번호를 매기는 목적으로 계산된다. 그러나 부분 문자열 캡처는 긍정적인 어설션에 대해서만 수행된다. 왜냐하면 부정적인 어설션에 대해서는 의미가 없기 때문이다.</p>
<p>어설션은 최대 200개의 괄호로 묶은 서브 패턴으로 계산된다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</strong></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/19/php-regex-back-references/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/19/php-regex-back-references/"/><published>2017-01-19T19:56:12+00:00</published><updated>2017-01-19T19:56:12+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[[Back references] (http://php.net/manual/kr/regexp.reference.back-references.php) (역 참조) 캐릭터 클래스 밖에서 백 슬래시 다음에 0보다 큰 숫자는 패턴에서 이전(즉, 왼쪽으로) 캡처 서브 패턴에 대한 역 참조다(주어진 수보다 캡처된 서브 패턴의 수가 같거나 더 많을 경우). 그러나 백 슬래시 뒤의 10진수가 10 보다 작은 경우에는 항상 역 참조로 사용되며 전체 패턴에 많은 왼쪽 여는 괄호(()가 없는 경우에만 오류가 발생한다. 즉, 참조된 괄호는 10 보다 작은 숫자의 참조 왼쪽에 있을 필요는 없다. "전방 참조"는 반복이 관련되어 있고 오른쪽의 서브 패턴이 이전 반복에 참여했을 때 의미가 있다. 백 슬래시 뒤에 나오는 숫자 처리에 대한 자세한 내용은 위의 "백 슬래시"절을 참조하자. 역 참조는 현재 문자열에서 캡처하는 서브 패턴과 실제로 일치하는 것과 매치한다. 그래서 패턴 (sens|respons)e and \1ibility는 "sense and sensibility"와 "response and responsibility"와 일치하지만 "sense and responsibility"은 일치하지 않는다. 대소문자를 구분하는(caseful) 일치일 경우 역 참조 또한 문자의 대소문자를 매치한다. 예를 들어 ((?i)rah)\s+\1은 "rah rah"및 "RAH RAH"와 일치하지만 "RAH rah"와 일치하지 않는다(원래 캡처 서브 패턴이 대소문자를 구분하지 않더라도). <?php $str = 'RAH rah'; preg_match('/((?i)rah)\s+\1/', $str, $matches); print_r($matches); //Array //( //) preg_match('/(RAH)\s+(?i)\1/', $str, $matches); print_r($matches); //Array //( // [0] => RAH rah //[1] => RAH //) 같은 서브 패턴에 대한 복수의 역 참조가 있을 수 있다. 특정 패턴에서 실제로 서브 패턴을 사용하지 않은 경우 항상 실패한다. 예를 들어 패턴 (a|(bc))\2는 "bc"가 아닌 "a"와 일치하기 시작하면 항상 실패한다. <?php $str = 'abc'; preg_match('/(a|(bc))\2/', $str, $matches); print_r($matches); //Array //( //) $str = 'bcbc'; preg_match('/(a|(bc))\2/', $str, $matches); print_r($matches); //Array //( // [0] => bcbc // [1] => bc // [2] => bc //) 최대 99개의 역 참조가 있을 수 있으므로 백 슬래시 뒤의 모든 숫자는 잠재적인 참조 번호의 일부로 사용된다. 패턴이 숫자로 계속되면 뒤로 구분을 종료하기 위한 구분 기호를 사용해야 한다. PCRE_EXTENDED 옵션이 설정되면 공백이 될 수 있다. 그렇지 않으면 빈 주석을 사용할 수 있다. <?php $str = 'bcbc2'; preg_match('/(a|(bc))\2(?#)2/', $str, $matches); print_r($matches); //Array //( // [0] => bcbc2 // [1] => bc // [2] => bc //) 서브 패턴이 처음 사용될 때 참조하는 괄호 안쪽에서 발생하는 역 참조는 실패한다. 예를 들어, (a\1)은 결코 일치하지 않는다. 그러나 이러한 참조는 반복되는 서브 패턴 내부에서 유용할 수 있다. 예를 들어, 패턴 (a|b\1)+는 "a" 및 "aba", "ababba" 등의 임의의 수와 일치한다. 서브 패턴의 각 반복에서 이전 참조는 이전 반복에 해당하는 문자열과 일치한다. 이 작업을 수행하려면 첫 번째 반복이 역 참조와 일치할 필요가 없는 패턴이어야 한다. 위의 예와 같이 한정 기호를 사용하거나 최소값이 0인 수량 기호를 사용하여 이 작업을 수행 할 수 있다. PHP 5.2.2부터는 \g 이스케이프 시퀀스를 사용하여 서브 패턴의 절대 참조 및 상대 참조를 사용할 수 있다. 이 이스케이프 시퀀스 뒤에는 부호없는 숫자 또는 음수가 와야하며, 선택적으로 중괄호로 묶을 수 있다. \1, \g1 및 \g{1}은 서로 동의어다. 역 참조 뒤에 문자 숫자(\g{2}1)가 나타나는 경우 중괄호를 사용하면 모호성을 제거하는데 도움이 된다. 음수와 함께 \g 시퀀스를 사용하면 상대 참조를 의미한다. 예를 들어 (foo)(bar)\g{-1}은 "foobarbar"와 (foo)(bar)\g{-2}는 "foobarfoo"와 일치한다. 이것은 긴 패턴에서 특정 이전 서브 패턴을 참조하기 위해 서브 패턴의 수를 추적하는 대신에 사용하면 유용하다. 이름이 지정된 서브 패턴에 대한 역 참조는 (?P=name) 또는 PHP 5.2.2 이후 \k<name> 또는 \k'name'을 사용하여 수행 할 수 있다. 또한 PHP 5.2.4에서는 \k{name} 및 \g{name}에 대한 지원이 추가되었다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) > PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3>[Back references] (<a href="http://php.net/manual/kr/regexp.reference.back-references.php">http://php.net/manual/kr/regexp.reference.back-references.php</a>) (역 참조)</h3>
<p><a href="/2017/01/14/php-regex-character-classes/">캐릭터 클래스</a> 밖에서 백 슬래시 다음에 0보다 큰 숫자는 패턴에서 이전(즉, 왼쪽으로) 캡처 <a href="/2017/01/17/php-regex-subpatterns/">서브 패턴</a>에 대한 역 참조다(주어진 수보다 캡처된 서브 패턴의 수가 같거나 더 많을 경우).</p>
<p>그러나 백 슬래시 뒤의 10진수가 10 보다 작은 경우에는 항상 역 참조로 사용되며 전체 패턴에 많은 왼쪽 여는 괄호(<code>(</code>)가 없는 경우에만 오류가 발생한다. 즉, 참조된 괄호는 10 보다 작은 숫자의 참조 왼쪽에 있을 필요는 없다. &quot;전방 참조&quot;는 반복이 관련되어 있고 오른쪽의 서브 패턴이 이전 반복에 참여했을 때 의미가 있다. 백 슬래시 뒤에 나오는 숫자 처리에 대한 자세한 내용은 위의 &quot;<a href="/2017/01/10/php-regex-escape-sequences/">백 슬래시</a>&quot;절을 참조하자.</p>
<p>역 참조는 현재 문자열에서 캡처하는 서브 패턴과 실제로 일치하는 것과 매치한다. 그래서 패턴 <code>(sens|respons)e and \1ibility</code>는 &quot;sense and sensibility&quot;와 &quot;response and responsibility&quot;와 일치하지만 &quot;sense and responsibility&quot;은 일치하지 않는다. 대소문자를 구분하는(caseful) 일치일 경우 역 참조 또한 문자의 대소문자를 매치한다. 예를 들어 <code>((?i)rah)\s+\1</code>은 &quot;rah rah&quot;및 &quot;RAH RAH&quot;와 일치하지만 &quot;RAH rah&quot;와 일치하지 않는다(원래 캡처 서브 패턴이 대소문자를 구분하지 않더라도).</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$str</span> = <span class="hljs-string">'RAH rah'</span>;
preg_match(<span class="hljs-string">'/((?i)rah)\s+\1/'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//)</span>

preg_match(<span class="hljs-string">'/(RAH)\s+(?i)\1/'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; RAH rah</span>
<span class="hljs-comment">//[1] =&gt; RAH</span>
<span class="hljs-comment">//)</span></pre>
<p>같은 서브 패턴에 대한 복수의 역 참조가 있을 수 있다. 특정 패턴에서 실제로 서브 패턴을 사용하지 않은 경우 항상 실패한다. 예를 들어 패턴 <code>(a|(bc))\2</code>는 &quot;bc&quot;가 아닌 &quot;a&quot;와 일치하기 시작하면 항상 실패한다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$str</span> = <span class="hljs-string">'abc'</span>;
preg_match(<span class="hljs-string">'/(a|(bc))\2/'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//)</span>

<span class="hljs-variable">$str</span> = <span class="hljs-string">'bcbc'</span>;
preg_match(<span class="hljs-string">'/(a|(bc))\2/'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; bcbc</span>
<span class="hljs-comment">//  [1] =&gt; bc</span>
<span class="hljs-comment">//  [2] =&gt; bc</span>
<span class="hljs-comment">//)</span></pre>
<p>최대 99개의 역 참조가 있을 수 있으므로 백 슬래시 뒤의 모든 숫자는 잠재적인 참조 번호의 일부로 사용된다. 패턴이 숫자로 계속되면 뒤로 구분을 종료하기 위한 구분 기호를 사용해야 한다. <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션이 설정되면 공백이 될 수 있다. 그렇지 않으면 빈 주석을 사용할 수 있다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$str</span> = <span class="hljs-string">'bcbc2'</span>;
preg_match(<span class="hljs-string">'/(a|(bc))\2(?#)2/'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; bcbc2</span>
<span class="hljs-comment">//  [1] =&gt; bc</span>
<span class="hljs-comment">//  [2] =&gt; bc</span>
<span class="hljs-comment">//)</span></pre>
<p>서브 패턴이 처음 사용될 때 참조하는 괄호 안쪽에서 발생하는 역 참조는 실패한다. 예를 들어, <code>(a\1)</code>은 결코 일치하지 않는다. 그러나 이러한 참조는 반복되는 서브 패턴 내부에서 유용할 수 있다. 예를 들어, 패턴 <code>(a|b\1)+</code>는 &quot;a&quot; 및 &quot;aba&quot;, &quot;ababba&quot; 등의 임의의 수와 일치한다. 서브 패턴의 각 반복에서 이전 참조는 이전 반복에 해당하는 문자열과 일치한다. 이 작업을 수행하려면 첫 번째 반복이 역 참조와 일치할 필요가 없는 패턴이어야 한다. 위의 예와 같이 한정 기호를 사용하거나 최소값이 0인 수량 기호를 사용하여 이 작업을 수행 할 수 있다.</p>
<p>PHP 5.2.2부터는 <code>\g</code> 이스케이프 시퀀스를 사용하여 서브 패턴의 절대 참조 및 상대 참조를 사용할 수 있다. 이 이스케이프 시퀀스 뒤에는 부호없는 숫자 또는 음수가 와야하며, 선택적으로 중괄호로 묶을 수 있다. <code>\1</code>, <code>\g1</code> 및 <code>\g{1}</code>은 서로 동의어다. 역 참조 뒤에 문자 숫자(<code>\g{2}1</code>)가 나타나는 경우 중괄호를 사용하면 모호성을 제거하는데 도움이 된다.</p>
<p>음수와 함께 <code>\g</code> 시퀀스를 사용하면 상대 참조를 의미한다. 예를 들어 <code>(foo)(bar)\g{-1}</code>은 &quot;foobarbar&quot;와 <code>(foo)(bar)\g{-2}</code>는 &quot;foobarfoo&quot;와 일치한다. 이것은 긴 패턴에서 특정 이전 서브 패턴을 참조하기 위해 서브 패턴의 수를 추적하는 대신에 사용하면 유용하다.</p>
<p>이름이 지정된 서브 패턴에 대한 역 참조는 <code>(?P=name)</code> 또는 PHP 5.2.2 이후 <code>\k&lt;name&gt;</code> 또는 <code>\k'name'</code>을 사용하여 수행 할 수 있다. 또한 PHP 5.2.4에서는 <code>\k{name}</code> 및 <code>\g{name}</code>에 대한 지원이 추가되었다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</strong></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/18/php-regex-repetition/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/18/php-regex-repetition/"/><published>2017-01-18T18:58:11+00:00</published><updated>2017-01-18T18:58:11+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Repetition (반복) 반복은 다음 항목 중 하나를 따를 수 있는 한정 기호로 지정된다. 이스케이프 가능한 단일 문자 . 메타 문자 캐릭터 클래스 back reference(역 참조) 어설션이 아닌 괄호로 묶인 서브 패턴 일반적으로 반복값은 괄호({}) 안에 쉼표로 구분 된 두 개의 숫자를 입력하여 허용되는 일치의 최소 및 최대 수를 지정한다. 숫자는 65536 보다 작아야 하며 첫 번째 숫자는 두 번째 숫자보다 작거나 같아야 한다. 예를 들어, z{2,4}는 "zz", "zzz" 또는 "zzzz"와 일치한다. 단독으로 닫는 중괄호는 특수 문자가 아니다. 두 번째 숫자가 생략 되었으나 쉼표가 있으면 상한이 없다. 두 번째 숫자와 쉼표가 둘 다 생략되면 수량 기호는 필요한 일치 항목의 정확한 수를 지정한다. 따라서 [aeiou]{3,}는 최소 3개의 연속 모음과 일치하지만 \d{8}은 정확히 8자리 숫자와 일치한다. 한정 기호가 허용되지 않는 위치나 한정 기호의 구문과 일치하지 않는 위치에 나타나는 여는 중괄호({)는 리터럴 문자로 사용된다. 예를 들어, {,6}은 한정 기호가 아니라 4자의 리터럴 문자열이다. 한정자 {0}이 허용되어 표현식이 이전 항목 및 한정 기호가 없는 것처럼 동작한다. 편의상 (그리고 전통적인 호환성) 세 가지 가장 일반적인 수량 기호는 한 문자로 된 약자를 사용한다 : Single-character quantifiers 문자 설명 * {0,}와 같다 + {1,}와 같다 ? {0,1}와 같다 상한이 없는 수량 기호와 일치하지 않는 서브 패턴을 따라 무한 루프를 구성 할 수 있다(예 : (a?)*). 이전 버전의 Perl과 PCRE는 그러한 패턴을 컴파일 할 때 오류를 내기도 했다. 그러나 이 방법이 유용 할 수 있기 때문에 이러한 패턴이 이제 허용되지만 실제로 서브 패턴의 반복이 실제로 문자와 일치하지 않으면 루프가 강제로 끊어진다. 기본적으로 한정 기호는 "greedy" 즉 패턴의 나머지 부분을 실패시키지 않고 가능한 한 최대 허용 횟수까지 일치시킨다. 이것이 문제를 일으키는 곳의 고전적인 예는 C 프로그램의 주석과 일치하는 것이다. 시퀀스 /*와 */ 사이에 나타나며 시퀀스 내에서 개별 * 및 / 문자가 나타날 수 있다. 첫 번째 주석 */ 주석 /* 두 번째 주석 */에 문자열 /**.*\*/ 패턴을 적용하여 C 주석을 일치 시키려는 시도는 .*의 탐욕("greedy")으로 인해 전체 문자열과 일치하기 때문에 실패한다. 그러나 수량 기호 다음에 물음표가 오는 경우에는 게으르며(lazy) 가능한 최소 횟수와 일치하므로 패턴 /\*.*?\*/는 C 주석과 함께 올바른 작업을 수행한다. 다양한 한정어의 의미는 다른 방식으로 변경되지 않으며 선호하는 일치 개수만 변경된다. 이 ? 사용을 그 자체로 한정 기호로 사용하는 것과 혼동하지 말아야 한다. 두 가지 용도로 사용되기 때문에 \d??\d와 같이 두 글자로 표시되는 경우가 있다. 한 글자가 기본 설정과 일치하지만 나머지 패턴 일치하는 경우 두 글자와 일치할 수 있다. PCRE_UNGREEDY 옵션이 설정되어 있으면 (Perl에서는 사용할 수없는 옵션) 수량 한정자는 기본적으로 탐욕이 없다. 하지만 개별적인 물음표는 물음표를 따라 가면서 탐욕이 적용된다. 즉, 기본 동작을 반전합니다. +를 따르는 한정 기호는 "possessive"이다. 가능한 한 많은 문자와 매치하고 나머지 패턴과 일치하도록 돌아 가지 않는다. 따라서 .*abc는 "aabc"와 일치하지만 .*+는 전체 문자를 매치하기 때문에 .*+abc은 일치하지 않는다. Possessive 지정자는 처리 속도를 높이는 데 사용할 수 있다. <?php $str = 'aabc'; preg_match('/.*abc/', $str, $matches); print_r($matches); // Array // ( // [0] => aabc // ) preg_match('/.*+abc/', $str, $matches); print_r($matches); // Array // ( // ) 괄호 안의 서브 패턴이 최소 반복 횟수가 1 보다 크거나 제한된 최대 값으로 정량화되면 컴파일 된 패턴에 최소 또는 최대 크기에 비례하여 더 많은 저장소가 필요하다. 패턴이 .* 또는 .{0,}으로 시작하고 PCRE_DOTALL 옵션(Perl의 /s와 동일)이 설정되어 있으므로 .을 줄바꿈과 일치 시키려면 패턴은 암시적으로 고정되어 있다. 왜냐하면 뒤에 오는 것은 문자열의 모든 문자 위치에 대해 시도된다. 따라서 첫 번째 이후의 모든 위치에서 전체 일치를 다시 시도 할 필요가 없다. PCRE(Perl Compatible Regular Expressions)는 앞에 \A가 붙은 것처럼 패턴을 처리한다. 대상 문자열에 개행 문자가 없는 것으로 알려진 경우 패턴이 .*로 시작하는 경우 PCRE_DOTALL을 설정하거나 최적화를 위해 ^를 사용하여 명시적으로 고정을 나타낼 수 있다. 캡처 서브 패턴이 반복되면 캡처된 값은 최종 반복과 일치하는 하위 문자열이다. 예를 들어, (tweedle[dume]{3}\s*)+가 "tweedledum tweedledee"와 일치하면 캡처된 부분 문자열의 값은 "tweedledee"이다. 그러나 중첩된 캡처 서브 패턴이 있으면 해당 캡처 값이 이전 반복에서 설정 되었을 수 있다. 예를 들어, /(a|(b))+/가 "aba"와 일치하면 두 번째로 캡처 된 하위 문자열의 값은 "b"가 된다. <?php <?php preg_match('/(tweedle[dume]{3}\s*)+/', 'tweedledum tweedledee', $matches); print_r($matches); // Array // ( // [0] => tweedledum tweedledee // [1] => tweedledee // ) preg_match('/(a|(b))+/', 'aba', $matches); print_r($matches); // Array // ( // [0] => aba // [1] => a // [2] => b // ) PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) > PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.repetition.php">Repetition</a> (반복)</h3>
<p>반복은 다음 항목 중 하나를 따를 수 있는 한정 기호로 지정된다.</p>
<ul>
<li><a href="/2017/01/10/php-regex-escape-sequences/">이스케이프</a> 가능한 단일 문자</li>
<li><a href="/2017/01/13/php-regex-dot/"><code>.</code> 메타 문자</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">캐릭터 클래스</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">back reference(역 참조)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">어설션</a>이 아닌 괄호로 묶인 <a href="/2017/01/17/php-regex-subpatterns/">서브 패턴</a></li>
</ul>
<p>일반적으로 반복값은 괄호(<code>{}</code>) 안에 쉼표로 구분 된 두 개의 숫자를 입력하여 허용되는 일치의 최소 및 최대 수를 지정한다. 숫자는 65536 보다 작아야 하며 첫 번째 숫자는 두 번째 숫자보다 작거나 같아야 한다. 예를 들어, <code>z{2,4}</code>는 &quot;zz&quot;, &quot;zzz&quot; 또는 &quot;zzzz&quot;와 일치한다.</p>
<p>단독으로 닫는 중괄호는 특수 문자가 아니다. 두 번째 숫자가 생략 되었으나 쉼표가 있으면 상한이 없다. 두 번째 숫자와 쉼표가 둘 다 생략되면 수량 기호는 필요한 일치 항목의 정확한 수를 지정한다. 따라서 <code>[aeiou]{3,}</code>는 최소 3개의 연속 모음과 일치하지만 <code>\d{8}</code>은 정확히 8자리 숫자와 일치한다. 한정 기호가 허용되지 않는 위치나 한정 기호의 구문과 일치하지 않는 위치에 나타나는 여는 중괄호(<code>{</code>)는 리터럴 문자로 사용된다. 예를 들어, <code>{,6}</code>은 한정 기호가 아니라 4자의 리터럴 문자열이다.</p>
<p>한정자 <code>{0}</code>이 허용되어 표현식이 이전 항목 및 한정 기호가 없는 것처럼 동작한다.</p>
<p>편의상 (그리고 전통적인 호환성) 세 가지 가장 일반적인 수량 기호는 한 문자로 된 약자를 사용한다 :</p>
<h4>Single-character quantifiers</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">문자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>*</code></td>
<td><code>{0,}</code>와 같다</td>
</tr>
<tr>
<td style="text-align: center;"><code>+</code></td>
<td><code>{1,}</code>와 같다</td>
</tr>
<tr>
<td style="text-align: center;"><code>?</code></td>
<td><code>{0,1}</code>와 같다</td>
</tr>
</tbody>
</table>
<p>상한이 없는 수량 기호와 일치하지 않는 서브 패턴을 따라 무한 루프를 구성 할 수 있다(예 : <code>(a?)*</code>).</p>
<p>이전 버전의 Perl과 PCRE는 그러한 패턴을 컴파일 할 때 오류를 내기도 했다. 그러나 이 방법이 유용 할 수 있기 때문에 이러한 패턴이 이제 허용되지만 실제로 서브 패턴의 반복이 실제로 문자와 일치하지 않으면 루프가 강제로 끊어진다.</p>
<p>기본적으로 한정 기호는 &quot;greedy&quot; 즉 패턴의 나머지 부분을 실패시키지 않고 가능한 한 최대 허용 횟수까지 일치시킨다. 이것이 문제를 일으키는 곳의 고전적인 예는 C 프로그램의 주석과 일치하는 것이다. 시퀀스 <code>/*</code>와 <code>*/</code> 사이에 나타나며 시퀀스 내에서 개별 <code>*</code> 및 <code>/</code> 문자가 나타날 수 있다. 첫 번째 주석 <code>*/</code> 주석 <code>/*</code> 두 번째 주석 <code>*/</code>에 문자열 <code>/**.*\*/</code> 패턴을 적용하여 C 주석을 일치 시키려는 시도는 <code>.*</code>의 탐욕(&quot;greedy&quot;)으로 인해 전체 문자열과 일치하기 때문에 실패한다.</p>
<p>그러나 수량 기호 다음에 물음표가 오는 경우에는 게으르며(lazy) 가능한 최소 횟수와 일치하므로 패턴 <code>/\*.*?\*/</code>는 C 주석과 함께 올바른 작업을 수행한다. 다양한 한정어의 의미는 다른 방식으로 변경되지 않으며 선호하는 일치 개수만 변경된다. 이 <code>?</code> 사용을 그 자체로 한정 기호로 사용하는 것과 혼동하지 말아야 한다. 두 가지 용도로 사용되기 때문에 <code>\d??\d</code>와 같이 두 글자로 표시되는 경우가 있다. 한 글자가 기본 설정과 일치하지만 나머지 패턴 일치하는 경우 두 글자와 일치할 수 있다.</p>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_UNGREEDY</a> 옵션이 설정되어 있으면 (Perl에서는 사용할 수없는 옵션) 수량 한정자는 기본적으로 탐욕이 없다. 하지만 개별적인 물음표는 물음표를 따라 가면서 탐욕이 적용된다. 즉, 기본 동작을 반전합니다.</p>
<p><code>+</code>를 따르는 한정 기호는 &quot;possessive&quot;이다. 가능한 한 많은 문자와 매치하고 나머지 패턴과 일치하도록 돌아 가지 않는다. 따라서 <code>.*abc</code>는 &quot;aabc&quot;와 일치하지만 <code>.*+</code>는 전체 문자를 매치하기 때문에 <code>.*+abc</code>은 일치하지 않는다. Possessive 지정자는 처리 속도를 높이는 데 사용할 수 있다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$str</span> = <span class="hljs-string">'aabc'</span>;
preg_match(<span class="hljs-string">'/.*abc/'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">// Array</span>
<span class="hljs-comment">// (</span>
<span class="hljs-comment">//  [0] =&gt; aabc</span>
<span class="hljs-comment">// )</span>

preg_match(<span class="hljs-string">'/.*+abc/'</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">// Array</span>
<span class="hljs-comment">// (</span>
<span class="hljs-comment">// )</span></pre>
<p>괄호 안의 서브 패턴이 최소 반복 횟수가 1 보다 크거나 제한된 최대 값으로 정량화되면 컴파일 된 패턴에 최소 또는 최대 크기에 비례하여 더 많은 저장소가 필요하다.</p>
<p>패턴이 <code>.*</code> 또는 <code>.{0,}</code>으로 시작하고 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a> 옵션(Perl의 <code>/s</code>와 동일)이 설정되어 있으므로 <code>.</code>을 줄바꿈과 일치 시키려면 패턴은 암시적으로 고정되어 있다. 왜냐하면 뒤에 오는 것은  문자열의 모든 문자 위치에 대해 시도된다. 따라서 첫 번째 이후의 모든 위치에서 전체 일치를 다시 시도 할 필요가 없다. PCRE(Perl Compatible Regular Expressions)는 앞에 <code>\A</code>가 붙은 것처럼 패턴을 처리한다. 대상 문자열에 개행 문자가 없는 것으로 알려진 경우 패턴이 <code>.*</code>로 시작하는 경우 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a>을 설정하거나 최적화를 위해 <code>^</code>를 사용하여 명시적으로 고정을 나타낼 수 있다.</p>
<p>캡처 서브 패턴이 반복되면 캡처된 값은 최종 반복과 일치하는 하위 문자열이다. 예를 들어, <code>(tweedle[dume]{3}\s*)+</code>가 &quot;tweedledum tweedledee&quot;와 일치하면 캡처된 부분 문자열의 값은 &quot;tweedledee&quot;이다. 그러나 중첩된 캡처 서브 패턴이 있으면 해당 캡처 값이 이전 반복에서 설정 되었을 수 있다. 예를 들어,  <code>/(a|(b))+/</code>가 &quot;aba&quot;와 일치하면 두 번째로 캡처 된 하위 문자열의 값은 &quot;b&quot;가 된다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-preprocessor">&lt;?php</span>
preg_match(<span class="hljs-string">'/(tweedle[dume]{3}\s*)+/'</span>, <span class="hljs-string">'tweedledum tweedledee'</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">// Array</span>
<span class="hljs-comment">// (</span>
<span class="hljs-comment">//  [0] =&gt; tweedledum tweedledee</span>
<span class="hljs-comment">//  [1] =&gt; tweedledee</span>
<span class="hljs-comment">// )</span>

preg_match(<span class="hljs-string">'/(a|(b))+/'</span>, <span class="hljs-string">'aba'</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">// Array</span>
<span class="hljs-comment">// (</span>
<span class="hljs-comment">//  [0] =&gt; aba</span>
<span class="hljs-comment">//  [1] =&gt; a</span>
<span class="hljs-comment">//  [2] =&gt; b</span>
<span class="hljs-comment">// )</span></pre>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</strong></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/17/php-regex-subpatterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/17/php-regex-subpatterns/"/><published>2017-01-17T17:57:41+00:00</published><updated>2017-01-17T17:57:41+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Subpatterns (서브 패턴) 서브 패턴은 둥근 괄호(())로 구분되며 중첩 될 수 있다. 패턴의 일부를 서브 패턴으로 표시하는 것은 다음 두 가지를 수행한다. 대안 집합을 지역화 한다. 예를 들어 cat(aract|erpillar|) 패턴은 "cat", "cataract" 또는 "caterpillar" 중 하나와 일치한다. 괄호가 없으면 "cataract", "erpillar" 또는 빈 문자열과 일치한다. 서브 패턴을 캡처 서브 패턴으로 설정한다. 전체 패턴이 일치하면 서브 패턴과 일치하는 문자열의 부분은 pcre_exec()의 ovector 인수를 통해 호출자에게 다시 전달된다. 여는 괄호는 왼쪽에서 오른쪽으로 (1부터 시작) 카운트하여 캡처 서브 패턴의 수를 얻는다. 예를 들어 문자열 "the red king"이 ((red|white) (king|queen)) 패턴과 일치하면 캡처된 부분 문자열이 "red king", "red"및 "king"이며 아래와 같이 번호가 매겨진다. <?php $string = 'the red king'; preg_match('/((red|white) (king|queen))/', $string, $matches); print_r($matches); //Array //( // [0] => red king // [1] => red king // [2] => red // [3] => king //) 평범한 괄호가 두 가지 기능을 수행한다는 사실이 항상 도움이되는 것은 아니다. 캡처 요구 사항없이 그룹화 서브 패턴이 필요한 경우가 종종 있다. 여는 괄호 뒤에 "?:"가 오는 경우 서브 패턴은 캡처를 수행하지 않으며 후속 캡처 서브 패턴의 수를 계산할 때는 계산되지 않는다. 예를 들어 문자열 "the white queen"이 ((?:red|white) (king|queen)) 패턴과 일치하면 캡처 된 부분 문자열은 "white queen"과 "queen"이며 1과 2로 번호가 매겨진다. 캡처된 부분 문자열의 최대 수는 99이며 캡처 및 비 캡처의 모든 서브 패턴의 최대 수는 200개다. <?php $string = 'the white queen'; preg_match('/((?:red|white) (king|queen))/', $string, $matches); print_r($matches); //Array //( // [0] => white queen // [1] => white queen // [2] => queen //) 캡처하지 않는 서브 패턴의 옵션이 필요한 경우 아래의 두 예시 처럼 "?" 그리고 ":" 사이에 옵션을 표기할 수 있다. (?i:saturday|sunday) (?:(?i)saturday|sunday) 정확히 동일한 문자열 세트와 일치해야 한다. 대체 분기는 왼쪽에서 오른쪽으로 시도되고 서브 패턴의 끝에 도달 할 때까지 옵션이 재설정되지 않아 한 분기의 옵션 설정이 후속 분기에 영향을 미치므로 위 패턴은 "SUNDAY"및 "Saturday"와 일치한다. <?php preg_match('/(?i:saturday|sunday)/','Saturday', $matches); print_r($matches); // Array // ( // [0] => Saturday // ) preg_match('/(?:(?i)saturday|sunday)/','SUNDAY', $matches); print_r($matches); // Array // ( // [0] => SUNDAY // ) 구문 (?P<name>pattern)을 사용하여 서브 패턴의 이름을 지정할 수 있다. 그런 다음이 서브 패턴은 matches 배열에서 일반 숫자 위치와 이름을 기준으로 인덱싱 된다(PHP 5.2.2에서는 두 가지 대체 구문 (?<name>pattern)과 (?'name'pattern)을 사용할 수 있다). <?php $string = 'the white queen'; preg_match('/(?P<name>the)/', $string, $matches); print_r($matches); preg_match("/(?'name'the)/", $string, $matches); print_r($matches); //Array //( // [0] => the // [name] => the // [1] => the //) //Array //( // [0] => the // [name] => the // [1] => the //) 때로는 일치하는 여러 개의 서브 그룹을 정규식에 포함시켜야 할 필요가 있다. 일반적으로 이들 중 하나만 일치할 가능성이 있더라도 각각의 고유한 역 참조 번호가 부여된다. 이 문제를 극복하기 위해 (?| 구문을 사용하면 중복되는 숫자를 가질 수 있다. 다음 정규식 (?:(Sat)ur|(Sun))day을 "Sunday" 문자열과 비교해보자. <?php $string = 'Sunday'; preg_match('/(?:(Sat)ur|(Sun))day/', $string, $matches); print_r($matches); //Array //( // [0] => Sunday // [1] => // [2] => Sun //) 여기에서 "Sun"은 역 참조 2에 저장되고 역 참조 1은 비어 있다. 역 참조 1에서의 "Sat"는 역 참조 2에서 존재하지 않는다. (?|를 사용하여 패턴을 변경하면 이 문제가 해결된다. <?php $string = 'Sunday'; preg_match('/(?|(Sat)ur|(Sun))day/', $string, $matches); print_r($matches); //Array //( // [0] => Sunday // [1] => Sun //) 이 패턴을 사용하면 Sun과 Sat가 모두 역 참조 1에 저장된다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) > PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.subpatterns.php">Subpatterns</a> (서브 패턴)</h3>
<p>서브 패턴은 둥근 괄호(<code>()</code>)로 구분되며 중첩 될 수 있다. 패턴의 일부를 서브 패턴으로 표시하는 것은 다음 두 가지를 수행한다.</p>
<ol>
<li>
<p><a href="/2017/01/15/php-regex-alternation/">대안 집합</a>을 지역화 한다. 예를 들어 <code>cat(aract|erpillar|)</code> 패턴은 &quot;cat&quot;, &quot;cataract&quot; 또는 &quot;caterpillar&quot; 중 하나와 일치한다. 괄호가 없으면 &quot;cataract&quot;, &quot;erpillar&quot; 또는 빈 문자열과 일치한다.</p>
</li>
<li>서브 패턴을 캡처 서브 패턴으로 설정한다. 전체 패턴이 일치하면 서브 패턴과 일치하는 문자열의 부분은 <code>pcre_exec()</code>의 <code>ovector</code> 인수를 통해 호출자에게 다시 전달된다. 여는 괄호는 왼쪽에서 오른쪽으로 (1부터 시작) 카운트하여 캡처 서브 패턴의 수를 얻는다.</li>
</ol>
<p>예를 들어 문자열 &quot;the red king&quot;이 <code>((red|white) (king|queen))</code>  패턴과 일치하면 캡처된 부분 문자열이 &quot;red king&quot;, &quot;red&quot;및 &quot;king&quot;이며 아래와 같이 번호가 매겨진다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'the red king'</span>;
preg_match(<span class="hljs-string">'/((red|white) (king|queen))/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; red king</span>
<span class="hljs-comment">//  [1] =&gt; red king</span>
<span class="hljs-comment">//  [2] =&gt; red</span>
<span class="hljs-comment">//  [3] =&gt; king</span>
<span class="hljs-comment">//)</span></pre>
<p>평범한 괄호가 두 가지 기능을 수행한다는 사실이 항상 도움이되는 것은 아니다. 캡처 요구 사항없이 그룹화 서브 패턴이 필요한 경우가 종종 있다. 여는 괄호 뒤에 &quot;<code>?:</code>&quot;가 오는 경우 서브 패턴은 캡처를 수행하지 않으며 후속 캡처 서브 패턴의 수를 계산할 때는 계산되지 않는다.</p>
<p>예를 들어 문자열 &quot;the white queen&quot;이 <code>((?:red|white) (king|queen))</code> 패턴과 일치하면 캡처 된 부분 문자열은 &quot;white queen&quot;과 &quot;queen&quot;이며 1과 2로 번호가 매겨진다. 캡처된 부분 문자열의 최대 수는 99이며 캡처 및 비 캡처의 모든 서브 패턴의 최대 수는 200개다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'the white queen'</span>;
preg_match(<span class="hljs-string">'/((?:red|white) (king|queen))/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; white queen</span>
<span class="hljs-comment">//  [1] =&gt; white queen</span>
<span class="hljs-comment">//  [2] =&gt; queen</span>
<span class="hljs-comment">//)</span></pre>
<p>캡처하지 않는 서브 패턴의 옵션이 필요한 경우 아래의 두 예시 처럼 &quot;?&quot; 그리고 &quot;:&quot; 사이에 옵션을 표기할 수 있다.</p>
<pre><code>(?i:saturday|sunday)
(?:(?i)saturday|sunday)</code></pre>
<p>정확히 동일한 문자열 세트와 일치해야 한다. 대체 분기는 왼쪽에서 오른쪽으로 시도되고 서브 패턴의 끝에 도달 할 때까지 옵션이 재설정되지 않아 한 분기의 옵션 설정이 후속 분기에 영향을 미치므로 위 패턴은 &quot;SUNDAY&quot;및 &quot;Saturday&quot;와 일치한다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
preg_match(<span class="hljs-string">'/(?i:saturday|sunday)/'</span>,<span class="hljs-string">'Saturday'</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">// Array</span>
<span class="hljs-comment">// (</span>
<span class="hljs-comment">//     [0] =&gt; Saturday</span>
<span class="hljs-comment">// )</span>

preg_match(<span class="hljs-string">'/(?:(?i)saturday|sunday)/'</span>,<span class="hljs-string">'SUNDAY'</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">// Array</span>
<span class="hljs-comment">// (</span>
<span class="hljs-comment">//     [0] =&gt; SUNDAY</span>
<span class="hljs-comment">// )</span></pre>
<p>구문 <code>(?P&lt;name&gt;pattern)</code>을 사용하여 서브 패턴의 이름을 지정할 수 있다. 그런 다음이 서브 패턴은 matches 배열에서 일반 숫자 위치와 이름을 기준으로 인덱싱 된다(PHP 5.2.2에서는 두 가지 대체 구문 <code>(?&lt;name&gt;pattern)</code>과 <code>(?'name'pattern)</code>을 사용할 수 있다).</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'the white queen'</span>;
preg_match(<span class="hljs-string">'/(?P&lt;name&gt;the)/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
preg_match(<span class="hljs-string">"/(?'name'the)/"</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; the</span>
<span class="hljs-comment">//  [name] =&gt; the</span>
<span class="hljs-comment">//  [1] =&gt; the</span>
<span class="hljs-comment">//)</span>
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; the</span>
<span class="hljs-comment">//  [name] =&gt; the</span>
<span class="hljs-comment">//  [1] =&gt; the</span>
<span class="hljs-comment">//)</span></pre>
<p>때로는 일치하는 여러 개의 서브 그룹을 정규식에 포함시켜야 할 필요가 있다. 일반적으로 이들 중 하나만 일치할 가능성이 있더라도 각각의 고유한 역 참조 번호가 부여된다. 이 문제를 극복하기 위해 <code>(?|</code> 구문을 사용하면 중복되는 숫자를 가질 수 있다. 다음 정규식 <code>(?:(Sat)ur|(Sun))day</code>을 &quot;Sunday&quot; 문자열과 비교해보자.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'Sunday'</span>;
preg_match(<span class="hljs-string">'/(?:(Sat)ur|(Sun))day/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; Sunday</span>
<span class="hljs-comment">//  [1] =&gt;</span>
<span class="hljs-comment">//  [2] =&gt; Sun</span>
<span class="hljs-comment">//)</span></pre>
<p>여기에서 &quot;Sun&quot;은 역 참조 2에 저장되고 역 참조 1은 비어 있다. 역 참조 1에서의 &quot;Sat&quot;는 역 참조 2에서 존재하지 않는다. <code>(?|</code>를 사용하여 패턴을 변경하면 이 문제가 해결된다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'Sunday'</span>;
preg_match(<span class="hljs-string">'/(?|(Sat)ur|(Sun))day/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; Sunday</span>
<span class="hljs-comment">//  [1] =&gt; Sun</span>
<span class="hljs-comment">//)</span></pre>
<p>이 패턴을 사용하면 Sun과 Sat가 모두 역 참조 1에 저장된다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</strong></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/16/php-regex-internal-option-setting/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/16/php-regex-internal-option-setting/"/><published>2017-01-16T14:36:21+00:00</published><updated>2017-01-16T14:36:21+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Internal option setting (내부 옵션 설정) PHP 정규표현식 패턴에 존재하는 변경자와 유사하게 사용되나 사용 위치가 다르다. PCRE_CASELESS, PCRE_MULTILINE,PCRE_DOTALL, PCRE_UNGREEDY, PCRE_EXTRA, PCRE_EXTENDED 및 PCRE_DUPNAMES의 설정은 "(?" 및 ")"로 묶인 Perl 옵션 문자 시퀀스에 의해 패턴 내에서 변경할 수 있다. 옵션 문자는 다음과 같다. Internal option letters 옵션 설명 i PCRE_CASELESS m PCRE_MULTILINE s PCRE_DOTALL x PCRE_EXTENDED U PCRE_UNGREEDY X PCRE_EXTRA J PCRE_INFO_JCHANGED 예를 들어, (?im)은 대소문자를 구분하지 않고 (caseless) 여러 줄 일치를 설정한다. 문자 앞에 하이픈을 붙여 이러한 옵션의 설정을 해제 할 수도 있으며 PCRE_DOTALL 및 PCRE_EXTENDED 설정을 해제 하면서 PCRE_CASELESS 및 PCRE_MULTILINE을 설정하는 (?im-sx)와 같은 조합된 설정 및 해제도 허용된다. 하이픈 앞과 뒤 모두에 옵션이 표시되면 설정되지 않는다. 옵션 변경이 최상위 레벨에서 발생하면(즉, 서브 패턴 괄호 안쪽에 있는 경우), 변경 사항은 뒤 따르는 패턴의 나머지 부분에 적용됩니다. 그래서 /ab(?i)c/는 "abc"와 "abC"에만 일치한다. 서브 패턴 내에서 옵션 변경이 발생하면 효과가 달라진다. 이것은 Perl 5.005의 동작 변경이다. 서브 패턴 내부의 옵션 변경은 그 뒤에 오는 서브 패턴의 해당 부분에만 영향을 미치므로 a(?i)b)c는 abc 및 aBc와 일치하며 다른 문자열은 없다 (PCRE_CASELESS가 사용되지 않는다고 가정). 이 방법을 사용하면 패턴의 다른 부분에서 옵션을 다르게 설정할 수 있다. 하나의 대안에서 변경한 사항은 동일한 서브 패턴 내의 후속 분기로 이어진다. 예를 들어 (a(?i)b|c)는 "ab", "aB", "c"및 "C"와 일치하지만 "C"와 일치할 때 첫 번째 분기가 옵션 설정 전에 취소 되더라도 마찬가지다. 이것은 옵션 설정의 효과가 컴파일 타임에 발생하기 때문이다. 이것은 조금 이상할 수 있다. PCRE 특정 옵션 PCRE_UNGREEDY 및 PCRE_EXTRA는 각각 U 및 X 문자를 사용하여 Perl 호환 옵션과 동일한 방식으로 변경할 수 있다. (?X) 플래그 설정은 최상위 레벨에서 활성화 되는 추가 기능보다 항상 먼저 실행되어야 하는 점에서 특별하다. 따라서 시작 부분에 넣는 것이 가장 좋다. <?php // PCRE_EXTRA (?X) Strict escape parsing echo (preg_match('/\y/', 'abc\ydef') ? 'true' : 'false') . "\n"; // true echo (preg_match('/\y/X', 'abc\ydef') ? 'true' : 'false') . "\n"; // Warning: preg_match(): Compilation failed: unrecognized character follows \ at offset 1 in _test.php on line 7 // false echo (preg_match('/\\\\y/X', 'abc\ydef') ? 'true' : 'false') . "\n"; // true echo (preg_match('/(?X)\ydef/', 'abc\ydef') ? 'true' : 'false') . "\n"; // Warning: preg_match(): Compilation failed: unrecognized character follows \ at offset 5 in _test.php on line 14 // false echo (preg_match('/(?X)\\\\ydef/', 'abc\ydef') ? 'true' : 'false') . "\n"; // true echo (preg_match('/\y(?X)def/', 'abc\ydef') ? 'true' : 'false') . "\n"; // true PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) > PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.internal-options.php">Internal option setting</a> (내부 옵션 설정)</h3>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PHP 정규표현식 패턴에 존재하는 변경자</a>와 유사하게 사용되나 사용 위치가 다르다.</p>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_CASELESS</a>, <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_MULTILINE</a>,<a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a>, <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_UNGREEDY</a>, <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTRA</a>, <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 및 PCRE_DUPNAMES의 설정은 &quot;<code>(?</code>&quot; 및 &quot;<code>)</code>&quot;로 묶인 Perl 옵션 문자 시퀀스에 의해 패턴 내에서 변경할 수 있다.</p>
<p>옵션 문자는 다음과 같다.</p>
<h4>Internal option letters</h4>
<table>
<thead>
<tr>
<th>옵션</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_CASELESS</a></td>
</tr>
<tr>
<td>m</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_MULTILINE</a></td>
</tr>
<tr>
<td>s</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a></td>
</tr>
<tr>
<td>x</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a></td>
</tr>
<tr>
<td>U</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_UNGREEDY</a></td>
</tr>
<tr>
<td>X</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTRA</a></td>
</tr>
<tr>
<td>J</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_INFO_JCHANGED</a></td>
</tr>
</tbody>
</table>
<p>예를 들어, <code>(?im)</code>은 대소문자를 구분하지 않고 (caseless) 여러 줄 일치를 설정한다. 문자 앞에 하이픈을 붙여 이러한 옵션의 설정을 해제 할 수도 있으며 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a> 및 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 설정을 해제 하면서 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_CASELESS</a> 및 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_MULTILINE</a>을 설정하는 <code>(?im-sx)</code>와 같은 조합된 설정 및 해제도 허용된다. 하이픈 앞과 뒤 모두에 옵션이 표시되면 설정되지 않는다.</p>
<p>옵션 변경이 최상위 레벨에서 발생하면(즉, 서브 패턴 괄호 안쪽에 있는 경우), 변경 사항은 뒤 따르는 패턴의 나머지 부분에 적용됩니다. 그래서 <code>/ab(?i)c/</code>는 &quot;abc&quot;와 &quot;abC&quot;에만 일치한다.</p>
<p>서브 패턴 내에서 옵션 변경이 발생하면 효과가 달라진다. 이것은 Perl 5.005의 동작 변경이다. 서브 패턴 내부의 옵션 변경은 그 뒤에 오는 서브 패턴의 해당 부분에만 영향을 미치므로 <code>a(?i)b)c</code>는 abc 및 aBc와 일치하며 다른 문자열은 없다 (<a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_CASELESS</a>가 사용되지 않는다고 가정). 이 방법을 사용하면 패턴의 다른 부분에서 옵션을 다르게 설정할 수 있다. 하나의 대안에서 변경한 사항은 동일한 서브 패턴 내의 후속 분기로 이어진다. 예를 들어 <code>(a(?i)b|c)</code>는 &quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;및 &quot;C&quot;와 일치하지만 &quot;C&quot;와 일치할 때 첫 번째 분기가 옵션 설정 전에 취소 되더라도 마찬가지다. 이것은 옵션 설정의 효과가 컴파일 타임에 발생하기 때문이다. 이것은 조금 이상할 수 있다.</p>
<p>PCRE 특정 옵션 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_UNGREEDY</a> 및 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTRA</a>는 각각 <code>U</code> 및 <code>X</code> 문자를 사용하여 Perl 호환 옵션과 동일한 방식으로 변경할 수 있다. <code>(?X)</code> 플래그 설정은 최상위 레벨에서 활성화 되는 추가 기능보다 항상 먼저 실행되어야 하는 점에서 특별하다. 따라서 시작 부분에 넣는 것이 가장 좋다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-comment">// PCRE_EXTRA   (?X)    Strict escape parsing</span>

<span class="hljs-keyword">echo</span> (preg_match(<span class="hljs-string">'/\y/'</span>, <span class="hljs-string">'abc\ydef'</span>) ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// true</span>

<span class="hljs-keyword">echo</span> (preg_match(<span class="hljs-string">'/\y/X'</span>, <span class="hljs-string">'abc\ydef'</span>) ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// Warning: preg_match(): Compilation failed: unrecognized character follows \ at offset 1 in _test.php on line 7</span>
<span class="hljs-comment">// false</span>

<span class="hljs-keyword">echo</span> (preg_match(<span class="hljs-string">'/\\\\y/X'</span>, <span class="hljs-string">'abc\ydef'</span>) ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// true</span>

<span class="hljs-keyword">echo</span> (preg_match(<span class="hljs-string">'/(?X)\ydef/'</span>, <span class="hljs-string">'abc\ydef'</span>) ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// Warning: preg_match(): Compilation failed: unrecognized character follows \ at offset 5 in _test.php on line 14</span>
<span class="hljs-comment">// false</span>

<span class="hljs-keyword">echo</span> (preg_match(<span class="hljs-string">'/(?X)\\\\ydef/'</span>, <span class="hljs-string">'abc\ydef'</span>) ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// true</span>

<span class="hljs-keyword">echo</span> (preg_match(<span class="hljs-string">'/\y(?X)def/'</span>, <span class="hljs-string">'abc\ydef'</span>) ? <span class="hljs-string">'true'</span> : <span class="hljs-string">'false'</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-comment">// true</span></pre>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</strong></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>


</feed>