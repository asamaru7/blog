<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

<title>이 세상에 하나는 남기고 가자</title><id>https://blog.asamaru.net/</id><updated>2017-01-24T06:53:19+00:00</updated><subtitle>세상에 필요한 소스코드 한줄 남기고 가자</subtitle><link href="https://blog.asamaru.net/" rel="alternate" type="text/html" /><link href="https://blog.asamaru.net/atom.xml" rel="self" type="application/atom+xml" /><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author>
<entry><id>https://blog.asamaru.net/2017/01/25/php-regex-epilogue/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 에필로그</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/25/php-regex-epilogue/"/><published>2017-01-25T11:45:13+00:00</published><updated>2017-01-25T11:45:13+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 앞선 글들에서 PCRE에 대한 전반적인 내용을 소개 했다. 일부는 내용이 이해하기 어려울 수 있다. 나름 이해가 어려운 부분은 예시를 추가해서 이해를 돕고자 했으나 부족할 것으로 보인다. 아마도 PCRE를 익히는 가장 좋은 방법은 직접 패턴을 만들어 보면서 학습하는 것일 것이다. PCRE에 대한 소개를 마치며 학습 및 활용에 도움이 될 수 있는 몇가지 사이트와 예시들을 남겨둔다. 정규식을 웹 상에서 테스트해 볼 수 있는 사이트를 소개한다(검색해보면 더 많은 사이트들이 존재하니 자신에게 맞는 사이트를 사용하면 된다). regular xpressions 101 : PHP, PCRE, Python, Golang, JavaScript 정규식을 테스트 할 수 있다. 그리고 입력한 정규식 패턴에 대한 설명과 매칭 결과를 상세히 보여줘서 상당히 유용하다. PHP Live Regex : PHP 정규식(PCRE)만 지원하지만 preg_match, preg_replace 등의 함수 등의 실행 결과를 바로 확인 할 수 있어 편리하다. 다음은 정규식 사용 예시를 몇가지 남겨둔다. 웹 상에서 공개되어 있는 예시들도 있고 직접 만들어 사용했던 정규식도 포함되어 있다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) > PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<p>앞선 글들에서 PCRE에 대한 전반적인 내용을 소개 했다. 일부는 내용이 이해하기 어려울 수 있다. 나름 이해가 어려운 부분은 예시를 추가해서 이해를 돕고자 했으나 부족할 것으로 보인다. 아마도 PCRE를 익히는 가장 좋은 방법은 직접 패턴을 만들어 보면서 학습하는 것일 것이다.</p>
<p>PCRE에 대한 소개를 마치며 학습 및 활용에 도움이 될 수 있는 몇가지 사이트와 예시들을 남겨둔다.</p>
<hr />
<p>정규식을 웹 상에서 테스트해 볼 수 있는 사이트를 소개한다(검색해보면 더 많은 사이트들이 존재하니 자신에게 맞는 사이트를 사용하면 된다).</p>
<ul>
<li><a href="https://regex101.com/">regular xpressions 101</a> : PHP, PCRE, Python, Golang, JavaScript 정규식을 테스트 할 수 있다. 그리고 입력한 정규식 패턴에 대한 설명과 매칭 결과를 상세히 보여줘서 상당히 유용하다.</li>
<li><a href="http://www.phpliveregex.com/">PHP Live Regex</a> : PHP 정규식(PCRE)만 지원하지만 preg_match, preg_replace 등의 함수 등의 실행 결과를 바로 확인 할 수 있어 편리하다.</li>
</ul>
<hr />
<p>다음은 정규식 사용 예시를 몇가지 남겨둔다. 웹 상에서 공개되어 있는 예시들도 있고 직접 만들어 사용했던 정규식도 포함되어 있다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 에필로그</strong></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/24/php-regex-recursive-patterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/24/php-regex-recursive-patterns/"/><published>2017-01-24T11:22:11+00:00</published><updated>2017-01-24T11:22:11+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 Recursive patterns (재귀 패턴) 무한대의 중첩 괄호를 허용하면서 괄호 안의 문자열을 일치시키는 문제를 고려하자. 재귀를 사용하지 않고 수행 할 수있는 최상의 방법은 중첩의 고정 된 깊이까지 일치하는 패턴을 사용하는 것이다. 임의의 중첩 깊이는 처리 할 수 ​​없다. Perl 5.6은 (다른 것들 중에서) 정규식을 반복 할 수있는 실험적 기능을 제공한다. 특수 항목 (?R)은 재귀의 특정 경우에 대해 제공된다. 이 PCRE 패턴은 괄호 문제를 해결한다 (공백을 무시하도록 PCRE_EXTENDED 옵션이 설정되어 있다고 가정한다) : \( ( (?>[^()]+) | (?R) )* \) 먼저 여는 괄호와 일치한다. 그런 다음 괄호가 아닌 시퀀스 또는 패턴 자체의 재귀 일치 (예 : 올바르게 괄호로 묶은 부분 문자열)가 될 수있는 임의의 수의 하위 문자열을 찾는다. 마지막으로 닫는 괄호가 있다. 이 특정 예제 패턴에는 중첩 된 무제한 반복이 포함되어 있으므로 일치하지 않는 문자열에 패턴을 적용 할 때 괄호가 아닌 문자열을 일치시키는데 한 번만 사용하는 서브 패턴을 사용하는 것이 중요하다. 예를 들어 "(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()"에 적용하면 신속하게 "일치하지 않음"을 나타낸다. 단 한 번만 사용하는 서브 패턴을 사용하지 않으면 매우 많은 다른 방법이 있으므로 실제로 매우 긴 시간 동안 일치가 실행됩니다. * 반복은 주제를 개척 할 수 있으며 실패가보고되기 전에 모두 테스트되어야한다. 캡춰 서브 패턴에 설정되는 값은 서브 패턴 값이 설정되어있는 재귀의 최 외각 레벨의 값입니다. 위의 패턴이 (ab(cd)ef)와 일치하면 캡처 괄호의 값은 최상위 수준에서 마지막으로 취해진 값인 "ef"입니다. 추가 괄호가 추가되면 \( ( ( (?>[^()]+) | (?R) )* ) \) 다음에 캡처하는 문자열은 "ab(cd)ef" 수준 괄호 패턴에 15 개 이상의 캡처 괄호가있는 경우 PCRE는 재귀 중에 데이터를 저장하기 위해 추가 메모리를 확보해야 한다. 재귀는 pcre_malloc을 사용하여 수행 한 후 나중에 pcre_free를 통해 해제한다. 메모리를 확보 할 수 없으면 재귀 내에서 메모리 부족 오류를 제공 할 방법이 없기 때문에 처음 15 개의 캡처 링 괄호에 대한 데이터만 저장한다. (?1), (?2) 등은 재귀 서브 패턴에도 사용될 수있다. 또한 명명 된 서브 패턴 (?P>name) 또는 (?P&name)을 사용할 수도 있다. 재귀적 서브 패턴 참조 (숫자 또는 이름 기준)의 구문이 참조되는 괄호 밖에서 사용되면 프로그래밍 언어의 서브 루틴처럼 작동한다. 앞의 예는 패턴 (sens|respons)e와 \1 가능성이 "sense and sensibility"과 "response and responsibility"과 일치하지만 "sense and responsibility"과는 일치하지 않는다고 지적했다. 대신에 패턴 (sens|respons)e 및 (?1)ibility가 사용되면 다른 두 문자열과 마찬가지로 "sense and responsibility"와 일치한다. 그러나 이러한 참조는 참조하는 서브 패턴을 따라야 한다. 제목 문자열의 최대 길이는 정수 변수가 보유 할 수 있는 최대 양수이다. 그러나 PCRE는 재귀를 사용하여 서브 패턴과 무한 반복을 처리한다. 이는 사용 가능한 스택 공간이 특정 패턴으로 처리 할 수있는 제목 문자열의 크기를 제한 할 수 있음을 의미한다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) > PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3><a href="http://php.net/manual/kr/regexp.reference.recursive.php">Recursive patterns</a> (재귀 패턴)</h3>
<p>무한대의 중첩 괄호를 허용하면서 괄호 안의 문자열을 일치시키는 문제를 고려하자. 재귀를 사용하지 않고 수행 할 수있는 최상의 방법은 중첩의 고정 된 깊이까지 일치하는 패턴을 사용하는 것이다. 임의의 중첩 깊이는 처리 할 수 ​​없다. Perl 5.6은 (다른 것들 중에서) 정규식을 반복 할 수있는 실험적 기능을 제공한다. 특수 항목 <code>(?R)</code>은 재귀의 특정 경우에 대해 제공된다. 이 PCRE 패턴은 괄호 문제를 해결한다 (공백을 무시하도록 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션이 설정되어 있다고 가정한다) : <code>\( ( (?&gt;[^()]+) | (?R) )* \)</code></p>
<p>먼저 여는 괄호와 일치한다. 그런 다음 괄호가 아닌 시퀀스 또는 패턴 자체의 재귀 일치 (예 : 올바르게 괄호로 묶은 부분 문자열)가 될 수있는 임의의 수의 하위 문자열을 찾는다. 마지막으로 닫는 괄호가 있다.</p>
<p>이 특정 예제 패턴에는 중첩 된 무제한 반복이 포함되어 있으므로 일치하지 않는 문자열에 패턴을 적용 할 때 괄호가 아닌 문자열을 일치시키는데 한 번만 사용하는 서브 패턴을 사용하는 것이 중요하다. 예를 들어 &quot;(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()&quot;에 적용하면 신속하게 &quot;일치하지 않음&quot;을 나타낸다. 단 한 번만 사용하는 서브 패턴을 사용하지 않으면 매우 많은 다른 방법이 있으므로 실제로 매우 긴 시간 동안 일치가 실행됩니다. * 반복은 주제를 개척 할 수 있으며 실패가보고되기 전에 모두 테스트되어야한다.</p>
<p>캡춰 서브 패턴에 설정되는 값은 서브 패턴 값이 설정되어있는 재귀의 최 외각 레벨의 값입니다. 위의 패턴이 <code>(ab(cd)ef)</code>와 일치하면 캡처 괄호의 값은 최상위 수준에서 마지막으로 취해진 값인 &quot;ef&quot;입니다. 추가 괄호가 추가되면 <code>\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</code> 다음에 캡처하는 문자열은 &quot;ab(cd)ef&quot; 수준 괄호 패턴에 15 개 이상의 캡처 괄호가있는 경우 PCRE는 재귀 중에 데이터를 저장하기 위해 추가 메모리를 확보해야 한다. 재귀는 pcre_malloc을 사용하여 수행 한 후 나중에 pcre_free를 통해 해제한다. 메모리를 확보 할 수 없으면 재귀 내에서 메모리 부족 오류를 제공 할 방법이 없기 때문에 처음 15 개의 캡처 링 괄호에 대한 데이터만 저장한다.</p>
<p><code>(?1)</code>, <code>(?2)</code> 등은 재귀 서브 패턴에도 사용될 수있다. 또한 명명 된 서브 패턴 <code>(?P&gt;name)</code> 또는 <code>(?P&amp;name)</code>을 사용할 수도 있다.</p>
<p>재귀적 서브 패턴 참조 (숫자 또는 이름 기준)의 구문이 참조되는 괄호 밖에서 사용되면 프로그래밍 언어의 서브 루틴처럼 작동한다. 앞의 예는 패턴 <code>(sens|respons)e</code>와 <code>\1</code> 가능성이 &quot;sense and sensibility&quot;과 &quot;response and responsibility&quot;과 일치하지만 &quot;sense and responsibility&quot;과는 일치하지 않는다고 지적했다. 대신에 패턴 <code>(sens|respons)e</code> 및 <code>(?1)ibility</code>가 사용되면 다른 두 문자열과 마찬가지로 &quot;sense and responsibility&quot;와 일치한다. 그러나 이러한 참조는 참조하는 서브 패턴을 따라야 한다.</p>
<p>제목 문자열의 최대 길이는 정수 변수가 보유 할 수 있는 최대 양수이다. 그러나 PCRE는 재귀를 사용하여 서브 패턴과 무한 반복을 처리한다. 이는 사용 가능한 스택 공간이 특정 패턴으로 처리 할 수있는 제목 문자열의 크기를 제한 할 수 있음을 의미한다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</strong></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/23/php-regex-comments/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/23/php-regex-comments/"/><published>2017-01-23T14:12:12+00:00</published><updated>2017-01-23T14:12:12+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 Comments (주석) 시퀀스 (?#는 다음 닫는 괄호까지 이어지는 주석의 시작을 표시한다. 중첩된 괄호는 허용되지 않으며 주석을 구성하는 문자는 패턴 일치에 전혀 영향을 미치지 않는다. PCRE_EXTENDED 옵션을 설정하면 캐릭터 클래스 외부의 이스케이프 처리되지 않은 # 문자가 패턴의 다음 줄바꿈 문자까지 이어지는 주석을 나타냅니다. <?php $string = 'test'; echo preg_match('/te(?# 주석테스트)st/', $string) . "\n"; echo preg_match('/te#~~~~ st/', $string) . "\n"; echo preg_match('/te#~~~~ st/x', $string) . "\n"; // result // 1 // 0 // 1 // 두번째 정규식의 경우 x(PCRE_EXTENDED) 옵션이 없으므로 #~~~~을 주석으로 인정하지 않아 실패를 반환 PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) > PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3><a href="http://php.net/manual/kr/regexp.reference.comments.php">Comments</a> (주석)</h3>
<p>시퀀스 <code>(?#</code>는 다음 닫는 괄호까지 이어지는 주석의 시작을 표시한다.
중첩된 괄호는 허용되지 않으며 주석을 구성하는 문자는 패턴 일치에 전혀 영향을 미치지 않는다.</p>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션을 설정하면 <a href="/2017/01/14/php-regex-character-classes/">캐릭터 클래스</a> 외부의 <a href="/2017/01/10/php-regex-escape-sequences/">이스케이프</a> 처리되지 않은 <code>#</code> 문자가 패턴의 다음 줄바꿈 문자까지 이어지는 주석을 나타냅니다.</p>
<pre><code>&lt;?php
$string = 'test';
echo preg_match('/te(?# 주석테스트)st/', $string) . "\n";
echo preg_match('/te#~~~~
st/', $string) . "\n";
echo preg_match('/te#~~~~
st/x', $string) . "\n";

// result
// 1
// 0
// 1
// 두번째 정규식의 경우 x(PCRE_EXTENDED) 옵션이 없으므로 #~~~~을 주석으로 인정하지 않아 실패를 반환</code></pre>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</strong></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/22/php-regex-conditional-subpatterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/22/php-regex-conditional-subpatterns/"/><published>2017-01-22T09:18:45+00:00</published><updated>2017-01-22T09:18:45+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 Conditional subpatterns (조건부 서브 패턴) 조건부로 서브 패턴을 따르거나 어설션의 결과에 따라 두 개의 대체 서브 패턴 중 하나를 선택하거나 이전 캡처 서브 패턴이 일치하는지 여부를 결정할 수 있다. 조건부 서브 패턴의 가능한 두 가지 형태는 다음과 같다. (?(condition)yes-pattern) (?(condition)yes-pattern|no-pattern) 조건이 충족되면 예 패턴이 사용된다. 그렇지 않으면 패턴 없음(있는 경우)이 사용된다. 서브 패턴에 두 개 이상의 대안이있는 경우 컴파일 타임 오류가 발생한다. 조건에는 두 가지 종류가 있다. 괄호 사이의 텍스트가 일련의 숫자로 구성되어 있으면 해당 숫자의 캡처 부속 패턴이 이전에 일치 한 경우 조건이 충족된다. ([PCRE_EXTENDED(/2017/01/04/php-pcre-pattern-modifiers/)] 옵션을 가정하여) 읽기 쉽도록하기위한 의미가없는 공백을 포함하는 다음 패턴을 고려하고 토론을 쉽게하기 위해 세 부분으로 나눕니다. ( \( )? [^()]+ (?(1) \) ) 첫 번째 부분은 선택적 여는 괄호와 일치하며, 해당 문자가있는 경우 첫 번째 부분 문자열로 설정한다. 두 번째 부분은 괄호가 아닌 하나 이상의 문자와 일치한다. 세 번째 파트는 첫 번째 괄호 세트가 일치하는지 여부를 테스트하는 조건부 서브 패턴이다. 만약 그렇다면, 즉, 시작 괄호로 시작한 주체는 조건이 true이므로 예 패턴이 실행되고 닫는 괄호가 필요하다. 그렇지 않으면 no-pattern이 없으므로 서브 패턴은 아무 것도 일치하지 않는다. 즉,이 패턴은 괄호 안에 괄호로 묶지 않은 비 괄호의 시퀀스와 일치한다. 조건이 문자열 "(R)" 인 경우 패턴 또는 서브 패턴에 대한 재귀 호출이 수행되면 만족된다. "top level"에서 조건은 거짓이다. 조건이 일련의 숫자 또는 "(R)"이 아닌 경우 조건이 어설션이어야 한다. 이것은 긍정적이거나 부정적인 선견자 또는 표정 엉뚱한 주장 일 수 있다. 중요하지 않은 공백을 포함하는이 패턴을 고려하고 두 번째 줄에있는 두 가지 대안을 고려하자. (?(?=[^a-z]*[a-z]) \d{2}-[a-z]{3}-\d{2} | \d{2}-\d{2}-\d{2} ) 조건은 문자가 아닌 문자의 선택적 순서와 일치하는 긍정적인 미리보기 어설션이다. 즉, 주제에 적어도 하나의 문자가 있는지 테스트한다. 편지가 발견되면, 첫 번째 대안에 대해 주제가 대조된다. 그렇지 않으면 두 번째와 일치한다. 이 패턴은 두 형식 "dd-aaa-dd" 또는 "dd-dd-dd" 중 하나의 문자열을 일치시킨다. 여기서 "aaa"는 문자이고 "dd"는 숫자다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) > PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3><a href="http://php.net/manual/kr/regexp.reference.conditional.php">Conditional subpatterns</a> (조건부 서브 패턴)</h3>
<p>조건부로 서브 패턴을 따르거나 <a href="/2017/01/15/php-regex-alternation/">어설션</a>의 결과에 따라 두 개의 대체 서브 패턴 중 하나를 선택하거나 이전 캡처 서브 패턴이 일치하는지 여부를 결정할 수 있다. 조건부 서브 패턴의 가능한 두 가지 형태는 다음과 같다.</p>
<pre><code>(?(condition)yes-pattern)
(?(condition)yes-pattern|no-pattern)</code></pre>
<p>조건이 충족되면 예 패턴이 사용된다. 그렇지 않으면 패턴 없음(있는 경우)이 사용된다. 서브 패턴에 두 개 이상의 대안이있는 경우 컴파일 타임 오류가 발생한다.</p>
<p>조건에는 두 가지 종류가 있다. 괄호 사이의 텍스트가 일련의 숫자로 구성되어 있으면 해당 숫자의 캡처 부속 패턴이 이전에 일치 한 경우 조건이 충족된다. ([PCRE_EXTENDED(/2017/01/04/php-pcre-pattern-modifiers/)] 옵션을 가정하여) 읽기 쉽도록하기위한 의미가없는 공백을 포함하는 다음 패턴을 고려하고 토론을 쉽게하기 위해 세 부분으로 나눕니다. <code>( \( )? [^()]+ (?(1) \) )</code></p>
<p>첫 번째 부분은 선택적 여는 괄호와 일치하며, 해당 문자가있는 경우 첫 번째 부분 문자열로 설정한다. 두 번째 부분은 괄호가 아닌 하나 이상의 문자와 일치한다. 세 번째 파트는 첫 번째 괄호 세트가 일치하는지 여부를 테스트하는 조건부 서브 패턴이다. 만약 그렇다면, 즉, 시작 괄호로 시작한 주체는 조건이 true이므로 예 패턴이 실행되고 닫는 괄호가 필요하다. 그렇지 않으면 no-pattern이 없으므로 서브 패턴은 아무 것도 일치하지 않는다. 즉,이 패턴은 괄호 안에 괄호로 묶지 않은 비 괄호의 시퀀스와 일치한다.</p>
<p>조건이 문자열 &quot;(R)&quot; 인 경우 패턴 또는 서브 패턴에 대한 재귀 호출이 수행되면 만족된다. &quot;top level&quot;에서 조건은 거짓이다.</p>
<p>조건이 일련의 숫자 또는 &quot;(R)&quot;이 아닌 경우 조건이 <a href="/2017/01/15/php-regex-alternation/">어설션</a>이어야 한다. 이것은 긍정적이거나 부정적인 선견자 또는 표정 엉뚱한 주장 일 수 있다. 중요하지 않은 공백을 포함하는이 패턴을 고려하고 두 번째 줄에있는 두 가지 대안을 고려하자.</p>
<pre><code>(?(?=[^a-z]*[a-z])
\d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )</code></pre>
<p>조건은 문자가 아닌 문자의 선택적 순서와 일치하는 긍정적인 미리보기 <a href="/2017/01/15/php-regex-alternation/">어설션</a>이다. 즉, 주제에 적어도 하나의 문자가 있는지 테스트한다. 편지가 발견되면, 첫 번째 대안에 대해 주제가 대조된다. 그렇지 않으면 두 번째와 일치한다. 이 패턴은 두 형식 &quot;dd-aaa-dd&quot; 또는 &quot;dd-dd-dd&quot; 중 하나의 문자열을 일치시킨다. 여기서 &quot;aaa&quot;는 문자이고 &quot;dd&quot;는 숫자다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</strong></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/21/php-regex-once-​only-subpatterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/21/php-regex-once-​only-subpatterns/"/><published>2017-01-21T18:25:01+00:00</published><updated>2017-01-21T18:25:01+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 Once-​only subpatterns (단일 서브 패턴) 반복을 최대화하고 최소화하면서 반복되는 항목이 실패하면 반복되는 항목의 재평가가 발생하여 다른 반복 횟수로 나머지 패턴을 일치시킬 수 있다. 때로는 패턴의 작성자가 계속 수행 할 점이 없음을 알 때이를 방지하거나 일치 성질을 변경하거나 다른 방법보다 먼저 실패하게하는 것이 유용하다. 예를 들어, 제목 줄 123456bar에 적용될 때 \d+foo 패턴을 고려해 보자. 6자리 모두를 매치 한 다음 "foo"와 일치하지 않으면, 정규식의 정상적인 동작은 \d+ 항목과 일치하는 5자리 숫자로 다시 시도한 다음 4등으로 다시 시도하여 궁극적으로 실패한다. 한 번만의 서브 패턴은 패턴의 일부가 매치되면,이 방법으로 재평가되지 않게하기 위해서, 매치자는 최초로 "foo"와의 매치가 실패했을 경우는 즉시 포기할 것을 지정하는 수단을 제공한다. 이 표기법은 또 다른 종류의 특수 괄호로, (?>이 예제에서와 같이 시작 : (?>\d+)bar 이런 종류의 괄호는 패턴이 일치하면 패턴의 일부를 "locks up" 그리고 패턴으로의 더 이상의 실패는 패턴으로 되돌아가는 것을 방지한다. 그러나 이전 항목으로 이동하면 정상적으로 작동한다. 또 다른 설명은 이 유형의 서브 패턴이 제목 문자열의 현재 위치에 고정되어 있으면 동일한 독립형 패턴이 일치하는 문자의 문자열과 일치한다는 것이다. 한 번만의 서브 패턴은 서브 패턴을 캡처하지 않는다. 위의 예제와 같은 간단한 경우는 가능한 모든 것을 삼켜 야하는 최대화 반복으로 생각할 수 있다. 그래서 \d+와 \d+? 패턴 일치의 나머지 부분을 만들기 위해 일치시키는 자릿수를 조정할 준비가되어 있다 (?>\d+). 전체 자릿수 시퀀스 만 일치시킬 수 있다. 물론이 구조는 임의로 복잡한 서브 패턴을 포함할 수 있으며 중첩 될 수 있다. 한 번만 사용할 수있는 서브 패턴은 look-behind 어설션과 함께 사용하여 제목 문자열 끝에 효율적인 일치를 지정한다. 일치하지 않는 긴 문자열에 적용 할 때 abcd$와 같은 간단한 패턴을 고려하자. 매칭은 왼쪽에서 오른쪽으로 진행되기 때문에, PCRE는 피사체의 각 "a"를 찾아 다음 패턴이 나머지 패턴과 일치하는지 확인하다. 패턴이 ^.*abcd$로 지정되면 초기 .*는 처음에는 전체 문자열과 일치하지만 실패 할 경우 ( "a" 다음에 없기 때문에) 마지막 문자를 제외하고 모두 일치하도록 역 추적 한 다음 모두 그러나 마지막 두 글자 등 . 다시 한 번 "a"에 대한 검색은 오른쪽에서 왼쪽으로 전체 문자열을 포함하므로 더 나아지지 않는다. 그러나 패턴이 ^(?>.*)(?<=abcd)로 쓰여진 경우 .* 항목에 대해 역 추적이 불가능 할 수 있다. 전체 문자열 만 일치시킬 수 있다. 후속 look-behind 어설션은 마지막 네 문자에 대해 단일 테스트를 수행한다. 실패하면 즉시 일치하지 않는다. 긴 문자열의 경우 이 접근 방식은 처리 시간에 중요한 차이를 만든다. 패턴이 무한 반복 횟수만큼 반복 될 수 있는 서브 패턴 내부에 무제한 반복을 포함하는 패턴은 한 번만 서브 패턴을 사용하는 것이 매우 오랜 시간 동안 실패한 일부 일치를 피할 수있는 유일한 방법이다. 패턴 (\D+|<\d+>)*[!?]은 숫자가 아닌 숫자 또는 <>로 묶인 숫자와 무작위로 일치하는 부분 문자열을 일치시킨다. ! 또는 ? 일치하면 빠르게 실행된다. 그러나 "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"에 적용되면 실패를 보고 하기까지 시간이 오래 걸린다. 이것은 문자열이 여러 가지 방법으로 두 반복 사이에서 나눌 수 있기 때문에 모두 시도해야한다. (PCRE와 Perl은 단일 문자가 사용될 때 빠른 오류를 허용하는 최적화 기능을 가지고 있기 때문에 끝에있는 단일 문자 대신 [!?]를 사용한다. 일치하는데 필요한 마지막 단일 문자를 기억하고, 패턴이 ((?>\D+)|<\d+>)*[!?]로 변경되면 숫자가 아닌 시퀀스는 깨질 수 없으므로 오류가 빠르게 발생한다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) > PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3><a href="http://php.net/manual/kr/regexp.reference.onlyonce.php">Once-​only subpatterns</a> (단일 서브 패턴)</h3>
<p>반복을 최대화하고 최소화하면서 반복되는 항목이 실패하면 반복되는 항목의 재평가가 발생하여 다른 반복 횟수로 나머지 패턴을 일치시킬 수 있다. 때로는 패턴의 작성자가 계속 수행 할 점이 없음을 알 때이를 방지하거나 일치 성질을 변경하거나 다른 방법보다 먼저 실패하게하는 것이 유용하다.</p>
<p>예를 들어, 제목 줄 123456bar에 적용될 때 <code>\d+foo</code> 패턴을 고려해 보자.</p>
<p>6자리 모두를 매치 한 다음 &quot;foo&quot;와 일치하지 않으면, 정규식의 정상적인 동작은 <code>\d+</code> 항목과 일치하는 5자리 숫자로 다시 시도한 다음 4등으로 다시 시도하여 궁극적으로 실패한다.
한 번만의 서브 패턴은 패턴의 일부가 매치되면,이 방법으로 재평가되지 않게하기 위해서, 매치자는 최초로 &quot;foo&quot;와의 매치가 실패했을 경우는 즉시 포기할 것을 지정하는 수단을 제공한다. 이 표기법은 또 다른 종류의 특수 괄호로, <code>(?&gt;</code>이 예제에서와 같이 시작 : <code>(?&gt;\d+)bar</code></p>
<p>이런 종류의 괄호는 패턴이 일치하면 패턴의 일부를 &quot;locks up&quot; 그리고 패턴으로의 더 이상의 실패는 패턴으로 되돌아가는 것을 방지한다. 그러나 이전 항목으로 이동하면 정상적으로 작동한다.</p>
<p>또 다른 설명은 이 유형의 서브 패턴이 제목 문자열의 현재 위치에 고정되어 있으면 동일한 독립형 패턴이 일치하는 문자의 문자열과 일치한다는 것이다.</p>
<p>한 번만의 서브 패턴은 서브 패턴을 캡처하지 않는다. 위의 예제와 같은 간단한 경우는 가능한 모든 것을 삼켜 야하는 최대화 반복으로 생각할 수 있다. 그래서 <code>\d+</code>와 <code>\d+?</code> 패턴 일치의 나머지 부분을 만들기 위해 일치시키는 자릿수를 조정할 준비가되어 있다 <code>(?&gt;\d+)</code>. 전체 자릿수 시퀀스 만 일치시킬 수 있다.</p>
<p>물론이 구조는 임의로 복잡한 서브 패턴을 포함할 수 있으며 중첩 될 수 있다.</p>
<p>한 번만 사용할 수있는 서브 패턴은 look-behind <a href="/2017/01/15/php-regex-alternation/">어설션</a>과 함께 사용하여 제목 문자열 끝에 효율적인 일치를 지정한다. 일치하지 않는 긴 문자열에 적용 할 때 <code>abcd$</code>와 같은 간단한 패턴을 고려하자. 매칭은 왼쪽에서 오른쪽으로 진행되기 때문에, PCRE는 피사체의 각 &quot;a&quot;를 찾아 다음 패턴이 나머지 패턴과 일치하는지 확인하다. 패턴이 <code>^.*abcd$</code>로 지정되면 초기 <code>.*</code>는 처음에는 전체 문자열과 일치하지만 실패 할 경우 ( &quot;a&quot; 다음에 없기 때문에) 마지막 문자를 제외하고 모두 일치하도록 역 추적 한 다음 모두 그러나 마지막 두 글자 등 . 다시 한 번 &quot;a&quot;에 대한 검색은 오른쪽에서 왼쪽으로 전체 문자열을 포함하므로 더 나아지지 않는다. 그러나 패턴이 <code>^(?&gt;.*)(?&lt;=abcd)</code>로 쓰여진 경우 <code>.*</code> 항목에 대해 역 추적이 불가능 할 수 있다. 전체 문자열 만 일치시킬 수 있다. 후속 look-behind <a href="/2017/01/15/php-regex-alternation/">어설션</a>은 마지막 네 문자에 대해 단일 테스트를 수행한다. 실패하면 즉시 일치하지 않는다. 긴 문자열의 경우 이 접근 방식은 처리 시간에 중요한 차이를 만든다.</p>
<p>패턴이 무한 반복 횟수만큼 반복 될 수 있는 서브 패턴 내부에 무제한 반복을 포함하는 패턴은 한 번만 서브 패턴을 사용하는 것이 매우 오랜 시간 동안 실패한 일부 일치를 피할 수있는 유일한 방법이다. 패턴 <code>(\D+|&lt;\d+&gt;)*[!?]</code>은 숫자가 아닌 숫자 또는 <code>&lt;&gt;</code>로 묶인 숫자와 무작위로 일치하는 부분 문자열을 일치시킨다. <code>!</code> 또는 <code>?</code> 일치하면 빠르게 실행된다. 그러나 &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;에 적용되면 실패를 보고 하기까지 시간이 오래 걸린다. 이것은 문자열이 여러 가지 방법으로 두 반복 사이에서 나눌 수 있기 때문에 모두 시도해야한다. (PCRE와 Perl은 단일 문자가 사용될 때 빠른 오류를 허용하는 최적화 기능을 가지고 있기 때문에 끝에있는 단일 문자 대신 <code>[!?]</code>를 사용한다. 일치하는데 필요한 마지막 단일 문자를 기억하고, 패턴이 <code>((?&gt;\D+)|&lt;\d+&gt;)*[!?]</code>로 변경되면 숫자가 아닌 시퀀스는 깨질 수 없으므로 오류가 빠르게 발생한다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</strong></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/20/php-regex-assertions/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/20/php-regex-assertions/"/><published>2017-01-20T19:54:12+00:00</published><updated>2017-01-20T19:54:12+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 [Assertions] (http://php.net/manual/kr/regexp.reference.assertions.php) (어설션) 어설션은 실제로 어떤 문자도 사용하지 않고 현재 일치 지점의 앞/뒤 문자에 대한 테스트이다. \b, \B, \A, \Z, \z, ^ 및 $로 코딩된 간단한 어설션은 위에 설명되어 있다. 더 복잡한 어서션은 서브 패턴으로 코딩 된다. 이 어설션은 대상 문자열의 현재 위치보다 앞서 보이는 것들(look ahead)과 그 뒤에 보이는 것들(look behind) 두 가지 종류가 있다. 어설션 서브 패턴은 현재 일치하는 위치가 변경되지 않는다는 점을 제외하면 일반적인 방법으로 매치된다. Lookahead 어설션은 (?= 긍정 어설션, (?!은 부정 어설션을 나타낸다. 예를 들어, \w+(?=;)는 단어 뒤에 세미콜론을 매치하지만 세미콜론은 매치하지 않으며 foo(?!bar)는 "bar"가 뒤에 붙지 않는 "foo"와 매치된다. 기억할 점은 유사한 패턴인 (?!foo)bar는 "foo"로 시작되지 않는 "bar" 항목을 찾지 않는다는 것이다. 다음 3개의 문자가 "bar"일 때 어설션 (?!foo)은 항상 TRUE 이므로 모든 항목을 찾는다. 아래의 예시를 참고하자. <?php $string = "fooXbar"; echo preg_match('/foo(?!bar)/', $string) . "\n"; $string = "foobar"; echo preg_match('/(?!foo)bar/', $string) . "\n"; // 1 // 1 원하는 결과를 얻으려면 lookbehind 어설션이 필요하다. Lookbehind 어설션은 (?<= 긍정 어설션, (?<!은 부정 어설션을 나타낸다. 예를 들어, (?<!foo)bar는 "foo"가 앞에 붙지 않는 "bar"의 항목을 찾는다. lookbehind 어설션은 일치하는 모든 문자열이 고정 길이가 되도록 제한되지만, 여러 가지 대안이 있는 경우 모두 동일한 고정 길이를 가져야하는 것은 아니다. 따라서 (?<=bullock|donkey)는 허용된다. 그러나 (?<!dogs?|cats?)는 컴파일 타임에 오류가 발생한다. 다른 길이의 문자열에 일치하는 분기는 lookbehind 어설션의 최상위 수준에서만 허용된다. 이것은 모든 분기에서 동일한 길이를 요구하는 Perl 5.005와 비교되는 확장이다. (?<=ab(c|de))와 같은 어설션은 허용되지 않는다. 왜냐하면 단일 최상위 분기가 두 개의 다른 길이를 일치시킬 수 있기 때문이다. 그러나 두 개의 최상위 레벨 분기를 사용하도록 (?<=abc|abde)로 다시 작성하면 허용된다. Lookbehind 어설션의 구현은 각 대안에 따라 현재 위치를 고정 폭만큼 임시로 이동시킨 다음 일치시키려고 시도한다. 현재 위치 앞에 문자가 충분하지 않으면 일치가 실패한 것으로 간주된다. 한 번만 사용 할 수 있는 하위 패턴과 관련된 Lookbehind는 특히 문자열 끝에 매칭하는데 유용 할 수 있다. once-only subpatterns에 대한 섹션에 예제가 있다. 여러 어설션이 연속해서 발생할 수 있다. 예를 들어, (?<=\d{3})(?<!999)foo는 "foo" 앞에 "999"가 아닌 세 자리를 찾는다. 각 어설션은 주제 문자열의 동일한 지점에서 독립적으로 적용된다. 먼저 앞의 세 문자가 모두 숫자임을 확인한 다음 동일한 세 문자가 "999"가 아닌지 확인한다. 이 패턴은 "foo"와 6 문자 앞의 문자는 일치하지 않는다. 첫 번째 문자는 숫자이고 마지막 세 문자는 "999"가 아니다. 예를 들어, "123abcfoo"와 일치하지 않는다((?<=\d{3}...)(?<!999)foo를 사용하면 매치된다). <?php $string = "123abcfoo"; echo preg_match('/(?<=\d{3})(?<!999)foo/', $string) . "\n"; echo preg_match('/(?<=\d{3}...)(?<!999)foo/', $string) . "\n"; // 0 // 1 이번에는 첫 번째 어설션은 앞의 여섯개 문자를 살펴보고 첫 번째 세 개가 숫자임을 확인한 다음 두 번째 어설션은 앞의 세 문자가 "999"가 아님을 확인한다. 어설션은 임의의 조합으로 중첩 될 수 있다. 예를 들어 (?<=(?<!foo)bar)baz는 앞에 "foo"가 없는 "bar"가 앞에 오는 "baz"의 발생과 일치하지만 (?<=\d{3}...(?<!999))foo는 "foo"앞에 3 자리 숫자와 "999"가 아닌 3 자와 일치하는 다른 패턴이다. 어설션 서브 패턴은 서브 패턴을 캡쳐하지 않으며 반복되지 않을 수 있다. 동일한 것을 여러 번 선언하는 것은 의미가 없기 때문이다. 임의의 종류의 어설션에 하위 패턴 캡처가 포함되어 있으면 이러한 패턴은 전체 패턴에서 캡처하는 하위 패턴에 번호를 매기는 목적으로 계산된다. 그러나 부분 문자열 캡처는 긍정적인 어설션에 대해서만 수행된다. 왜냐하면 부정적인 어설션에 대해서는 의미가 없기 때문입니다. 어설션은 최대 200개의 괄호로 묶은 하위 패턴으로 계산된다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) > PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3>[Assertions] (<a href="http://php.net/manual/kr/regexp.reference.assertions.php">http://php.net/manual/kr/regexp.reference.assertions.php</a>) (어설션)</h3>
<p>어설션은 실제로 어떤 문자도 사용하지 않고 현재 일치 지점의 앞/뒤 문자에 대한 테스트이다. <code>\b</code>, <code>\B</code>, <code>\A</code>, <code>\Z</code>, <code>\z</code>, <code>^</code> 및 <code>$</code>로 코딩된 간단한 어설션은 위에 설명되어 있다. 더 복잡한 어서션은 서브 패턴으로 코딩 된다. 이 어설션은 대상 문자열의 현재 위치보다 앞서 보이는 것들(look ahead)과 그 뒤에 보이는 것들(look behind) 두 가지 종류가 있다.</p>
<p>어설션 서브 패턴은 현재 일치하는 위치가 변경되지 않는다는 점을 제외하면 일반적인 방법으로 매치된다.</p>
<p>Lookahead 어설션은 <code>(?=</code> 긍정 어설션, <code>(?!</code>은 부정 어설션을 나타낸다. 예를 들어, <code>\w+(?=;)</code>는 단어 뒤에 세미콜론을 매치하지만 세미콜론은 매치하지 않으며 <code>foo(?!bar)</code>는 &quot;bar&quot;가 뒤에 붙지 않는 &quot;foo&quot;와 매치된다. 기억할 점은 유사한 패턴인 <code>(?!foo)bar</code>는 &quot;foo&quot;로 시작되지 않는 &quot;bar&quot; 항목을 찾지 않는다는 것이다. 다음 3개의 문자가 &quot;bar&quot;일 때 어설션 <code>(?!foo)</code>은 항상 TRUE 이므로 모든 항목을 찾는다. 아래의 예시를 참고하자.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">"fooXbar"</span>;
<span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">'/foo(?!bar)/'</span>, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-variable">$string</span> = <span class="hljs-string">"foobar"</span>;
<span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">'/(?!foo)bar/'</span>, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;

<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 1</span></pre>
<p>원하는 결과를 얻으려면 lookbehind 어설션이 필요하다.</p>
<p>Lookbehind 어설션은 <code>(?&lt;=</code> 긍정 어설션, <code>(?&lt;!</code>은 부정 어설션을 나타낸다. 예를 들어, <code>(?&lt;!foo)bar</code>는 &quot;foo&quot;가 앞에 붙지 않는 &quot;bar&quot;의 항목을 찾는다. lookbehind 어설션은 일치하는 모든 문자열이 고정 길이가 되도록 제한되지만, 여러 가지 대안이 있는 경우 모두 동일한 고정 길이를 가져야하는 것은 아니다. 따라서 <code>(?&lt;=bullock|donkey)</code>는 허용된다. 그러나 <code>(?&lt;!dogs?|cats?)</code>는 컴파일 타임에 오류가 발생한다.
다른 길이의 문자열에 일치하는 분기는 lookbehind 어설션의 최상위 수준에서만 허용된다. 이것은 모든 분기에서 동일한 길이를 요구하는 Perl 5.005와 비교되는 확장이다.
<code>(?&lt;=ab(c|de))</code>와 같은 어설션은 허용되지 않는다. 왜냐하면 단일 최상위 분기가 두 개의 다른 길이를 일치시킬 수 있기 때문이다. 그러나 두 개의 최상위 레벨 분기를 사용하도록 <code>(?&lt;=abc|abde)</code>로 다시 작성하면 허용된다.
Lookbehind 어설션의 구현은 각 대안에 따라 현재 위치를 고정 폭만큼 임시로 이동시킨 다음 일치시키려고 시도한다. 현재 위치 앞에 문자가 충분하지 않으면 일치가 실패한 것으로 간주된다. 한 번만 사용 할 수 있는 하위 패턴과 관련된 Lookbehind는 특히 문자열 끝에 매칭하는데 유용 할 수 있다. <a href="/2017/01/21/php-regex-once-​only-subpatterns/">once-only subpatterns</a>에 대한 섹션에 예제가 있다.</p>
<p>여러 어설션이 연속해서 발생할 수 있다. 예를 들어, <code>(?&lt;=\d{3})(?&lt;!999)foo</code>는 &quot;foo&quot; 앞에 &quot;999&quot;가 아닌 세 자리를 찾는다. 각 어설션은 주제 문자열의 동일한 지점에서 독립적으로 적용된다. 먼저 앞의 세 문자가 모두 숫자임을 확인한 다음 동일한 세 문자가 &quot;999&quot;가 아닌지 확인한다. 이 패턴은 &quot;foo&quot;와 6 문자 앞의 문자는 일치하지 않는다. 첫 번째 문자는 숫자이고 마지막 세 문자는 &quot;999&quot;가 아니다. 예를 들어, &quot;123abcfoo&quot;와 일치하지 않는다(<code>(?&lt;=\d{3}...)(?&lt;!999)foo</code>를 사용하면 매치된다).</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">"123abcfoo"</span>;
<span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">'/(?&lt;=\d{3})(?&lt;!999)foo/'</span>, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;
<span class="hljs-keyword">echo</span> preg_match(<span class="hljs-string">'/(?&lt;=\d{3}...)(?&lt;!999)foo/'</span>, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;

<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 1</span></pre>
<p>이번에는 첫 번째 어설션은 앞의 여섯개 문자를 살펴보고 첫 번째 세 개가 숫자임을 확인한 다음 두 번째 어설션은 앞의 세 문자가 &quot;999&quot;가 아님을 확인한다.</p>
<p>어설션은 임의의 조합으로 중첩 될 수 있다. 예를 들어 <code>(?&lt;=(?&lt;!foo)bar)baz</code>는 앞에 &quot;foo&quot;가 없는 &quot;bar&quot;가 앞에 오는 &quot;baz&quot;의 발생과 일치하지만 <code>(?&lt;=\d{3}...(?&lt;!999))foo</code>는 &quot;foo&quot;앞에 3 자리 숫자와 &quot;999&quot;가 아닌 3 자와 일치하는 다른 패턴이다.</p>
<p>어설션 서브 패턴은 서브 패턴을 캡쳐하지 않으며 반복되지 않을 수 있다. 동일한 것을 여러 번 선언하는 것은 의미가 없기 때문이다. 임의의 종류의 어설션에 하위 패턴 캡처가 포함되어 있으면 이러한 패턴은 전체 패턴에서 캡처하는 하위 패턴에 번호를 매기는 목적으로 계산된다. 그러나 부분 문자열 캡처는 긍정적인 어설션에 대해서만 수행된다. 왜냐하면 부정적인 어설션에 대해서는 의미가 없기 때문입니다.</p>
<p>어설션은 최대 200개의 괄호로 묶은 하위 패턴으로 계산된다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</strong></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/19/php-regex-back-references/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/19/php-regex-back-references/"/><published>2017-01-19T19:56:12+00:00</published><updated>2017-01-19T19:56:12+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 [Back references] (http://php.net/manual/kr/regexp.reference.back-references.php) (역 참조) 캐릭터 클래스 밖에서 백 슬래시 다음에 0보다 큰 숫자는 패턴에서 이전(즉, 왼쪽으로) 캡처 서브 패턴에 대한 역 참조다(주어진 수보다 캡처된 서브 패턴의 수가 같거나 더 많을 경우). 그러나 백 슬래시 뒤의 10진수가 10 보다 작은 경우에는 항상 역 참조로 사용되며 전체 패턴에 많은 왼쪽 여는 괄호(()가 없는 경우에만 오류가 발생한다. 즉, 참조된 괄호는 10 보다 작은 숫자의 참조 왼쪽에 있을 필요는 없다. "전방 참조"는 반복이 관련되어 있고 오른쪽의 서브 패턴이 이전 반복에 참여했을 때 의미가 있다. 백 슬래시 뒤에 나오는 숫자 처리에 대한 자세한 내용은 위의 "백 슬래시"절을 참조하자. 역 참조는, 서브 패턴 자체와 일치하는 것이 아니라, 현재의 subject 캐릭터 라인의 캡춰 중의 서브 패턴과 실제로 일치하고 있는 것을 매치한다. 그래서 패턴 (sens|respons)e와 \1 적합성은 "sense and sensibility"와 "response and responsibility"과 일치하지만 "sense and responsibility"은 일치하지 않는다. 역 참조에서 대소문자를 구분하는 (대소문자가) 일치하는 경우 문자의 대소문자가 적합한다. 예를 들어 ((?i)rah)\s+\1은 "rah rah"및 "RAH RAH"와 일치하지만 "RAH rah"와 일치하지 않는다. 원래 캡처 하위 패턴은 대소문자를 구분하지 않는다. 같은 서브 패턴에 대한 복수의 역 참조가 있을 수 있다. 특정 패턴에서 실제로 하위 패턴을 사용하지 않은 경우 하위 패턴은 항상 실패한다. 예를 들어 패턴 (a|(bc))\2는 "bc"가 아닌 "a"와 일치하기 시작하면 항상 실패한다. 최대 99개의 역 참조가 있을 수 있으므로 백 슬래시 뒤의 모든 숫자는 잠재적인 참조 번호의 일부로 사용된다. 패턴이 숫자 문자로 계속되면 뒤로 구분을 종료하기 위해 일부 구분 기호를 사용해야 한다. PCRE_EXTENDED 옵션이 설정되면 공백이 될 수 있다. 그렇지 않으면 빈 주석을 사용할 수 있다. 하위 패턴이 처음 사용될 때 참조하는 괄호 안쪽에서 발생하는 역 참조는 실패합니다. 예를 들어, (a\1)은 결코 일치하지 않는다. 그러나 이러한 참조는 반복되는 하위 패턴 내부에서 유용할 수 있다. 예를 들어, 패턴 (a|b\1)+은 "a" 및 "aba", "ababba"등의 임의의 수와 일치한다. 하위 패턴의 각 반복에서 이전 참조는 이전 패턴 되풀이. 이 작업을 수행하려면 첫 번째 반복이 역 참조와 일치할 필요가 없는 패턴이어야 한다. 위의 예와 같이 교번을 사용하거나 최소값이 0인 수량 기호를 사용하여 이 작업을 수행 할 수 있다. PHP 5.2.2부터는 \g 이스케이프 시퀀스를 사용하여 하위 패턴의 절대 참조 및 상대 참조를 사용할 수 있다. 이 이스케이프 시퀀스 뒤에는 부호없는 숫자 또는 음수가 와야하며, 선택적으로 중괄호로 묶어야 한다. \1, \g1 및 \g{1}은 서로 동의어다. 이 패턴을 부호없는 숫자와 함께 사용하면 역 슬래시 뒤에 오는 숫자를 사용할 때 고유 한 모호성을 제거하는 데 도움이 된다. 이 시퀀스는 역 참조를 8진수 문자와 구별하는 데 도움이 되며, 역 참조 뒤에 문자 숫자 (예 \g{2}1) 음수와 함께 \g 시퀀스를 사용하면 상대 참조를 의미한다. 예를 들어 (foo)(bar)\g{-1}은 "foobarbar"와 (foo)(bar)\g{-2}는 "foobarfoo"와 일치한다. 이것은 특정 이전 하위 패턴을 참조하기 위해 하위 패턴의 수를 추적하는 대신에 긴 패턴에서 유용 할 수 있다. 명명 된 서브 패턴에 대한 역 참조는 (?P=name) 또는 PHP 5.2.2 이후 \k<name> 또는 \k'name'을 사용하여 수행 할 수 있다. 또한 PHP 5.2.4에서는 \k{name} 및 \g{name}에 대한 지원이 추가되었다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) > PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3>[Back references] (<a href="http://php.net/manual/kr/regexp.reference.back-references.php">http://php.net/manual/kr/regexp.reference.back-references.php</a>) (역 참조)</h3>
<p><a href="/2017/01/14/php-regex-character-classes/">캐릭터 클래스</a> 밖에서 백 슬래시 다음에 0보다 큰 숫자는 패턴에서 이전(즉, 왼쪽으로) 캡처 <a href="/2017/01/17/php-regex-subpatterns/">서브 패턴</a>에 대한 역 참조다(주어진 수보다 캡처된 서브 패턴의 수가 같거나 더 많을 경우).</p>
<p>그러나 백 슬래시 뒤의 10진수가 10 보다 작은 경우에는 항상 역 참조로 사용되며 전체 패턴에 많은 왼쪽 여는 괄호(<code>(</code>)가 없는 경우에만 오류가 발생한다. 즉, 참조된 괄호는 10 보다 작은 숫자의 참조 왼쪽에 있을 필요는 없다. &quot;전방 참조&quot;는 반복이 관련되어 있고 오른쪽의 서브 패턴이 이전 반복에 참여했을 때 의미가 있다. 백 슬래시 뒤에 나오는 숫자 처리에 대한 자세한 내용은 위의 &quot;<a href="/2017/01/10/php-regex-escape-sequences/">백 슬래시</a>&quot;절을 참조하자.</p>
<p>역 참조는, 서브 패턴 자체와 일치하는 것이 아니라, 현재의 subject 캐릭터 라인의 캡춰 중의 서브 패턴과 실제로 일치하고 있는 것을 매치한다. 그래서 패턴 <code>(sens|respons)e</code>와 <code>\1</code> 적합성은 &quot;sense and sensibility&quot;와 &quot;response and responsibility&quot;과 일치하지만 &quot;sense and responsibility&quot;은 일치하지 않는다. 역 참조에서 대소문자를 구분하는 (대소문자가) 일치하는 경우 문자의 대소문자가 적합한다. 예를 들어 <code>((?i)rah)\s+\1</code>은 &quot;rah rah&quot;및 &quot;RAH RAH&quot;와 일치하지만 &quot;RAH rah&quot;와 일치하지 않는다. 원래 캡처 하위 패턴은 대소문자를 구분하지 않는다.</p>
<p>같은 서브 패턴에 대한 복수의 역 참조가 있을 수 있다. 특정 패턴에서 실제로 하위 패턴을 사용하지 않은 경우 하위 패턴은 항상 실패한다. 예를 들어 패턴 <code>(a|(bc))\2</code>는 &quot;bc&quot;가 아닌 &quot;a&quot;와 일치하기 시작하면 항상 실패한다. 최대 99개의 역 참조가 있을 수 있으므로 백 슬래시 뒤의 모든 숫자는 잠재적인 참조 번호의 일부로 사용된다. 패턴이 숫자 문자로 계속되면 뒤로 구분을 종료하기 위해 일부 구분 기호를 사용해야 한다. <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션이 설정되면 공백이 될 수 있다. 그렇지 않으면 빈 주석을 사용할 수 있다.</p>
<p>하위 패턴이 처음 사용될 때 참조하는 괄호 안쪽에서 발생하는 역 참조는 실패합니다. 예를 들어, <code>(a\1)</code>은 결코 일치하지 않는다. 그러나 이러한 참조는 반복되는 하위 패턴 내부에서 유용할 수 있다. 예를 들어, 패턴 <code>(a|b\1)+</code>은 &quot;a&quot; 및 &quot;aba&quot;, &quot;ababba&quot;등의 임의의 수와 일치한다. 하위 패턴의 각 반복에서 이전 참조는 이전 패턴 되풀이. 이 작업을 수행하려면 첫 번째 반복이 역 참조와 일치할 필요가 없는 패턴이어야 한다. 위의 예와 같이 교번을 사용하거나 최소값이 0인 수량 기호를 사용하여 이 작업을 수행 할 수 있다.</p>
<p>PHP 5.2.2부터는 <code>\g</code> 이스케이프 시퀀스를 사용하여 하위 패턴의 절대 참조 및 상대 참조를 사용할 수 있다. 이 이스케이프 시퀀스 뒤에는 부호없는 숫자 또는 음수가 와야하며, 선택적으로 중괄호로 묶어야 한다. <code>\1</code>, <code>\g1</code> 및 <code>\g{1}</code>은 서로 동의어다. 이 패턴을 부호없는 숫자와 함께 사용하면 역 슬래시 뒤에 오는 숫자를 사용할 때 고유 한 모호성을 제거하는 데 도움이 된다. 이 시퀀스는 역 참조를 8진수 문자와 구별하는 데 도움이 되며, 역 참조 뒤에 문자 숫자 (예 <code>\g{2}1</code>)</p>
<p>음수와 함께 <code>\g</code> 시퀀스를 사용하면 상대 참조를 의미한다. 예를 들어 <code>(foo)(bar)\g{-1}</code>은 &quot;foobarbar&quot;와 <code>(foo)(bar)\g{-2}</code>는 &quot;foobarfoo&quot;와 일치한다. 이것은 특정 이전 하위 패턴을 참조하기 위해 하위 패턴의 수를 추적하는 대신에 긴 패턴에서 유용 할 수 있다.</p>
<p>명명 된 서브 패턴에 대한 역 참조는 <code>(?P=name)</code> 또는 PHP 5.2.2 이후 <code>\k&lt;name&gt;</code> 또는 <code>\k'name'</code>을 사용하여 수행 할 수 있다. 또한 PHP 5.2.4에서는 <code>\k{name}</code> 및 <code>\g{name}</code>에 대한 지원이 추가되었다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</strong></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/18/php-regex-repetition/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/18/php-regex-repetition/"/><published>2017-01-18T18:58:11+00:00</published><updated>2017-01-18T18:58:11+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 Repetition (반복) 반복은 다음 항목 중 하나를 따를 수 있는 한정 기호로 지정된다. 이스케이프 된 단일 문자 . 메타 문자 캐릭터 클래스 back reference(역 참조) assertion이 아닌 괄호로 묶인 서브 패턴 일반적으로 반복값은 괄호({}) 안에 쉼표로 구분 된 두 개의 숫자를 입력하여 허용되는 일치의 최소 및 최대 수를 지정한다. 숫자는 65536 보다 작아야 하며 첫 번째 숫자는 두 번째 숫자보다 작거나 같아야 한다. 예 : z{2,4}는 "zz", "zzz" 또는 "zzzz"와 일치한다. 단독으로 닫는 중괄호는 특수 문자가 아니다. 두 번째 숫자가 생략 되었으나 쉼표가 있으면 상한이 없다. 두 번째 숫자와 쉼표가 둘 다 생략되면 수량 기호는 필요한 일치 항목의 정확한 수를 지정한다. 따라서 [aeiou]{3,}는 최소 3개의 연속 모음과 일치하지만 \d{8}은 정확히 8자리 숫자와 일치한다. 한정 기호가 허용되지 않는 위치나 한정 기호의 구문과 일치하지 않는 위치에 나타나는 여는 중괄호({})는 리터럴 문자로 사용된다. 예를 들어, {,6}은 한정 기호가 아니라 4자의 리터럴 문자열이다. 한정자 {0}이 허용되어 표현식이 이전 항목 및 한정 기호가 없는 것처럼 동작한다. 편의상 (그리고 전통적인 호환성) 세 가지 가장 일반적인 수량 기호는 한 문자로 된 약자를 사용한다 : Single-character quantifiers 문자 설명 * {0,}와 같다 + {1,}와 같다 ? {0,1}와 같다 상한이 없는 수량 기호와 일치하지 않는 서브 패턴을 따라 무한 루프를 구성 할 수 있다(예 : (a?)*). 이전 버전의 Perl과 PCRE는 그러한 패턴을 컴파일 할 때 오류를 내기도 했다. 그러나 이 방법이 유용 할 수 있기 때문에 이러한 패턴이 이제 허용되지만 실제로 서브 패턴의 반복이 실제로 문자와 일치하지 않으면 루프가 강제로 끊어진다. 기본적으로 한정 기호는 "greedy" 즉 패턴의 나머지 부분을 실패시키지 않고 가능한 한 최대 허용 횟수까지 일치시킨다. 이것이 문제를 일으키는 곳의 고전적인 예는 C 프로그램의 주석과 일치하는 것이다. 시퀀스 /*와 */ 사이에 나타나며 시퀀스 내에서 개별 * 및 / 문자가 나타날 수 있다. 첫 번째 주석 */ 주석 /* 두 번째 주석 */에 문자열 /**.*\*/ 패턴을 적용하여 C 주석을 일치 시키려는 시도는 .*의 탐욕으로 인해 전체 문자열과 일치하기 때문에 실패한다. 그러나 수량 기호 다음에 물음표가 오는 경우에는 게으르며 가능한 최소 횟수와 일치하므로 패턴 /\*.*?\*/는 C 주석과 함께 올바른 작업을 수행한다. 다양한 한정어의 의미는 다른 방식으로 변경되지 않으며 선호하는 일치 개수만 변경된다. 이 ? 사용을 그 자체로 한정 기호로 사용하는 것과 혼동하지 말아야 한다. 두 가지 용도로 사용되기 때문에 \d??\d와 같이 두 글자로 표시되는 경우가 있다. 한 글자가 기본 설정과 일치하지만 나머지 패턴 일치하는 경우 두 글자와 일치할 수 있다. PCRE_UNGREEDY 옵션이 설정되어 있으면 (Perl에서는 사용할 수없는 옵션) 수량 한정자는 기본적으로 욕심이 없지만 물음표로 따옴표를 사용하면 개별적으로 욕심을 느낄 수 있다. 즉, 기본 동작을 반전한다. + 뒤에 오는 한정 기호는 "possessive"이다. 가능한 한 많은 문자를 먹고 나머지 패턴과 일치하도록 돌아 가지 않는다. 따라서 .*abc는 "aabc"와 일치하지만 .*+는 전체 문자열을 먹기 때문에 .*+abc은 그렇지 않습니다. 소유량 지정자는 처리 속도를 높이는 데 사용할 수 있습니다. 괄호 안의 서브 패턴이 최소 반복 횟수가 1 보다 크거나 제한된 최대 값으로 정량화되면 컴파일 된 패턴에 최소 또는 최대 크기에 비례하여 더 많은 저장소가 필요하다. 패턴이 .* 또는 .{0,}으로 시작하고 PCRE_DOTALL 옵션(Perl의 /s와 동일)이 설정되어 있으므로. 줄 바꿈과 일치시키려면 패턴은 암시적으로 고정되어 있다. 왜냐하면 뒤 따르는 것은 제목 문자열의 모든 문자 위치에 대해 시도되기 때문이다. 따라서 첫 번째 이후의 모든 위치에서 전체 일치를 다시 시도 할 필요가 없다. PCRE(Perl Compatible Regular Expressions)는 앞에 \A와 같은 패턴을 처리합니다. 대상 문자열에 개행 문자가없는 것으로 알려진 경우 패턴이 .*로 시작하는 경우 PCRE_DOTALL을 설정하거나이 최적화를 얻기 위해 ^를 사용하거나 ^를 사용하여 명시적으로 고정을 나타낼 수 있다. 캡처 서브 패턴이 반복되면 캡처된 값은 최종 반복과 일치하는 하위 문자열이다. 예를 들어, (tweedle[dume]{3}\s*)+가 "tweedledum tweedledee"와 일치하면 캡처된 부분 문자열의 값은 "tweedledee"이다. 그러나 중첩된 캡처 서브 패턴이 있으면 해당 캡처 값이 이전 반복에서 설정 되었을 수 있다. 예를 들어, /(a|(b))+/가 "aba"와 일치하면 두 번째로 캡처 된 하위 문자열의 값은 "b"가 된다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) > PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3><a href="http://php.net/manual/kr/regexp.reference.repetition.php">Repetition</a> (반복)</h3>
<p>반복은 다음 항목 중 하나를 따를 수 있는 한정 기호로 지정된다.</p>
<ul>
<li><a href="/2017/01/10/php-regex-escape-sequences/">이스케이프</a> 된 단일 문자</li>
<li><a href="/2017/01/13/php-regex-dot/"><code>.</code> 메타 문자</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">캐릭터 클래스</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">back reference(역 참조)</a></li>
<li>assertion이 아닌 괄호로 묶인 <a href="/2017/01/17/php-regex-subpatterns/">서브 패턴</a></li>
</ul>
<p>일반적으로 반복값은 괄호(<code>{}</code>) 안에 쉼표로 구분 된 두 개의 숫자를 입력하여 허용되는 일치의 최소 및 최대 수를 지정한다.
숫자는 65536 보다 작아야 하며 첫 번째 숫자는 두 번째 숫자보다 작거나 같아야 한다.
예 : <code>z{2,4}</code>는 &quot;zz&quot;, &quot;zzz&quot; 또는 &quot;zzzz&quot;와 일치한다.
단독으로 닫는 중괄호는 특수 문자가 아니다.
두 번째 숫자가 생략 되었으나 쉼표가 있으면 상한이 없다.
두 번째 숫자와 쉼표가 둘 다 생략되면 수량 기호는 필요한 일치 항목의 정확한 수를 지정한다.
따라서 <code>[aeiou]{3,}</code>는 최소 3개의 연속 모음과 일치하지만 <code>\d{8}</code>은 정확히 8자리 숫자와 일치한다. 한정 기호가 허용되지 않는 위치나 한정 기호의 구문과 일치하지 않는 위치에 나타나는 여는 중괄호(<code>{}</code>)는 리터럴 문자로 사용된다. 예를 들어, <code>{,6}</code>은 한정 기호가 아니라 4자의 리터럴 문자열이다.</p>
<p>한정자 <code>{0}</code>이 허용되어 표현식이 이전 항목 및 한정 기호가 없는 것처럼 동작한다.</p>
<p>편의상 (그리고 전통적인 호환성) 세 가지 가장 일반적인 수량 기호는 한 문자로 된 약자를 사용한다 :</p>
<h4>Single-character quantifiers</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">문자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>*</code></td>
<td><code>{0,}</code>와 같다</td>
</tr>
<tr>
<td style="text-align: center;"><code>+</code></td>
<td><code>{1,}</code>와 같다</td>
</tr>
<tr>
<td style="text-align: center;"><code>?</code></td>
<td><code>{0,1}</code>와 같다</td>
</tr>
</tbody>
</table>
<p>상한이 없는 수량 기호와 일치하지 않는 서브 패턴을 따라 무한 루프를 구성 할 수 있다(예 : <code>(a?)*</code>).</p>
<p>이전 버전의 Perl과 PCRE는 그러한 패턴을 컴파일 할 때 오류를 내기도 했다. 그러나 이 방법이 유용 할 수 있기 때문에 이러한 패턴이 이제 허용되지만 실제로 서브 패턴의 반복이 실제로 문자와 일치하지 않으면 루프가 강제로 끊어진다.</p>
<p>기본적으로 한정 기호는 &quot;greedy&quot; 즉 패턴의 나머지 부분을 실패시키지 않고 가능한 한 최대 허용 횟수까지 일치시킨다. 이것이 문제를 일으키는 곳의 고전적인 예는 C 프로그램의 주석과 일치하는 것이다. 시퀀스 <code>/*</code>와 <code>*/</code> 사이에 나타나며 시퀀스 내에서 개별 <code>*</code> 및 <code>/</code> 문자가 나타날 수 있다. 첫 번째 주석 <code>*/</code> 주석 <code>/*</code> 두 번째 주석 <code>*/</code>에 문자열 <code>/**.*\*/</code> 패턴을 적용하여 C 주석을 일치 시키려는 시도는 <code>.*</code>의 탐욕으로 인해 전체 문자열과 일치하기 때문에 실패한다.</p>
<p>그러나 수량 기호 다음에 물음표가 오는 경우에는 게으르며 가능한 최소 횟수와 일치하므로 패턴 <code>/\*.*?\*/</code>는 C 주석과 함께 올바른 작업을 수행한다. 다양한 한정어의 의미는 다른 방식으로 변경되지 않으며 선호하는 일치 개수만 변경된다. 이 <code>?</code> 사용을 그 자체로 한정 기호로 사용하는 것과 혼동하지 말아야 한다. 두 가지 용도로 사용되기 때문에 <code>\d??\d</code>와 같이 두 글자로 표시되는 경우가 있다. 한 글자가 기본 설정과 일치하지만 나머지 패턴 일치하는 경우 두 글자와 일치할 수 있다.</p>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_UNGREEDY</a> 옵션이 설정되어 있으면 (Perl에서는 사용할 수없는 옵션) 수량 한정자는 기본적으로 욕심이 없지만 물음표로 따옴표를 사용하면 개별적으로 욕심을 느낄 수 있다. 즉, 기본 동작을 반전한다.</p>
<p><code>+</code> 뒤에 오는 한정 기호는 &quot;possessive&quot;이다. 가능한 한 많은 문자를 먹고 나머지 패턴과 일치하도록 돌아 가지 않는다. 따라서 <code>.*abc</code>는 &quot;aabc&quot;와 일치하지만 <code>.*+</code>는 전체 문자열을 먹기 때문에 <code>.*+abc</code>은 그렇지 않습니다. 소유량 지정자는 처리 속도를 높이는 데 사용할 수 있습니다.</p>
<p>괄호 안의 서브 패턴이 최소 반복 횟수가 1 보다 크거나 제한된 최대 값으로 정량화되면 컴파일 된 패턴에 최소 또는 최대 크기에 비례하여 더 많은 저장소가 필요하다.</p>
<p>패턴이 <code>.*</code> 또는 <code>.{0,}</code>으로 시작하고 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a> 옵션(Perl의 <code>/s</code>와 동일)이 설정되어 있으므로. 줄 바꿈과 일치시키려면 패턴은 암시적으로 고정되어 있다. 왜냐하면 뒤 따르는 것은 제목 문자열의 모든 문자 위치에 대해 시도되기 때문이다. 따라서 첫 번째 이후의 모든 위치에서 전체 일치를 다시 시도 할 필요가 없다. PCRE(Perl Compatible Regular Expressions)는 앞에 <code>\A</code>와 같은 패턴을 처리합니다. 대상 문자열에 개행 문자가없는 것으로 알려진 경우 패턴이 <code>.*</code>로 시작하는 경우 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a>을 설정하거나이 최적화를 얻기 위해 ^를 사용하거나 ^를 사용하여 명시적으로 고정을 나타낼 수 있다.</p>
<p>캡처 서브 패턴이 반복되면 캡처된 값은 최종 반복과 일치하는 하위 문자열이다. 예를 들어, <code>(tweedle[dume]{3}\s*)+</code>가 &quot;tweedledum tweedledee&quot;와 일치하면 캡처된 부분 문자열의 값은 &quot;tweedledee&quot;이다. 그러나 중첩된 캡처 서브 패턴이 있으면 해당 캡처 값이 이전 반복에서 설정 되었을 수 있다. 예를 들어,  <code>/(a|(b))+/</code>가 &quot;aba&quot;와 일치하면 두 번째로 캡처 된 하위 문자열의 값은 &quot;b&quot;가 된다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</strong></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/17/php-regex-subpatterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/17/php-regex-subpatterns/"/><published>2017-01-17T17:57:41+00:00</published><updated>2017-01-17T17:57:41+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 Subpatterns (서브 패턴) 서브 패턴은 괄호(둥근 괄호)로 구분되며 중첩 될 수 있다. 패턴의 일부를 서브 패턴으로 표시하는 것은 다음 두 가지를 수행한다. 대안 집합을 지역화 한다.예를 들어 cat(aract|erpillar|) 패턴은 "cat", "cataract" 또는 "caterpillar" 중 하나와 일치한다. 괄호가 없으면 "cataract", "erpillar" 또는 빈 문자열과 일치한다. 서브 패턴을 캡처 서브 패턴으로 설정한다. 전체 패턴이 일치하면 서브 패턴과 일치하는 문자열의 부분은 pcre_exec()의 ovector 인수를 통해 호출자에게 다시 전달된다. 여는 괄호는 왼쪽에서 오른쪽으로 (1부터 시작) 카운트하여 캡처 서브 패턴의 수를 얻는다. 예를 들어 문자열 "the red king"이 ((red|white) (king|queen)) 패턴과 일치하면 캡처된 부분 문자열이 "red king", "red"및 "king"이며 아래와 같이 번호가 매겨진다. <?php $string = 'the red king'; preg_match('/((red|white) (king|queen))/', $string, $matches); print_r($matches); //Array //( // [0] => red king // [1] => red king // [2] => red // [3] => king //) 평범한 괄호가 두 가지 기능을 수행한다는 사실이 항상 도움이되는 것은 아니다. 캡처 요구 사항없이 그룹화 서브 패턴이 필요한 경우가 종종 있다. 여는 괄호 뒤에 "?:"가 오는 경우 서브 패턴은 캡처를 수행하지 않으며 후속 캡처 서브 패턴의 수를 계산할 때는 계산되지 않는다. 예를 들어 문자열 "the white queen"이 ((?:red|white) (king|queen)) 패턴과 일치하면 캡처 된 부분 문자열은 "white queen"과 "queen"이며 1과 2로 번호가 매겨진다. 캡처된 부분 문자열의 최대 수는 99이며 캡처 및 비 캡처의 모든 서브 패턴의 최대 수는 200개다. <?php $string = 'the white queen'; preg_match('/((?:red|white) (king|queen))/', $string, $matches); print_r($matches); //Array //( // [0] => white queen // [1] => white queen // [2] => queen //) if any option settings are required at the start of a non-capturing subpattern, the option letters may appear between the "?" and the ":". Thus the two patterns 편리한 약식으로, 캡처하지 않는 서브 패턴의 시작 부분에 옵션 설정이 필요한 경우 아래의 두 패턴처럼 옵션 문자가 "?" 그리고 ":" 사이에 표기한다. (?i:saturday|sunday) (?:(?i)saturday|sunday) 정확히 동일한 문자열 세트와 일치해야 한다. 대체 분기는 왼쪽에서 오른쪽으로 시도되고 서브 패턴의 끝에 도달 할 때까지 옵션이 재설정되지 않아 한 분기의 옵션 설정이 후속 분기에 영향을 미치므로 위 패턴은 "SUNDAY"및 "Saturday"와 일치한다. 구문 (?P<name>pattern)을 사용하여 서브 패턴의 이름을 지정할 수 있다. 그런 다음이 서브 패턴은 matches 배열에서 일반 숫자 위치와 이름을 기준으로 인덱싱된다(PHP 5.2.2에서는 두 가지 대체 구문 (?<name>pattern)과 (?'name'pattern)을 소개했다). <?php $string = 'the white queen'; preg_match('/(?P<name>the)/', $string, $matches); print_r($matches); preg_match("/(?'name'the)/", $string, $matches); print_r($matches); //Array //( // [0] => the // [name] => the // [1] => the //) //Array //( // [0] => the // [name] => the // [1] => the //) 때로는 일치하는 여러 개의 서브 그룹을 정규식에 포함시켜야 할 필요가 있다. 일반적으로 이들 중 하나만 일치할 가능성이 있더라도 각각의 고유한 역 참조 번호가 부여된다. 이 문제를 극복하기 위해 (?| 구문을 사용하면 중복되는 숫자를 가질 수 있다. 다음 정규식 (?:(Sat)ur|(Sun))day을 "Sunday" 문자열과 비교해보자. <?php $string = 'Sunday'; preg_match('/(?:(Sat)ur|(Sun))day/', $string, $matches); print_r($matches); //Array //( // [0] => Sunday // [1] => // [2] => Sun //) 여기에서 Sun은 역 참조 2에 저장되고 역 참조 1은 비어 있다. 매칭률은 역 참조 1에서의 토요일은 역 참조 2에서 존재하지 않는다. (?|를 사용하기 위해 패턴을 변경하면이 문제가 해결된다. <?php $string = 'Sunday'; preg_match('/(?|(Sat)ur|(Sun))day/', $string, $matches); print_r($matches); //Array //( // [0] => Sunday // [1] => Sun //) 이 패턴을 사용하면 Sun과 Sat가 모두 역 참조 1에 저장됩니다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) > PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3><a href="http://php.net/manual/kr/regexp.reference.subpatterns.php">Subpatterns</a> (서브 패턴)</h3>
<p>서브 패턴은 괄호(둥근 괄호)로 구분되며 중첩 될 수 있다. 패턴의 일부를 서브 패턴으로 표시하는 것은 다음 두 가지를 수행한다.</p>
<ol>
<li>
<p><a href="/2017/01/15/php-regex-alternation/">대안 집합</a>을 지역화 한다.예를 들어 <code>cat(aract|erpillar|)</code> 패턴은 &quot;cat&quot;, &quot;cataract&quot; 또는 &quot;caterpillar&quot; 중 하나와 일치한다. 괄호가 없으면 &quot;cataract&quot;, &quot;erpillar&quot; 또는 빈 문자열과 일치한다.</p>
</li>
<li>서브 패턴을 캡처 서브 패턴으로 설정한다. 전체 패턴이 일치하면 서브 패턴과 일치하는 문자열의 부분은 <code>pcre_exec()</code>의 <code>ovector</code> 인수를 통해 호출자에게 다시 전달된다. 여는 괄호는 왼쪽에서 오른쪽으로 (1부터 시작) 카운트하여 캡처 서브 패턴의 수를 얻는다.</li>
</ol>
<p>예를 들어 문자열 &quot;the red king&quot;이 <code>((red|white) (king|queen))</code>  패턴과 일치하면 캡처된 부분 문자열이 &quot;red king&quot;, &quot;red&quot;및 &quot;king&quot;이며 아래와 같이 번호가 매겨진다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'the red king'</span>;
preg_match(<span class="hljs-string">'/((red|white) (king|queen))/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; red king</span>
<span class="hljs-comment">//  [1] =&gt; red king</span>
<span class="hljs-comment">//  [2] =&gt; red</span>
<span class="hljs-comment">//  [3] =&gt; king</span>
<span class="hljs-comment">//)</span></pre>
<p>평범한 괄호가 두 가지 기능을 수행한다는 사실이 항상 도움이되는 것은 아니다. 캡처 요구 사항없이 그룹화 서브 패턴이 필요한 경우가 종종 있다. 여는 괄호 뒤에 &quot;<code>?:</code>&quot;가 오는 경우 서브 패턴은 캡처를 수행하지 않으며 후속 캡처 서브 패턴의 수를 계산할 때는 계산되지 않는다.</p>
<p>예를 들어 문자열 &quot;the white queen&quot;이 <code>((?:red|white) (king|queen))</code> 패턴과 일치하면 캡처 된 부분 문자열은 &quot;white queen&quot;과 &quot;queen&quot;이며 1과 2로 번호가 매겨진다. 캡처된 부분 문자열의 최대 수는 99이며 캡처 및 비 캡처의 모든 서브 패턴의 최대 수는 200개다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'the white queen'</span>;
preg_match(<span class="hljs-string">'/((?:red|white) (king|queen))/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; white queen</span>
<span class="hljs-comment">//  [1] =&gt; white queen</span>
<span class="hljs-comment">//  [2] =&gt; queen</span>
<span class="hljs-comment">//)</span></pre>
<p>if any option settings are required at the start of a non-capturing subpattern, the option letters may appear between the &quot;?&quot; and the &quot;:&quot;. Thus the two patterns</p>
<p>편리한 약식으로, 캡처하지 않는 서브 패턴의 시작 부분에 옵션 설정이 필요한 경우 아래의 두 패턴처럼 옵션 문자가 &quot;?&quot; 그리고 &quot;:&quot; 사이에 표기한다.</p>
<pre><code>(?i:saturday|sunday)
(?:(?i)saturday|sunday)</code></pre>
<p>정확히 동일한 문자열 세트와 일치해야 한다. 대체 분기는 왼쪽에서 오른쪽으로 시도되고 서브 패턴의 끝에 도달 할 때까지 옵션이 재설정되지 않아 한 분기의 옵션 설정이 후속 분기에 영향을 미치므로 위 패턴은 &quot;SUNDAY&quot;및 &quot;Saturday&quot;와 일치한다.</p>
<p>구문 <code>(?P&lt;name&gt;pattern)</code>을 사용하여 서브 패턴의 이름을 지정할 수 있다. 그런 다음이 서브 패턴은 matches 배열에서 일반 숫자 위치와 이름을 기준으로 인덱싱된다(PHP 5.2.2에서는 두 가지 대체 구문 <code>(?&lt;name&gt;pattern)</code>과 <code>(?'name'pattern)</code>을 소개했다).</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'the white queen'</span>;
preg_match(<span class="hljs-string">'/(?P&lt;name&gt;the)/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
preg_match(<span class="hljs-string">"/(?'name'the)/"</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; the</span>
<span class="hljs-comment">//  [name] =&gt; the</span>
<span class="hljs-comment">//  [1] =&gt; the</span>
<span class="hljs-comment">//)</span>
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; the</span>
<span class="hljs-comment">//  [name] =&gt; the</span>
<span class="hljs-comment">//  [1] =&gt; the</span>
<span class="hljs-comment">//)</span></pre>
<p>때로는 일치하는 여러 개의 서브 그룹을 정규식에 포함시켜야 할 필요가 있다. 일반적으로 이들 중 하나만 일치할 가능성이 있더라도 각각의 고유한 역 참조 번호가 부여된다. 이 문제를 극복하기 위해 <code>(?|</code> 구문을 사용하면 중복되는 숫자를 가질 수 있다. 다음 정규식 <code>(?:(Sat)ur|(Sun))day</code>을 &quot;Sunday&quot; 문자열과 비교해보자.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'Sunday'</span>;
preg_match(<span class="hljs-string">'/(?:(Sat)ur|(Sun))day/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; Sunday</span>
<span class="hljs-comment">//  [1] =&gt;</span>
<span class="hljs-comment">//  [2] =&gt; Sun</span>
<span class="hljs-comment">//)</span></pre>
<p>여기에서 Sun은 역 참조 2에 저장되고 역 참조 1은 비어 있다. 매칭률은 역 참조 1에서의 토요일은 역 참조 2에서 존재하지 않는다. <code>(?|</code>를 사용하기 위해 패턴을 변경하면이 문제가 해결된다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'Sunday'</span>;
preg_match(<span class="hljs-string">'/(?|(Sat)ur|(Sun))day/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);
<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; Sunday</span>
<span class="hljs-comment">//  [1] =&gt; Sun</span>
<span class="hljs-comment">//)</span></pre>
<p>이 패턴을 사용하면 Sun과 Sat가 모두 역 참조 1에 저장됩니다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</strong></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/16/php-regex-internal-option-setting/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/16/php-regex-internal-option-setting/"/><published>2017-01-16T14:36:21+00:00</published><updated>2017-01-16T14:36:21+00:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[문서 내용 보강중 Internal option setting (내부 옵션 설정) PHP 정규표현식 패턴에 존재하는 변경자와 유사하게 사용되나 사용 위치가 다르다. PCRE_CASELESS, PCRE_MULTILINE,PCRE_DOTALL, PCRE_UNGREEDY, PCRE_EXTRA, PCRE_EXTENDED 및 PCRE_DUPNAMES의 설정은 "(?"및 ")"로 묶인 Perl 옵션 문자 시퀀스에 의해 패턴 내에서 변경할 수 있다. 옵션 문자는 다음과 같다. Internal option letters 옵션 설명 i PCRE_CASELESS m PCRE_MULTILINE s PCRE_DOTALL x PCRE_EXTENDED U PCRE_UNGREEDY X PCRE_EXTRA J PCRE_INFO_JCHANGED 예를 들어, (?im)은 대소문자를 구분하지 않고 (caseless) 여러 줄 일치를 설정한다. 문자 앞에 하이픈을 붙여 이러한 옵션의 설정을 해제 할 수도 있으며 PCRE_DOTALL 및 PCRE_EXTENDED 설정을 해제하면서 PCRE_CASELESS 및 PCRE_MULTILINE을 설정하는 (?im-sx)와 같은 조합된 설정 및 해제도 허용된다. 하이픈 앞뒤에 문자가 표시되면 옵션이 설정되지 않는다. 옵션 변경이 최상위 레벨에서 발생하면 (즉, 서브 패턴 괄호 안쪽에있는 경우), 변경 사항은 뒤 따르는 패턴의 나머지 부분에 적용됩니다. 그래서 /ab(?i)c/는 "abc"와 "abC"에만 일치한다. 서브 패턴 내에서 옵션 변경이 발생하면 효과가 달라진다. 이것은 Perl 5.005의 동작 변경이다. 서브 패턴 내부의 옵션 변경은 그 뒤에 오는 서브 패턴의 해당 부분에만 영향을 미치므로 a(?i)b)c는 abc 및 aBc와 일치하며 다른 문자열은 없다 (PCRE_CASELESS가 사용되지 않는다고 가정). 이 방법을 사용하면 패턴의 다른 부분에서 옵션을 다르게 설정할 수 있다. 하나의 대안에서 변경한 사항은 동일한 서브 패턴 내의 후속 분기로 이어진다. 예를 들어 (a(?i)b|c)는 "ab", "aB", "c"및 "C"와 일치하지만 "C"와 일치할 때 첫 번째 분기가 옵션 설정 전에 취소 되더라도 마찬가지다. 이것은 옵션 설정의 효과가 컴파일 타임에 발생하기 때문이다. 달리 아주 이상한 행동이있을 것이다. PCRE 특정 옵션 PCRE_UNGREEDY 및 PCRE_EXTRA는 각각 U 및 X 문자를 사용하여 Perl 호환 옵션과 동일한 방식으로 변경할 수 있다. (?X) 플래그 설정은 최상위 레벨에있을 때에도 켜지는 추가 기능보다 항상 패턴에서 더 일찍 발생해야 한다는 점에서 특별하다. 처음 시작할 때 가장 좋다. PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 점(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 대안(Alternation) > PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<blockquote>
<p>문서 내용 보강중</p>
</blockquote>
<h3><a href="http://php.net/manual/kr/regexp.reference.internal-options.php">Internal option setting</a> (내부 옵션 설정)</h3>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PHP 정규표현식 패턴에 존재하는 변경자</a>와 유사하게 사용되나 사용 위치가 다르다.</p>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_CASELESS</a>, <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_MULTILINE</a>,<a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a>, <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_UNGREEDY</a>, <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTRA</a>, <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 및 PCRE_DUPNAMES의 설정은 &quot;(?&quot;및 &quot;)&quot;로 묶인 Perl 옵션 문자 시퀀스에 의해 패턴 내에서 변경할 수 있다. 옵션 문자는 다음과 같다.</p>
<h4>Internal option letters</h4>
<table>
<thead>
<tr>
<th>옵션</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_CASELESS</a></td>
</tr>
<tr>
<td>m</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_MULTILINE</a></td>
</tr>
<tr>
<td>s</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a></td>
</tr>
<tr>
<td>x</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a></td>
</tr>
<tr>
<td>U</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_UNGREEDY</a></td>
</tr>
<tr>
<td>X</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTRA</a></td>
</tr>
<tr>
<td>J</td>
<td><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_INFO_JCHANGED</a></td>
</tr>
</tbody>
</table>
<p>예를 들어, <code>(?im)</code>은 대소문자를 구분하지 않고 (caseless) 여러 줄 일치를 설정한다. 문자 앞에 하이픈을 붙여 이러한 옵션의 설정을 해제 할 수도 있으며 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_DOTALL</a> 및 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 설정을 해제하면서 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_CASELESS</a> 및 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_MULTILINE</a>을 설정하는 <code>(?im-sx)</code>와 같은 조합된 설정 및 해제도 허용된다. 하이픈 앞뒤에 문자가 표시되면 옵션이 설정되지 않는다.</p>
<p>옵션 변경이 최상위 레벨에서 발생하면 (즉, 서브 패턴 괄호 안쪽에있는 경우), 변경 사항은 뒤 따르는 패턴의 나머지 부분에 적용됩니다. 그래서 <code>/ab(?i)c/</code>는 &quot;abc&quot;와 &quot;abC&quot;에만 일치한다.</p>
<p>서브 패턴 내에서 옵션 변경이 발생하면 효과가 달라진다. 이것은 Perl 5.005의 동작 변경이다. 서브 패턴 내부의 옵션 변경은 그 뒤에 오는 서브 패턴의 해당 부분에만 영향을 미치므로 <code>a(?i)b)c</code>는 abc 및 aBc와 일치하며 다른 문자열은 없다 (<a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_CASELESS</a>가 사용되지 않는다고 가정). 이 방법을 사용하면 패턴의 다른 부분에서 옵션을 다르게 설정할 수 있다. 하나의 대안에서 변경한 사항은 동일한 서브 패턴 내의 후속 분기로 이어진다. 예를 들어 <code>(a(?i)b|c)</code>는 &quot;ab&quot;, &quot;aB&quot;, &quot;c&quot;및 &quot;C&quot;와 일치하지만 &quot;C&quot;와 일치할 때 첫 번째 분기가 옵션 설정 전에 취소 되더라도 마찬가지다. 이것은 옵션 설정의 효과가 컴파일 타임에 발생하기 때문이다. 달리 아주 이상한 행동이있을 것이다.</p>
<p>PCRE 특정 옵션 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_UNGREEDY</a> 및 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTRA</a>는 각각 U 및 X 문자를 사용하여 Perl 호환 옵션과 동일한 방식으로 변경할 수 있다. <code>(?X)</code> 플래그 설정은 최상위 레벨에있을 때에도 켜지는 추가 기능보다 항상 패턴에서 더 일찍 발생해야 한다는 점에서 특별하다. 처음 시작할 때 가장 좋다.</p>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 점(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 대안(Alternation)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</strong></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>


</feed>