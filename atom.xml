<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

<title>이 세상에 하나는 남기고 가자</title><id>https://blog.asamaru.net/</id><updated>2017-04-05T17:25:50+09:00</updated><subtitle>세상에 필요한 소스코드 한줄 남기고 가자</subtitle><link href="https://blog.asamaru.net/" rel="alternate" type="text/html" /><link href="https://blog.asamaru.net/atom.xml" rel="self" type="application/atom+xml" /><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author>
<entry><id>https://blog.asamaru.net/2017/04/04/css-image-vertical-center/</id><title type="html">CSS로 이미지 세로 중앙 정렬(Vertical align)하기</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/04/04/css-image-vertical-center/"/><published>2017-04-04T17:14:41+09:00</published><updated>2017-04-04T17:14:41+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="css" label="css" /><summary><![CDATA[HTML에서 <img>를 CSS만으로 비율을 유지한 채로 특정 영역의 중앙에 출력하는 방법은 다음과 같다. <!DOCTYPE html> <html> <head> <meta charset="utf-8"/> <style type="text/css"> /* 예시를 위한 css */ dl { float:left; margin-right:20px; } dt { clear:both; } dd { margin:0 0 20px 0; padding:10px; float:left; } dd > img, dd > div { border:#ccc solid 1px; float:left; margin-right:10px; } /* position 을 이용한 방법 */ div.box1 { position:relative; width:150px; height:200px; } div.box1 > img { position:absolute; max-width:100%; max-height:100%; width:auto; height:auto; margin:auto; top:0; bottom:0; left:0; right:0; } /* line-height 를 이용한 방법 */ div.box2 { width:150px; height:200px; line-height:200px; text-align:center; } div.box2 > img { max-width:100%; max-height:100%; vertical-align:middle; } /* :before / content 를 이용한 방법 */ div.box3 { width:150px; height:200px; text-align:center; white-space:nowrap; font:0/0 a; } div.box3:before { content:""; display:inline-block; vertical-align:middle; height:100%; } div.box3 > img { max-width:100%; max-height:100%; display:inline-block; vertical-align:middle; } /* flex 를 이용한 방법 */ div.box4 { width:150px; height:200px; display:flex; justify-content:center; align-items:center; } div.box4 > img { max-width:100%; max-height:100%; } </style> </head> <body> <dl> <dt>position 을 이용한 방법</dt> <dd> <div class="box1"> <img src="test_100px.png" alt="test image"/> </div> <div class="box1"> <img src="test_550px.png" alt="test image"/> </div> </dd> <dt>line-height 를 이용한 방법</dt> <dd> <div class="box2"> <img src="test_100px.png" alt="test image"/> </div> <div class="box2"> <img src="test_550px.png" alt="test image"/> </div> </dd> </dl> <dl> <dt>:before / content 를 이용한 방법</dt> <dd> <div class="box3"> <img src="test_100px.png" alt="test image"/> </div> <div class="box3"> <img src="test_550px.png" alt="test image"/> </div> </dd> <dt>flex 를 이용한 방법</dt> <dd> <div class="box4"> <img src="test_100px.png" alt="test image"/> </div> <div class="box4"> <img src="test_550px.png" alt="test image"/> </div> </dd> </dl> </body> </html> 총 4가지 방법을 예시로 나열했지만 나의 경우는 크로스 브라우징을 위해 "position 을 이용한 방법"이나 "line-height 를 이용한 방법"을 주로 사용한다. 하지만 상황에 따라서는 다른 방법이 유용할 수도 있기에 함께 남겨둔다. 그리고 여기서 사용된 원리를 잘 이용하면 다른 레이아웃을 구성하는데도 도움이 되니 한번쯤은 원리를 참고해보면 좋을 듯하다.]]></summary><content type="html"><![CDATA[<p>HTML에서 <code>&lt;img&gt;</code>를 CSS만으로 비율을 유지한 채로 특정 영역의 중앙에 출력하는 방법은 다음과 같다.</p>
<p><img src="/res/img/post/2017/04/image_align_center.png" alt="phpstorm formatter markers" width="706" height="509" /></p>
<pre class="hljs xml"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">"utf-8"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">style</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/css"</span>&gt;</span><span class="css">
        <span class="hljs-comment">/* 예시를 위한 css */</span>
        <span class="hljs-tag">dl</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">float</span>:<span class="hljs-value">left</span></span>; <span class="hljs-rule"><span class="hljs-attribute">margin-right</span>:<span class="hljs-value"><span class="hljs-number">20px</span></span></span>; }</span>
        <span class="hljs-tag">dt</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">clear</span>:<span class="hljs-value">both</span></span>; }</span>
        <span class="hljs-tag">dd</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> <span class="hljs-number">0</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"><span class="hljs-number">10px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">float</span>:<span class="hljs-value">left</span></span>; }</span>
        <span class="hljs-tag">dd</span> &gt; <span class="hljs-tag">img</span>,
        <span class="hljs-tag">dd</span> &gt; <span class="hljs-tag">div</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"><span class="hljs-hexcolor">#ccc</span> solid <span class="hljs-number">1px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">float</span>:<span class="hljs-value">left</span></span>; <span class="hljs-rule"><span class="hljs-attribute">margin-right</span>:<span class="hljs-value"><span class="hljs-number">10px</span></span></span>; }</span>
        <span class="hljs-comment">/* position 을 이용한 방법 */</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box1</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value">relative</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">150px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">200px</span></span></span>;
        }</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box1</span> &gt; <span class="hljs-tag">img</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value">absolute</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">max-width</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">max-height</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value">auto</span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value">auto</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value">auto</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">top</span>:<span class="hljs-value"><span class="hljs-number">0</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">bottom</span>:<span class="hljs-value"><span class="hljs-number">0</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">left</span>:<span class="hljs-value"><span class="hljs-number">0</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">right</span>:<span class="hljs-value"><span class="hljs-number">0</span></span></span>;
        }</span>
        <span class="hljs-comment">/* line-height 를 이용한 방법 */</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box2</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">150px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">200px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">line-height</span>:<span class="hljs-value"><span class="hljs-number">200px</span></span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">text-align</span>:<span class="hljs-value">center</span></span>;
        }</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box2</span> &gt; <span class="hljs-tag">img</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">max-width</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">max-height</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">vertical-align</span>:<span class="hljs-value">middle</span></span>;
        }</span>
        <span class="hljs-comment">/* :before / content 를 이용한 방법 */</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box3</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">150px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">200px</span></span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">text-align</span>:<span class="hljs-value">center</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">white-space</span>:<span class="hljs-value">nowrap</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">font</span>:<span class="hljs-value"><span class="hljs-number">0</span>/<span class="hljs-number">0</span> a</span></span>;
        }</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box3</span><span class="hljs-pseudo">:before</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"><span class="hljs-string">""</span></span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value">inline-block</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">vertical-align</span>:<span class="hljs-value">middle</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>;
        }</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box3</span> &gt; <span class="hljs-tag">img</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">max-width</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">max-height</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value">inline-block</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">vertical-align</span>:<span class="hljs-value">middle</span></span>;
        }</span>
        <span class="hljs-comment">/* flex 를 이용한 방법 */</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box4</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">150px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"><span class="hljs-number">200px</span></span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">display</span>:<span class="hljs-value">flex</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">justify-content</span>:<span class="hljs-value">center</span></span>;
            <span class="hljs-rule"><span class="hljs-attribute">align-items</span>:<span class="hljs-value">center</span></span>;
        }</span>
        <span class="hljs-tag">div</span><span class="hljs-class">.box4</span> &gt; <span class="hljs-tag">img</span> <span class="hljs-rules">{
            <span class="hljs-rule"><span class="hljs-attribute">max-width</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">max-height</span>:<span class="hljs-value"><span class="hljs-number">100%</span></span></span>;
        }</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">dl</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">dt</span>&gt;</span>position 을 이용한 방법<span class="hljs-tag">&lt;/<span class="hljs-title">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">dd</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"box1"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test_100px.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"test image"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"box1"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test_550px.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"test image"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">dd</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">dt</span>&gt;</span>line-height 를 이용한 방법<span class="hljs-tag">&lt;/<span class="hljs-title">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">dd</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"box2"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test_100px.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"test image"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"box2"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test_550px.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"test image"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">dd</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">dl</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">dl</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">dt</span>&gt;</span>:before / content 를 이용한 방법<span class="hljs-tag">&lt;/<span class="hljs-title">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">dd</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"box3"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test_100px.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"test image"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"box3"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test_550px.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"test image"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">dd</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">dt</span>&gt;</span>flex 를 이용한 방법<span class="hljs-tag">&lt;/<span class="hljs-title">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">dd</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"box4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test_100px.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"test image"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"box4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test_550px.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"test image"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">dd</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">dl</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></pre>
<p>총 4가지 방법을 예시로 나열했지만 나의 경우는 크로스 브라우징을 위해 &quot;position 을 이용한 방법&quot;이나 &quot;line-height 를 이용한 방법&quot;을 주로 사용한다. 하지만 상황에 따라서는 다른 방법이 유용할 수도 있기에 함께 남겨둔다. 그리고 여기서 사용된 원리를 잘 이용하면 다른 레이아웃을 구성하는데도 도움이 되니 한번쯤은 원리를 참고해보면 좋을 듯하다.</p>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/04/02/php-lock-file-using-symlink/</id><title type="html">PHP에서 symlink()를 이용해 lock 구현하기</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/04/02/php-lock-file-using-symlink/"/><published>2017-04-02T17:26:08+09:00</published><updated>2017-04-02T17:26:08+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[PHP에서 외부 Extensions 없이 간단히 lock을 구현하고자 할 때 file을 이용하는 경우가 많다(file에 대한 읽기/쓰기 lock을 말하는 것이 아니다). 예를들어 어떤 프로세스가 중첩되어 실행되는 것을 막기 위한 lock이 필요할 수 있다. 나의 경우는 Laravel의 Queue를 사용하면서 Daemon을 동시에 여러개를 띄운 상황에서 특정 작업의 중첩을 막기 위해 필요했다. Job에 대한 중복 실행은 Laravel의 Queue가 DB lock을 이용해 자체적으로 처리한다. 하지만 나는 Job의 중복 실행을 막는 것이 아닌 프로세스의 중첩을 막는 것이 필요했다. 가장 간단한 구현을 생각하면 아래와 같이 할 수 있다. #!/usr/bin/php <?php define('LOCK_FILE', "/var/run/" . basename($argv[0], ".php") . ".lock"); if (isLocked()) { die("Already running.\n"); } # The rest of your script goes here.... echo "Hello world!\n"; sleep(30); unlink(LOCK_FILE); exit(0); function isLocked() { # If lock file exists, check if stale. If exists and is not stale, return TRUE # Else, create lock file and return FALSE. if (file_exists(LOCK_FILE)) { # check if it's stale $lockingPID = trim(file_get_contents(LOCK_FILE)); # Get all active PIDs. $pids = explode("\n", trim(`ps -e | awk '{print $1}'`)); # If PID is still active, return true if (in_array($lockingPID, $pids)) { return true; } # Lock-file is stale, so kill it. Then move on to re-creating it. echo "Removing stale lock file.\n"; unlink(LOCK_FILE); } file_put_contents(LOCK_FILE, getmypid() . "\n"); return false; } 위 코드는 Kevin Traas가 제시한 코드다. 내가 laravel에서 구현 했던 코드는 예시로 사용하기엔 여러 가지 다른 코드가 섞여있어 이해하기 쉬운 코드로 예를 들었다. 어차피 원리는 거의 유사하다. 위 코드는 잘 동작할 것처럼 보이지만 그렇지 않다(일반적인 상황에서는 잘 동작한다). 이유는 lock을 검사하는 코드와 lock을 생성하는 코드 사이에 다른 프로세스가 끼어들 수 있기 때문이다. 위에서 이야기한 것처럼 Daemon이 동시에 여러개 떠 있는 상황에서 동시에 lock을 사용하다보면 생각보다 빈번하게 오작동 한다(프로세스가 중첩된다). 이 문제를 해결하기 위해서는 symlink()를 이용하는 방법이 있다. 아래는 Kevin Traas가 제시한 코드의 문제와 해결 방법을 제시한 Radu Cristescu의 코드다. #!/usr/bin/php <?php define('LOCK_FILE', "/var/run/" . basename($argv[0], ".php") . ".lock"); if (!tryLock()) { die("Already running.\n"); } # remove the lock on exit (Control+C doesn't count as 'exit'?) register_shutdown_function('unlink', LOCK_FILE); # The rest of your script goes here.... echo "Hello world!\n"; sleep(30); exit(0); function tryLock() { # If lock file exists, check if stale. If exists and is not stale, return TRUE # Else, create lock file and return FALSE. if (@symlink("/proc/" . getmypid(), LOCK_FILE) !== false) # the @ in front of 'symlink' is to suppress the NOTICE you get if the LOCK_FILE exists { return true; } # link already exists # check if it's stale if (is_link(LOCK_FILE) && !is_dir(LOCK_FILE)) { unlink(LOCK_FILE); # try to lock again return tryLock(); } return false; } 간단히 설명하자면 symlink()를 이용해서 lock이 걸려 있는지를 검사하는 과정과 lock을 생성하는 과정을 한번에 처리하는 것이다. 이 방법을 사용하면 보다 안전하게 lock-file 매커니즘을 사용할 수 있다.]]></summary><content type="html"><![CDATA[<p><a href="http://php.net/">PHP</a>에서 외부 Extensions 없이 간단히 lock을 구현하고자 할 때 file을 이용하는 경우가 많다(file에 대한 읽기/쓰기 lock을 말하는 것이 아니다).</p>
<p>예를들어 어떤 프로세스가 중첩되어 실행되는 것을 막기 위한 lock이 필요할 수 있다. 나의 경우는 <a href="https://laravel.com/">Laravel</a>의 <a href="https://laravel.com/docs/master/queues">Queue</a>를 사용하면서 Daemon을 동시에 여러개를 띄운 상황에서 특정 작업의 중첩을 막기 위해 필요했다. Job에 대한 중복 실행은 Laravel의 Queue가 DB lock을 이용해 자체적으로 처리한다. 하지만 나는 Job의 중복 실행을 막는 것이 아닌 프로세스의 중첩을 막는 것이 필요했다.</p>
<p>가장 간단한 구현을 생각하면 아래와 같이 할 수 있다.</p>
<pre class="hljs php"><span class="hljs-comment">#!/usr/bin/php</span>
<span class="hljs-preprocessor">&lt;?php</span>
define(<span class="hljs-string">'LOCK_FILE'</span>, <span class="hljs-string">"/var/run/"</span> . basename(<span class="hljs-variable">$argv</span>[<span class="hljs-number">0</span>], <span class="hljs-string">".php"</span>) . <span class="hljs-string">".lock"</span>);
<span class="hljs-keyword">if</span> (isLocked()) {
    <span class="hljs-keyword">die</span>(<span class="hljs-string">"Already running.\n"</span>);
}

<span class="hljs-comment"># The rest of your script goes here....</span>
<span class="hljs-keyword">echo</span> <span class="hljs-string">"Hello world!\n"</span>;
sleep(<span class="hljs-number">30</span>);

unlink(LOCK_FILE);
<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment"># If lock file exists, check if stale.  If exists and is not stale, return TRUE</span>
    <span class="hljs-comment"># Else, create lock file and return FALSE.</span>

    <span class="hljs-keyword">if</span> (file_exists(LOCK_FILE)) {
        <span class="hljs-comment"># check if it's stale</span>
        <span class="hljs-variable">$lockingPID</span> = trim(file_get_contents(LOCK_FILE));

        <span class="hljs-comment"># Get all active PIDs.</span>
        <span class="hljs-variable">$pids</span> = explode(<span class="hljs-string">"\n"</span>, trim(`ps -e | awk <span class="hljs-string">'{print $1}'</span>`));

        <span class="hljs-comment"># If PID is still active, return true</span>
        <span class="hljs-keyword">if</span> (in_array(<span class="hljs-variable">$lockingPID</span>, <span class="hljs-variable">$pids</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }

        <span class="hljs-comment"># Lock-file is stale, so kill it.  Then move on to re-creating it.</span>
        <span class="hljs-keyword">echo</span> <span class="hljs-string">"Removing stale lock file.\n"</span>;
        unlink(LOCK_FILE);
    }

    file_put_contents(LOCK_FILE, getmypid() . <span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

}</pre>
<p>위 코드는 <a href="http://php.net/manual/en/function.getmypid.php#93753">Kevin Traas가 제시한 코드</a>다. 내가 laravel에서 구현 했던 코드는 예시로 사용하기엔 여러 가지 다른 코드가 섞여있어 이해하기 쉬운 코드로 예를 들었다. 어차피 원리는 거의 유사하다.</p>
<p>위 코드는 잘 동작할 것처럼 보이지만 그렇지 않다(일반적인 상황에서는 잘 동작한다). 이유는 lock을 검사하는 코드와 lock을 생성하는 코드 사이에 다른 프로세스가 끼어들 수 있기 때문이다.</p>
<p>위에서 이야기한 것처럼 Daemon이 동시에 여러개 떠 있는 상황에서 동시에 lock을 사용하다보면 생각보다 빈번하게 오작동 한다(프로세스가 중첩된다).</p>
<p>이 문제를 해결하기 위해서는 <a href="http://php.net/manual/en/function.symlink.php">symlink()</a>를 이용하는 방법이 있다.</p>
<p>아래는 Kevin Traas가 제시한 코드의 문제와 해결 방법을 제시한 <a href="http://php.net/manual/en/function.getmypid.php#112782">Radu Cristescu의 코드</a>다.</p>
<pre class="hljs php"><span class="hljs-comment">#!/usr/bin/php</span>
<span class="hljs-preprocessor">&lt;?php</span>

define(<span class="hljs-string">'LOCK_FILE'</span>, <span class="hljs-string">"/var/run/"</span> . basename(<span class="hljs-variable">$argv</span>[<span class="hljs-number">0</span>], <span class="hljs-string">".php"</span>) . <span class="hljs-string">".lock"</span>);

<span class="hljs-keyword">if</span> (!tryLock()) {
    <span class="hljs-keyword">die</span>(<span class="hljs-string">"Already running.\n"</span>);
}

<span class="hljs-comment"># remove the lock on exit (Control+C doesn't count as 'exit'?)</span>
register_shutdown_function(<span class="hljs-string">'unlink'</span>, LOCK_FILE);

<span class="hljs-comment"># The rest of your script goes here....</span>
<span class="hljs-keyword">echo</span> <span class="hljs-string">"Hello world!\n"</span>;
sleep(<span class="hljs-number">30</span>);

<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-comment"># If lock file exists, check if stale.  If exists and is not stale, return TRUE</span>
    <span class="hljs-comment"># Else, create lock file and return FALSE.</span>

    <span class="hljs-keyword">if</span> (@symlink(<span class="hljs-string">"/proc/"</span> . getmypid(), LOCK_FILE) !== <span class="hljs-keyword">false</span>) <span class="hljs-comment"># the @ in front of 'symlink' is to suppress the NOTICE you get if the LOCK_FILE exists</span>
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-comment"># link already exists</span>
    <span class="hljs-comment"># check if it's stale</span>
    <span class="hljs-keyword">if</span> (is_link(LOCK_FILE) &amp;&amp; !is_dir(LOCK_FILE)) {
        unlink(LOCK_FILE);
        <span class="hljs-comment"># try to lock again</span>
        <span class="hljs-keyword">return</span> tryLock();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}</pre>
<p>간단히 설명하자면 <a href="http://php.net/manual/en/function.symlink.php">symlink()</a>를 이용해서 lock이 걸려 있는지를 검사하는 과정과 lock을 생성하는 과정을 한번에 처리하는 것이다. 이 방법을 사용하면 보다 안전하게 lock-file 매커니즘을 사용할 수 있다.</p>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/04/01/phpstorm-disable-code-formatting-for-part-of-code/</id><title type="html">PhpStorm에서 부분적으로 코드 포멧팅(code formatting) disable 하기</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/04/01/phpstorm-disable-code-formatting-for-part-of-code/"/><published>2017-04-01T17:27:25+09:00</published><updated>2017-04-01T17:27:25+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><category term="tip" label="tip" /><summary><![CDATA[PhpStorm을 사용하면서 자주 이용하는 기능 중 하나가 code formatting 기능이다. 코드의 가독성을 높이고 code style을 유지하는데 도움이 되기 때문이다. 이 기능을 사용하면서 항상 불편했던 것 중 하나가 부분적으로 code formatting을 제외할 수 없다는 것이었다. 그런데 알고 보니 이미 부분적으로 code formatting을 제외하는 기능이 존재했다. PhpStorm 중 2016.x 와 2017.x 기준으로 Preferences > Editor > Code Style > Formatter Control에서 'Enable formatter markers in comments'를 체크 해주고 code formatting 을 제외하고 싶은 곳을 @formatter:off와 @formatter:on으로 둘러싸주면 된다(설정을 보면 알겠지만 문구는 변경이 가능하다). PhpStorm 중 version 14의 경우는 Preferences > Editor > Code Style > Formatter Control에서 설정 가능하다고 한다. PHP를 기준으로 아래와 같이 사용 할 수 있다. <?php // @formatter:off $a = 1; $b = 2; // @formatter:on 또한, blade 템플릿을 기준으로 아래와 같이 사용 할 수 있다. {{--@formatter:off--}} @if(!empty($conf['site']['googleAnalytics'])) <script> if (typeof window.GoogleAnalyticsObject == 'undefined') { (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '{{$conf['site']['googleAnalytics']}}', 'auto'); ga('send', 'pageview'); } </script> @endif {{--@formatter:on--}} 위의 예시를 보면 알겠지만 @formatter 문구는 주석으로 처리하면 된다(다른 언어의 경우도 해당 언어에서의 주석으로 처리하면 된다). 참고 : How to disable code formatting for some part of the code using comments?]]></summary><content type="html"><![CDATA[<p><a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a>을 사용하면서 자주 이용하는 기능 중 하나가 code formatting 기능이다. 코드의 가독성을 높이고 code style을 유지하는데 도움이 되기 때문이다.</p>
<p>이 기능을 사용하면서 항상 불편했던 것 중 하나가 부분적으로 code formatting을 제외할 수 없다는 것이었다. 그런데 알고 보니 이미 부분적으로 code formatting을 제외하는 기능이 존재했다.</p>
<p>PhpStorm 중 2016.x 와 2017.x 기준으로 <code>Preferences &gt; Editor &gt; Code Style &gt; Formatter Control</code>에서 'Enable formatter markers in comments'를 체크 해주고 code formatting 을 제외하고 싶은 곳을 <code>@formatter:off</code>와 <code>@formatter:on</code>으로 둘러싸주면 된다(설정을 보면 알겠지만 문구는 변경이 가능하다).</p>
<p><img src="/res/img/post/2017/04/phpstorm_formatter_markers.png" alt="phpstorm formatter markers" width="1035" height="734" /></p>
<p>PhpStorm 중 version 14의 경우는 <code>Preferences &gt; Editor &gt; Code Style &gt; Formatter Control</code>에서 설정 가능하다고 한다.</p>
<p>PHP를 기준으로 아래와 같이 사용 할 수 있다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>

<span class="hljs-comment">// @formatter:off</span>
<span class="hljs-variable">$a</span> = <span class="hljs-number">1</span>;
<span class="hljs-variable">$b</span> = <span class="hljs-number">2</span>;
<span class="hljs-comment">// @formatter:on</span></pre>
<p>또한, blade 템플릿을 기준으로 아래와 같이 사용 할 수 있다.</p>
<pre class="hljs xml">{{--@formatter:off--}}
@if(!empty($conf['site']['googleAnalytics']))
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span>.GoogleAnalyticsObject == <span class="hljs-string">'undefined'</span>) {
      (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i,s,o,g,r,a,m</span>)</span>{i[<span class="hljs-string">'GoogleAnalyticsObject'</span>]=r;i[r]=i[r]||<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
          (i[r].q=i[r].q||[]).push(<span class="hljs-built_in">arguments</span>)},i[r].l=<span class="hljs-number">1</span>*<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();a=s.createElement(o),
        m=s.getElementsByTagName(o)[<span class="hljs-number">0</span>];a.async=<span class="hljs-number">1</span>;a.src=g;m.parentNode.insertBefore(a,m)
      })(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>,<span class="hljs-string">'script'</span>,<span class="hljs-string">'https://www.google-analytics.com/analytics.js'</span>,<span class="hljs-string">'ga'</span>);

      ga(<span class="hljs-string">'create'</span>, <span class="hljs-string">'{{$conf['</span>site<span class="hljs-string">']['</span>googleAnalytics<span class="hljs-string">']}}'</span>, <span class="hljs-string">'auto'</span>);
      ga(<span class="hljs-string">'send'</span>, <span class="hljs-string">'pageview'</span>);
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
@endif
{{--@formatter:on--}}</pre>
<p>위의 예시를 보면 알겠지만 <code>@formatter</code> 문구는 주석으로 처리하면 된다(다른 언어의 경우도 해당 언어에서의 주석으로 처리하면 된다).</p>
<hr />
<p>참고 : <a href="http://stackoverflow.com/a/19492318">How to disable code formatting for some part of the code using comments?</a></p>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/03/17/laravel-schedule-artisan-commands-in-a-package/</id><title type="html">laravel(또는 lumen) package 에서 schedule 추가</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/03/17/laravel-schedule-artisan-commands-in-a-package/"/><published>2017-03-17T11:25:36+09:00</published><updated>2017-03-17T11:25:36+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><category term="laravel" label="laravel" /><summary><![CDATA[laravel을 사용하는 프로젝트에서 schedule 처리는 Task Scheduling에 안내되어 있는 것처럼 \App\Console\Kernel의 schedule(Schedule $schedule) 메서드 내에서 정의해서 사용한다. laravel 기반 프로젝트에 추가한 package(module)에서 직접 schedule을 추가하고 싶다면 어떻게 해야 할까? 이 부분에 대해서는 메뉴얼 상에 안내된 내용이 없다. 하지만 "How to schedule Artisan commands in a package?" 글을 참고하면 아래와 같이 처리할 수 있다. use Illuminate\Support\ServiceProvider; use Illuminate\Console\Scheduling\Schedule; class ScheduleServiceProvider extends ServiceProvider { public function boot() { $this->app->booted(function () { $schedule = $this->app->make(Schedule::class); $schedule->command('some:command')->everyMinute(); }); } public function register() { } } Application Class의 booted($callback) 함수를 사용해서 schedule을 추가하는 것이다. 그런데 이 booted 함수가 lumen에서는 존재하지 않는다. booted 함수가 없는 것이 문제가 되는 이유는 schedule 개체를 만드는 Kernel Class의 defineConsoleSchedule() 메서드가 아래와 같이 구현되어 있으며 이 메서드는 Provider가 구성된 이후에 실행 되므로 $schedule 개체에 추가적인 schedule을 추가할 수 있는 진입 지점이 없다. protected function defineConsoleSchedule() { $this->app->instance( 'Illuminate\Console\Scheduling\Schedule', $schedule = new Schedule($this->app[Cache::class]) ); $this->schedule($schedule); } 따라서 lumen 프로젝트에서는 package 내부에서 직접적으로 schedule을 추가하는 것은 불가능해 보인다. 굳이 해야 한다면 Kernel 클래스의 defineConsoleSchedule() 메서드를 override 하여 아래와 같이 구현해야 한다. protected function defineConsoleSchedule() { $this->app->instance( 'Illuminate\Console\Scheduling\Schedule', $schedule = ScheduleHelper::get() ); $this->schedule($schedule); } new Schedule($this->app[Cache::class]) 대신에 ScheduleHelper::get()에서 인스턴스를 받아서 사용한다. use Illuminate\Console\Scheduling\Schedule; use Illuminate\Contracts\Cache\Repository as Cache; class ScheduleHelper { /** @var Schedule */ private static $scheduleInstance = null; /** * @return Schedule */ static public function &get() { if (empty(static::$scheduleInstance)) { static::$scheduleInstance = new Schedule(app(Cache::class)); } return static::$scheduleInstance; } } ScheduleHelper에서는 schedule 인스턴스를 싱글톤으로 반환한다. use Illuminate\Support\ServiceProvider; use Illuminate\Console\Scheduling\Schedule; class ScheduleServiceProvider extends ServiceProvider { public function boot() { $schedule = ScheduleHelper::get(); $schedule->command('some:command')->everyMinute(); } public function register() { } } Provider 에서는 ScheduleHelper::get()를 이용해서 schedule 인스턴스를 받아 schedule을 추가 한다. 위 방법은 lumen 프로젝트와 package 간의 종속 관계가 생기므로 권장할만한 방법은 아니다. 다만, 나의 경우는 lumen 프로젝트 개설시 기본적으로 직접 개발한 package를 사용하고 해당 package에서 기본 제어를 하도록 되어 있기 때문에 위 방법이 유용하게 사용될 수 있다(사실 대부분의 개발자들의 의견은 lumen은 간단한 프로젝트에서만 사용하고 다소 복잡해질 수 있는 프로젝트는 그냥 laravel을 쓰라는 것이다).]]></summary><content type="html"><![CDATA[<p><a href="https://laravel.com">laravel</a>을 사용하는 프로젝트에서 schedule 처리는 <a href="https://laravel.com/docs/5.4/scheduling">Task Scheduling</a>에 안내되어 있는 것처럼 <code>\App\Console\Kernel</code>의 <code>schedule(Schedule $schedule)</code> 메서드 내에서 정의해서 사용한다.</p>
<p>laravel 기반 프로젝트에 추가한 package(module)에서 직접 schedule을 추가하고 싶다면 어떻게 해야 할까? 이 부분에 대해서는 메뉴얼 상에 안내된 내용이 없다. 하지만 &quot;<a href="http://stackoverflow.com/a/36630136">How to schedule Artisan commands in a package?</a>&quot; 글을 참고하면 아래와 같이 처리할 수 있다.</p>
<pre class="hljs php"><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">ServiceProvider</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Console</span>\<span class="hljs-title">Scheduling</span>\<span class="hljs-title">Schedule</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleServiceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceProvider</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boot</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-variable">$this</span>-&gt;app-&gt;booted(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-variable">$schedule</span> = <span class="hljs-variable">$this</span>-&gt;app-&gt;make(Schedule::class);
            <span class="hljs-variable">$schedule</span>-&gt;command(<span class="hljs-string">'some:command'</span>)-&gt;everyMinute();
        });
    }

    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">()</span>
    </span>{
    }
}</pre>
<p>Application Class의 <code>booted($callback)</code> 함수를 사용해서 schedule을 추가하는 것이다.</p>
<hr />
<p>그런데 이 <code>booted</code> 함수가 <a href="https://lumen.laravel.com/">lumen</a>에서는 존재하지 않는다. <code>booted</code> 함수가 없는 것이 문제가 되는 이유는 schedule 개체를 만드는 Kernel Class의 <code>defineConsoleSchedule()</code> 메서드가 아래와 같이 구현되어 있으며 이 메서드는 Provider가 구성된 이후에 실행 되므로 <code>$schedule</code> 개체에 추가적인 schedule을 추가할 수 있는 진입 지점이 없다.</p>
<pre class="hljs php"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineConsoleSchedule</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-variable">$this</span>-&gt;app-&gt;instance(
      <span class="hljs-string">'Illuminate\Console\Scheduling\Schedule'</span>, <span class="hljs-variable">$schedule</span> = <span class="hljs-keyword">new</span> Schedule(<span class="hljs-variable">$this</span>-&gt;app[Cache::class])
  );

  <span class="hljs-variable">$this</span>-&gt;schedule(<span class="hljs-variable">$schedule</span>);
}</pre>
<p>따라서 lumen 프로젝트에서는 package 내부에서 직접적으로 schedule을 추가하는 것은 불가능해 보인다. 굳이 해야 한다면 Kernel 클래스의 <code>defineConsoleSchedule()</code> 메서드를 override 하여 아래와 같이 구현해야 한다.</p>
<pre class="hljs php"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineConsoleSchedule</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-variable">$this</span>-&gt;app-&gt;instance(
    <span class="hljs-string">'Illuminate\Console\Scheduling\Schedule'</span>, <span class="hljs-variable">$schedule</span> = ScheduleHelper::get()
  );

  <span class="hljs-variable">$this</span>-&gt;schedule(<span class="hljs-variable">$schedule</span>);
}</pre>
<p><code>new Schedule($this-&gt;app[Cache::class])</code> 대신에 <code>ScheduleHelper::get()</code>에서 인스턴스를 받아서 사용한다.</p>
<pre class="hljs php"><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Console</span>\<span class="hljs-title">Scheduling</span>\<span class="hljs-title">Schedule</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Contracts</span>\<span class="hljs-title">Cache</span>\<span class="hljs-title">Repository</span> <span class="hljs-title">as</span> <span class="hljs-title">Cache</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleHelper</span>
</span>{
    <span class="hljs-comment">/** <span class="hljs-doctag">@var</span> Schedule */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-variable">$scheduleInstance</span> = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@return</span> Schedule
     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> &amp;<span class="hljs-title">get</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>(<span class="hljs-keyword">static</span>::<span class="hljs-variable">$scheduleInstance</span>)) {
            <span class="hljs-keyword">static</span>::<span class="hljs-variable">$scheduleInstance</span> = <span class="hljs-keyword">new</span> Schedule(app(Cache::class));
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static</span>::<span class="hljs-variable">$scheduleInstance</span>;
    }
}</pre>
<p><code>ScheduleHelper</code>에서는 schedule 인스턴스를 싱글톤으로 반환한다.</p>
<pre class="hljs php"><span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Support</span>\<span class="hljs-title">ServiceProvider</span>;
<span class="hljs-keyword">use</span> <span class="hljs-title">Illuminate</span>\<span class="hljs-title">Console</span>\<span class="hljs-title">Scheduling</span>\<span class="hljs-title">Schedule</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduleServiceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceProvider</span>
</span>{
  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boot</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-variable">$schedule</span> = ScheduleHelper::get();
    <span class="hljs-variable">$schedule</span>-&gt;command(<span class="hljs-string">'some:command'</span>)-&gt;everyMinute();
  }

  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">()</span>
  </span>{
  }
}</pre>
<p>Provider 에서는 <code>ScheduleHelper::get()</code>를 이용해서 schedule 인스턴스를 받아 schedule을 추가 한다.</p>
<hr />
<p>위 방법은 lumen 프로젝트와 package 간의 종속 관계가 생기므로 권장할만한 방법은 아니다. 다만, 나의 경우는 lumen 프로젝트 개설시 기본적으로 직접 개발한 package를 사용하고 해당 package에서 기본 제어를 하도록 되어 있기 때문에 위 방법이 유용하게 사용될 수 있다(사실 대부분의 개발자들의 의견은 lumen은 간단한 프로젝트에서만 사용하고 다소 복잡해질 수 있는 프로젝트는 그냥 laravel을 쓰라는 것이다).</p>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/03/08/laravel-log-files-permisson-change/</id><title type="html">라라벨(laravel) log 파일 권한 변경</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/03/08/laravel-log-files-permisson-change/"/><published>2017-03-08T10:37:02+09:00</published><updated>2017-03-08T10:37:02+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><category term="laravel" label="laravel" /><summary><![CDATA[laravel 에서는 기본적으로 오류 로그를 "storage/logs"에 저장한다. 별다른 설정이 없다면 해당 경로에 실행 프로세스의 권한으로 로그 파일이 저장되는데 이것이 문제가 되는 경우가 있다. 예를들어 web server는 nobody 권한을 사용하고 crontab의 경우 root를 사용한다고 가정하다. crontab에 의해서 실행된 laravel 프로세스에서 오류가 발생하여 로그 파일이 생성 되었다면 이 파일의 권한은 기본적으로 root permission 에 644(-rw-r--r--)로 저장된다(서버 설정에 따라 다소 다를 수 있음). 이 상태에서 web server에서 실행한 프로세스에서 오류가 발생한다면 로그 파일에 접근할 권한이 없어 파일 저장 오류가 발생한다. 이 문제를 권한 변경없이 해결 할 수 있는 방법은 다음과 같다. <?php $app->configureMonologUsing(function(Monolog\Logger $monolog) { $filename = storage_path('/logs/laravel-' . php_sapi_name() . '.log'); $handler = new Monolog\Handler\RotatingFileHandler($filename, 5); $monolog->pushHandler($handler); }); 위 내용을 bootstrap이나 Provider에 추가한다. 이 방법은 php_sapi_name() 함수를 사용해서 인터페이스 형식을 로그 파일명에 추가함으로써 shell과 web의 로그 파일을 분리하는 것이다(권한 문제와는 상관없지만 RotatingFileHandler의 두번째 인자로 5가 추가되어 일단위로 5개의 파일까지 로그를 분할 저장하도록 되어있다). 일반적인 경우라면 이 정도로 문제는 모두 해결된다. 그리고 대부분 권한을 변경하기 보다는 위 방법을 권장한다. 하지만 다음의 경우를 생각해보자. crontab은 root에서 실행되나 작업 또는 테스트 등의 이유로 root가 아닌 사용자 계정의 shell에서 laravel 프로세스를 실행하는 경우 이미 root에 의해 로그 파일이 이미 생성되었다면 위 방법으로는 완전히 해결되지 않는다. 이러한 경우라면 아래와 같이 직접 permisson을 변경하는 방법도 가능하다. <?php $app->configureMonologUsing(function(Monolog\Logger $monolog) { $filename = storage_path('/logs/laravel-' . php_sapi_name() . '.log'); $handler = new Monolog\Handler\RotatingFileHandler($filename, 5, \Monolog\Logger::DEBUG, true, 0666); $monolog->pushHandler($handler); }); RotatingFileHandler에 추가 인자를 넘겨주어 로그 파일의 권한을 666(-rw-rw-rw-)으로 주도록 변경한 것이다. 혹 로그 파일의 수를 줄이고 싶거나 shell과 web의 로그가 분리되는 것이 싫다면 $filename 부분에서 php_sapi_name()를 제거하면 된다.]]></summary><content type="html"><![CDATA[<p><a href="https://laravel.com/">laravel</a> 에서는 기본적으로 오류 로그를 &quot;storage/logs&quot;에 저장한다. 별다른 설정이 없다면 해당 경로에 실행 프로세스의 권한으로 로그 파일이 저장되는데 이것이 문제가 되는 경우가 있다.</p>
<p>예를들어 web server는 nobody 권한을 사용하고 crontab의 경우 root를 사용한다고 가정하다. crontab에 의해서 실행된 laravel 프로세스에서 오류가 발생하여 로그 파일이 생성 되었다면 이 파일의 권한은 기본적으로 root permission 에 <code>644(-rw-r--r--)</code>로 저장된다(서버 설정에 따라 다소 다를 수 있음). 이 상태에서 web server에서 실행한 프로세스에서 오류가 발생한다면 로그 파일에 접근할 권한이 없어 파일 저장 오류가 발생한다.</p>
<p>이 문제를 권한 변경없이 해결 할 수 있는 방법은 다음과 같다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$app</span>-&gt;configureMonologUsing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(Monolog\Logger <span class="hljs-variable">$monolog</span>)</span> </span>{
    <span class="hljs-variable">$filename</span> = storage_path(<span class="hljs-string">'/logs/laravel-'</span> . php_sapi_name() . <span class="hljs-string">'.log'</span>);
    <span class="hljs-variable">$handler</span> = <span class="hljs-keyword">new</span> Monolog\Handler\RotatingFileHandler(<span class="hljs-variable">$filename</span>, <span class="hljs-number">5</span>);  
    <span class="hljs-variable">$monolog</span>-&gt;pushHandler(<span class="hljs-variable">$handler</span>);
});</pre>
<p>위 내용을 bootstrap이나 Provider에 추가한다.</p>
<p>이 방법은 <a href="http://php.net/manual/kr/function.php-sapi-name.php">php_sapi_name()</a> 함수를 사용해서 인터페이스 형식을 로그 파일명에 추가함으로써 shell과 web의 로그 파일을 분리하는 것이다(권한 문제와는 상관없지만 RotatingFileHandler의 두번째 인자로 5가 추가되어 일단위로 5개의 파일까지 로그를 분할 저장하도록 되어있다).</p>
<p>일반적인 경우라면 이 정도로 문제는 모두 해결된다. 그리고 대부분 권한을 변경하기 보다는 위 방법을 권장한다. 하지만 다음의 경우를 생각해보자.</p>
<p>crontab은 root에서 실행되나 작업 또는 테스트 등의 이유로 root가 아닌 사용자 계정의 shell에서 laravel 프로세스를 실행하는 경우 이미 root에 의해 로그 파일이 이미 생성되었다면 위 방법으로는 완전히 해결되지 않는다. 이러한 경우라면 아래와 같이 직접 permisson을 변경하는 방법도 가능하다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$app</span>-&gt;configureMonologUsing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(Monolog\Logger <span class="hljs-variable">$monolog</span>)</span> </span>{
    <span class="hljs-variable">$filename</span> = storage_path(<span class="hljs-string">'/logs/laravel-'</span> . php_sapi_name() . <span class="hljs-string">'.log'</span>);
    <span class="hljs-variable">$handler</span> = <span class="hljs-keyword">new</span> Monolog\Handler\RotatingFileHandler(<span class="hljs-variable">$filename</span>, <span class="hljs-number">5</span>, \Monolog\Logger::DEBUG, <span class="hljs-keyword">true</span>, <span class="hljs-number">0666</span>);  
    <span class="hljs-variable">$monolog</span>-&gt;pushHandler(<span class="hljs-variable">$handler</span>);
});</pre>
<p>RotatingFileHandler에 추가 인자를 넘겨주어 로그 파일의 권한을 <code>666(-rw-rw-rw-)</code>으로 주도록 변경한 것이다.</p>
<p>혹 로그 파일의 수를 줄이고 싶거나 shell과 web의 로그가 분리되는 것이 싫다면 <code>$filename</code> 부분에서 <code>php_sapi_name()</code>를 제거하면 된다.</p>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/02/15/named-backreferences-with-preg-replace/</id><title type="html">preg_replace()의 치환 문자열에서 이름이 지정된 서브 패턴의 역 참조 사용하기</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/02/15/named-backreferences-with-preg-replace/"/><published>2017-02-15T15:36:32+09:00</published><updated>2017-02-15T15:36:32+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[preg_replace()는 이름이 지정된 서브 패턴에 대한 역 참조(named backreferences)를 지원하지 않는다. 일단 일반적인 역 참조를 사용하는 방법에 대한 예시를 보자. <?php $string = 'user/foo'; echo preg_replace('/^user\\/(?P<id>[^\\/]+)$/', 'user/profile/\\1', $string); // user/profile/foo 위의 예시에서 치환 문자열의 \\1 대신에 패턴에서 지정된 이름("id")을 사용하고자 한다고 가정하자. <?php $string = 'user/foo'; echo preg_replace('/^user\\/(?P<id>[^\\/]+)$/', 'user/profile/\\id', $string); user/profile/\id 결과에서 보듯이 역 참조는 패턴에서 지정된 이름으로는 사용할 수 없다. 이런 경우라면 아래와 같이 preg_replace_callback()을 사용해야 한다. $string = 'user/foo'; echo preg_replace_callback('/^user\\/(?P<id>[^\\/]+)$/', function ($matches) { return 'user/profile/' . $matches['id']; }, $string) . "\n"; // user/profile/foo 위 예시를 봤을 때는 "굳이 복잡하게 서브 패턴에 이름을 지정해서 사용해야 하는가?" 하는 의문이 들겠지만 정규식이 복잡해 진다면 명시적으로 이름을 붙여서 사용하는 것이 유지 보수와 코드를 읽는데 도움이 된다. 서브 패턴과 역 참조에 대한 자세한 내용은 아래의 글을 참고하자. PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)]]></summary><content type="html"><![CDATA[<p><a href="http://php.net/manual/kr/function.preg-replace.php">preg_replace()</a>는 이름이 지정된 <a href="/2017/01/17/php-regex-subpatterns/">서브 패턴</a>에 대한 <a href="/2017/01/19/php-regex-back-references/">역 참조</a>(named backreferences)를 지원하지 않는다.</p>
<p>일단 일반적인 역 참조를 사용하는 방법에 대한 예시를 보자.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'user/foo'</span>;
<span class="hljs-keyword">echo</span> preg_replace(<span class="hljs-string">'/^user\\/(?P&lt;id&gt;[^\\/]+)$/'</span>, <span class="hljs-string">'user/profile/\\1'</span>, <span class="hljs-variable">$string</span>);

<span class="hljs-comment">// user/profile/foo</span></pre>
<p>위의 예시에서 치환 문자열의 <code>\\1</code> 대신에 패턴에서 지정된 이름(&quot;id&quot;)을 사용하고자 한다고 가정하자.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">'user/foo'</span>;
<span class="hljs-keyword">echo</span> preg_replace(<span class="hljs-string">'/^user\\/(?P&lt;id&gt;[^\\/]+)$/'</span>, <span class="hljs-string">'user/profile/\\id'</span>, <span class="hljs-variable">$string</span>);

user/profile/\id</pre>
<p>결과에서 보듯이 역 참조는 패턴에서 지정된 이름으로는 사용할 수 없다. 이런 경우라면 아래와 같이 <a href="http://php.net/manual/kr/function.preg-replace-callback.php">preg_replace_callback()</a>을 사용해야 한다.</p>
<pre class="hljs php"><span class="hljs-variable">$string</span> = <span class="hljs-string">'user/foo'</span>;
<span class="hljs-keyword">echo</span> preg_replace_callback(<span class="hljs-string">'/^user\\/(?P&lt;id&gt;[^\\/]+)$/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-variable">$matches</span>)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'user/profile/'</span> . <span class="hljs-variable">$matches</span>[<span class="hljs-string">'id'</span>];
    }, <span class="hljs-variable">$string</span>) . <span class="hljs-string">"\n"</span>;

<span class="hljs-comment">// user/profile/foo</span></pre>
<p>위 예시를 봤을 때는 &quot;굳이 복잡하게 서브 패턴에 이름을 지정해서 사용해야 하는가?&quot; 하는 의문이 들겠지만 정규식이 복잡해 진다면 명시적으로 이름을 붙여서 사용하는 것이 유지 보수와 코드를 읽는데 도움이 된다.</p>
<p>서브 패턴과 역 참조에 대한 자세한 내용은 아래의 글을 참고하자.</p>
<ul>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/02/06/difference-between-bindparam-and-bindvalue-in-php-pdo/</id><title type="html">PHP PDO의 bindParam와 bindValue의 차이</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/02/06/difference-between-bindparam-and-bindvalue-in-php-pdo/"/><published>2017-02-06T14:18:01+09:00</published><updated>2017-02-06T14:18:01+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[PDO(PHP Data Objects)에서 Prepared statements 사용시 값을 bind하기 위해 PDOStatement::bindParam 또는 PDOStatement::bindValue를 주로 사용한다. 두개의 함수는 사용법이 거의 유사해서 어떤 차이가 있는지 알아둘 필요가 있다. 아래의 예시를 보면 정확한 차이를 바로 알 수 있다. <?php $sex = 'male'; $s = $dbh->prepare('SELECT name FROM students WHERE sex = :sex'); $s->bindParam(':sex', $sex); // use bindParam to bind the variable $sex = 'female'; $s->execute(); // executed with WHERE sex = 'female' <?php $sex = 'male'; $s = $dbh->prepare('SELECT name FROM students WHERE sex = :sex'); $s->bindValue(':sex', $sex); // use bindValue to bind the variable's value $sex = 'female'; $s->execute(); // executed with WHERE sex = 'male' 결론은 PDOStatement::bindParam는 변수의 레퍼런스로 바인딩 되므로 PDOStatement::execute가 호출될 때 값이 반영된다.]]></summary><content type="html"><![CDATA[<p><a href="http://php.net/manual/en/book.pdo.php">PDO(PHP Data Objects)</a>에서 Prepared statements 사용시 값을 bind하기 위해  <a href="http://php.net/manual/en/pdostatement.bindparam.php">PDOStatement::bindParam</a> 또는
<a href="http://php.net/manual/en/pdostatement.bindvalue.php">PDOStatement::bindValue</a>를 주로 사용한다. 두개의 함수는 사용법이 거의 유사해서 어떤 차이가 있는지 알아둘 필요가 있다.</p>
<p>아래의 예시를 보면 정확한 차이를 바로 알 수 있다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$sex</span> = <span class="hljs-string">'male'</span>;
<span class="hljs-variable">$s</span> = <span class="hljs-variable">$dbh</span>-&gt;prepare(<span class="hljs-string">'SELECT name FROM students WHERE sex = :sex'</span>);
<span class="hljs-variable">$s</span>-&gt;bindParam(<span class="hljs-string">':sex'</span>, <span class="hljs-variable">$sex</span>); <span class="hljs-comment">// use bindParam to bind the variable</span>
<span class="hljs-variable">$sex</span> = <span class="hljs-string">'female'</span>;
<span class="hljs-variable">$s</span>-&gt;execute(); <span class="hljs-comment">// executed with WHERE sex = 'female'</span></pre>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$sex</span> = <span class="hljs-string">'male'</span>;
<span class="hljs-variable">$s</span> = <span class="hljs-variable">$dbh</span>-&gt;prepare(<span class="hljs-string">'SELECT name FROM students WHERE sex = :sex'</span>);
<span class="hljs-variable">$s</span>-&gt;bindValue(<span class="hljs-string">':sex'</span>, <span class="hljs-variable">$sex</span>); <span class="hljs-comment">// use bindValue to bind the variable's value</span>
<span class="hljs-variable">$sex</span> = <span class="hljs-string">'female'</span>;
<span class="hljs-variable">$s</span>-&gt;execute(); <span class="hljs-comment">// executed with WHERE sex = 'male'</span></pre>
<p>결론은 <a href="http://php.net/manual/en/pdostatement.bindparam.php">PDOStatement::bindParam</a>는 변수의 레퍼런스로 바인딩 되므로 <a href="http://php.net/manual/kr/pdostatement.execute.php">PDOStatement::execute</a>가 호출될 때 값이 반영된다.</p>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/25/php-regex-epilogue/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 에필로그</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/25/php-regex-epilogue/"/><published>2017-01-25T11:45:13+09:00</published><updated>2017-01-25T11:45:13+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[앞선 글들에서 PCRE에 대한 전반적인 내용을 소개 했다. 일부는 내용이 이해하기 어려울 수 있다. 나름 이해가 어려운 부분은 예시를 추가해서 이해를 돕고자 했으나 부족할 것으로 보인다. PCRE를 익히는 가장 좋은 방법은 직접 패턴을 만들어 보면서 학습하는 것이다. PCRE에 대한 소개를 마치며 학습 및 활용에 도움이 될 수 있는 몇가지 사이트와 예시들을 남겨둔다. 정규식을 웹 상에서 테스트해 볼 수 있는 사이트를 소개한다(검색해보면 더 많은 사이트들이 존재하니 자신에게 맞는 사이트를 사용하면 된다). regular xpressions 101 : PHP, PCRE, Python, Golang, JavaScript 정규식을 테스트 할 수 있다. 그리고 입력한 정규식 패턴에 대한 설명과 매칭 결과를 상세히 보여줘서 상당히 유용하다. PHP Live Regex : PHP 정규식(PCRE)만 지원하지만 preg_match, preg_replace 등의 함수 등의 실행 결과를 바로 확인 할 수 있어 편리하다. REGEXPER : 정규식을 Railroad Diagrams으로 보여준다. 단, PCRE와 완전히 호환되지 않기 때문에 PCRE 문법이 포함된 정규식은 오류가 난다. 다음은 정규식 사용 예시를 몇가지 남겨둔다. 웹 상에서 공개되어 있는 예시들도 있고 직접 만들어 사용했던 정규식도 포함되어 있다. 유니코드 공백 문자들을 일반 공백 문자(0x20)로 치환 <?php $result = trim(preg_replace('/[\\pZ\\pC]+/u', ' ', $str)); 이와 관련된 유사한 내용은 htmlspecialchars_decode와 html_entity_decode의 문자열 처리의 다른 점을 참고하자. 한글 추출 / 제외 <?php // http://phpschool.com/link/tipntech/77239 $text = '!@#$%^&*()_+ 가나다라 1234567890 abcdefgh'; echo preg_replace('/\p{Hangul}/u', '', $text) . "\n"; // 한글 제외 echo preg_replace('/\P{Hangul}/u', '', $text) . "\n"; // 한글만 남김 // !@#$%^&*()_+ 1234567890 abcdefgh // 가나다라 // 한글 범위 // [\x{ac00}-\x{d7a3}] 가-힣 // [\x{3131}-\x{314e}] ㄱ-ㅎ // [\x{314f}-\x{3163}] ㅏ-ㅣ // 무슨 문자가 더 있나 찍어보기 // for($i = 0x31; $i < 0xff; $i ++) { // echo iconv('UCS-2BE', 'UTF-8', pack('H*', '31'.strtolower(dechex($i)))); // } 대상 내에서 문자열로 정의된 영역을 추출하는 예시 <?php $string = <<<STR \$a = "123test-string"; "test-string\"test-string" 'test-string"test-string\'test-string' 'test-string" test-string\'test-string' sample "" '"' '' STR; $regex = '/(?P<string>(["\'])(?s:(?=(\\\\?))\g{-1}.)*?\g{-2})/'; preg_match_all($regex, $string, $matches); print_r($matches['string']); 위 예시를 응용해서 html에서 이미지 url만 추출하는 예시다. <?php $string = <<<STR <img src="test url" /> <img alt="ver" src="http://test/\"'url" /> <img alt="v\"er" src="test url" /> STR; $regex = '/<img\s+[^>]*src\s*=\s*(?P<images>(["\'])(?s:(?=(\\\\?))\g{-1}.)*?\g{-2})/'; preg_match_all($regex, $string, $matches); print_r($matches['images']); 더 간단히 아래와 같이 해도 상관없다(url 내에 ' 또는 " 가 나올 수 없으므로). <?php preg_match_all('/<img\s+[^>]*src\s*=\s*[\'"]([^\'"]+)[\'"][^>]*>/', $string, $matches); 기타 간단한 정규식 이하 내용은 예시로 웹 상에 공개된 정규식들로 검증을 거치지 않았으니 참고만 하자. 숫자만 체크 정규식 /^[0-9]+$/ 이메일 체크 정규식 /^[0-9A-Z]([-_\.]?[0-9A-Z])*@[0-9A-Z]([-_\.]?[0-9A-Z])*\.[A-Z]{2,20}$/i 전화번호 정규식 /^\d{3}-\d{3,4}-\d{4}$/ : 휴대전화 /^01([0|1|6|7|8|9]?)-?([0-9]{3,4})-?([0-9]{4})$/ : 휴대전화 /^\d{2,3}-\d{3,4}-\d{4}$/ : 일반 전화번호 아이디나 비밀번호 정규식 /^[a-z0-9_]{4,20}$/ : 4자 이상 20자 이하 영소문자/숫자/_ 허용 태그(#) / 맨션(@) 추출 /(?:@|#)[^\s\t\n\r]+/ : @나 #으로 시작되는 문자열 추출 PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 마침표(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 선택(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) > PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<p>앞선 글들에서 PCRE에 대한 전반적인 내용을 소개 했다. 일부는 내용이 이해하기 어려울 수 있다. 나름 이해가 어려운 부분은 예시를 추가해서 이해를 돕고자 했으나 부족할 것으로 보인다. PCRE를 익히는 가장 좋은 방법은 직접 패턴을 만들어 보면서 학습하는 것이다.</p>
<p>PCRE에 대한 소개를 마치며 학습 및 활용에 도움이 될 수 있는 몇가지 사이트와 예시들을 남겨둔다.</p>
<hr />
<p>정규식을 웹 상에서 테스트해 볼 수 있는 사이트를 소개한다(검색해보면 더 많은 사이트들이 존재하니 자신에게 맞는 사이트를 사용하면 된다).</p>
<ul>
<li><a href="https://regex101.com/">regular xpressions 101</a> : PHP, PCRE, Python, Golang, JavaScript 정규식을 테스트 할 수 있다. 그리고 입력한 정규식 패턴에 대한 설명과 매칭 결과를 상세히 보여줘서 상당히 유용하다.</li>
<li><a href="http://www.phpliveregex.com/">PHP Live Regex</a> : PHP 정규식(PCRE)만 지원하지만 preg_match, preg_replace 등의 함수 등의 실행 결과를 바로 확인 할 수 있어 편리하다.</li>
<li><a href="https://regexper.com/">REGEXPER</a> : 정규식을 <a href="http://tiddlywiki.com/languages/ko-KR/static/Railroad%2520Diagrams.html">Railroad Diagrams</a>으로 보여준다. 단, PCRE와 완전히 호환되지 않기 때문에 PCRE 문법이 포함된 정규식은 오류가 난다.</li>
</ul>
<hr />
<p>다음은 정규식 사용 예시를 몇가지 남겨둔다. 웹 상에서 공개되어 있는 예시들도 있고 직접 만들어 사용했던 정규식도 포함되어 있다.</p>
<h4>유니코드 공백 문자들을 일반 공백 문자(0x20)로 치환</h4>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$result</span> = trim(preg_replace(<span class="hljs-string">'/[\\pZ\\pC]+/u'</span>, <span class="hljs-string">' '</span>, <span class="hljs-variable">$str</span>));</pre>
<p>이와 관련된 유사한 내용은 <a href="/2015/09/10/htmlspecialchars-decode-html-entity-decode-spaces/">htmlspecialchars_decode와 html_entity_decode의 문자열 처리의 다른 점</a>을 참고하자.</p>
<h3>한글 추출 / 제외</h3>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-comment">// http://phpschool.com/link/tipntech/77239</span>
<span class="hljs-variable">$text</span> = <span class="hljs-string">'!@#$%^&amp;*()_+ 가나다라 1234567890 abcdefgh'</span>;
<span class="hljs-keyword">echo</span> preg_replace(<span class="hljs-string">'/\p{Hangul}/u'</span>, <span class="hljs-string">''</span>, <span class="hljs-variable">$text</span>) . <span class="hljs-string">"\n"</span>;   <span class="hljs-comment">// 한글 제외</span>
<span class="hljs-keyword">echo</span> preg_replace(<span class="hljs-string">'/\P{Hangul}/u'</span>, <span class="hljs-string">''</span>, <span class="hljs-variable">$text</span>) . <span class="hljs-string">"\n"</span>;   <span class="hljs-comment">// 한글만 남김</span>

<span class="hljs-comment">// !@#$%^&amp;*()_+  1234567890 abcdefgh</span>
<span class="hljs-comment">// 가나다라</span>

<span class="hljs-comment">// 한글 범위</span>
<span class="hljs-comment">// [\x{ac00}-\x{d7a3}] 가-힣</span>
<span class="hljs-comment">// [\x{3131}-\x{314e}] ㄱ-ㅎ</span>
<span class="hljs-comment">// [\x{314f}-\x{3163}] ㅏ-ㅣ</span>

<span class="hljs-comment">// 무슨 문자가 더 있나 찍어보기</span>
<span class="hljs-comment">// for($i = 0x31; $i &lt; 0xff; $i ++) {</span>
<span class="hljs-comment">//     echo iconv('UCS-2BE', 'UTF-8', pack('H*', '31'.strtolower(dechex($i))));</span>
<span class="hljs-comment">// }</span></pre>
<h4>대상 내에서 문자열로 정의된 영역을 추출하는 예시</h4>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">&lt;&lt;&lt;STR
\$a = "123test-string";
"test-string\"test-string"
'test-string"test-string\'test-string'

'test-string"
        test-string\'test-string'

sample</span>

<span class="hljs-string">""</span>
<span class="hljs-string">'"'</span>
<span class="hljs-string">''</span>
STR;

<span class="hljs-variable">$regex</span> = <span class="hljs-string">'/(?P&lt;string&gt;(["\'])(?s:(?=(\\\\?))\g{-1}.)*?\g{-2})/'</span>;
preg_match_all(<span class="hljs-variable">$regex</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>[<span class="hljs-string">'string'</span>]);</pre>
<h4>위 예시를 응용해서 html에서 이미지 url만 추출하는 예시다.</h4>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$string</span> = <span class="hljs-string">&lt;&lt;&lt;STR
&lt;img src="test url" /&gt;
&lt;img alt="ver" src="http://test/\"'url" /&gt;
&lt;img alt="v\"er" src="test url" /&gt;
STR;</span>

<span class="hljs-variable">$regex</span> = <span class="hljs-string">'/&lt;img\s+[^&gt;]*src\s*=\s*(?P&lt;images&gt;(["\'])(?s:(?=(\\\\?))\g{-1}.)*?\g{-2})/'</span>;
preg_match_all(<span class="hljs-variable">$regex</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>[<span class="hljs-string">'images'</span>]);</pre>
<p>더 간단히 아래와 같이 해도 상관없다(url 내에 ' 또는 &quot; 가 나올 수 없으므로).</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
preg_match_all(<span class="hljs-string">'/&lt;img\s+[^&gt;]*src\s*=\s*[\'"]([^\'"]+)[\'"][^&gt;]*&gt;/'</span>, <span class="hljs-variable">$string</span>, <span class="hljs-variable">$matches</span>);</pre>
<h4>기타 간단한 정규식</h4>
<p>이하 내용은 예시로 웹 상에 공개된 정규식들로 검증을 거치지 않았으니 참고만 하자.</p>
<ul>
<li>
<p>숫자만 체크 정규식</p>
<ul>
<li><code>/^[0-9]+$/</code></li>
</ul>
</li>
<li>
<p>이메일 체크 정규식</p>
<ul>
<li><code>/^[0-9A-Z]([-_\.]?[0-9A-Z])*@[0-9A-Z]([-_\.]?[0-9A-Z])*\.[A-Z]{2,20}$/i</code></li>
</ul>
</li>
<li>
<p>전화번호 정규식</p>
<ul>
<li><code>/^\d{3}-\d{3,4}-\d{4}$/</code> : 휴대전화</li>
<li><code>/^01([0|1|6|7|8|9]?)-?([0-9]{3,4})-?([0-9]{4})$/</code> : 휴대전화</li>
<li><code>/^\d{2,3}-\d{3,4}-\d{4}$/</code> : 일반 전화번호</li>
</ul>
</li>
<li>
<p>아이디나 비밀번호 정규식</p>
<ul>
<li><code>/^[a-z0-9_]{4,20}$/</code> : 4자 이상 20자 이하 영소문자/숫자/_ 허용</li>
</ul>
</li>
<li>태그(#) / 맨션(@) 추출
<ul>
<li><code>/(?:@|#)[^\s\t\n\r]+/</code> : <code>@</code>나 <code>#</code>으로 시작되는 문자열 추출</li>
</ul></li>
</ul>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 마침표(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 선택(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 에필로그</strong></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/24/php-regex-recursive-patterns/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/24/php-regex-recursive-patterns/"/><published>2017-01-24T11:22:11+09:00</published><updated>2017-01-24T11:22:11+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Recursive patterns (재귀 패턴) 무한대의 중첩 괄호를 허용하면서 괄호 안의 문자열을 일치시키는 문제를 고려해 보자. 재귀를 사용하지 않고 수행 할 수 있는 최상의 방법은 중첩의 고정된 깊이까지 일치하는 패턴을 사용하는 것이다. 임의의 중첩 깊이는 처리 할 수 ​​없다. Perl 5.6은 정규식을 반복 할 수 있는 실험적 기능을 제공한다. 특수 항목 (?R)은 재귀의 특정 경우에 대해 제공된다. \( ( (?>[^()]+) | (?R) )* \) 이 PCRE 패턴은 괄호 문제를 해결한다(공백을 무시하도록 PCRE_EXTENDED 옵션이 설정되어 있다고 가정한다). 먼저 여는 괄호와 일치한다. 그런 다음 괄호가 아닌 시퀀스 또는 패턴 자체의 재귀 일치 (예 : 올바르게 괄호로 묶은 부분 문자열)가 될 수 있는 임의의 수의 하위 문자열을 찾는다. 마지막으로 닫는 괄호가 있다. 이 특정 예제 패턴에는 중첩된 무제한 반복이 포함되어 있으므로 일치하지 않는 문자열에 패턴을 적용 할 때 괄호가 아닌 문자열을 일치 시키는데 한 번만 사용하는 서브 패턴을 사용하는 것이 중요하다. 예를 들어 "(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()"에 적용하면 신속하게 "일치하지 않음"을 나타낸다. 그러나 once-only 서브 패턴이 사용되지 않으면 매우 오랜 시간 동안 검사가 실행된다. + 및 *의 반복은 모든 경우의 수에 대해 실패할 때까지 테스트해야 하기 때문이다. 캡춰 서브 패턴에 설정되는 값은 서브 패턴 값이 설정되어 있는 재귀의 최외각 레벨의 값이다. 위의 패턴이 (ab(cd)ef)와 일치하면 캡처 괄호의 값은 최상위 수준에서 마지막으로 취해진 값인 "ef"이다. 추가 괄호가 추가되면 \( ( ( (?>[^()]+) | (?R) )* ) \) 다음에 캡처하는 문자열은 "ab(cd)ef" 수준 괄호 패턴에 15개 이상의 캡처 괄호가 있는 경우 PCRE는 재귀 중에 데이터를 저장하기 위해 추가 메모리를 확보해야 한다. 재귀는 pcre_malloc을 사용하여 수행 한 후 나중에 pcre_free를 통해 해제 한다. 메모리를 확보 할 수 없으면 재귀 내에서 메모리 부족 오류를 제공 할 방법이 없기 때문에 처음 15개의 캡처링 괄호에 대한 데이터만 저장한다. (?1), (?2) 등은 재귀 서브 패턴에도 사용될 수있다. 또한 이름이 지정된 서브 패턴 (?P>name) 또는 (?P&name)을 사용할 수도 있다. 재귀적 서브 패턴 참조 (숫자 또는 이름 기준)의 구문이 참조되는 괄호 밖에서 사용되면 프로그래밍 언어의 서브 루틴처럼 작동한다. 앞의 예는 패턴 (sens|respons)e and \1ibility가 "sense and sensibility", "response and responsibility"와 일치하지만 "sense and responsibility"와는 일치하지 않는다고 지적했다. 대신에 패턴 (sens|respons)e and (?1)ibility가 사용되면 다른 두 문자열과 마찬가지로 "sense and responsibility"와 일치한다. 그러나 이러한 참조는 참조하는 서브 패턴을 따라야 한다. 문자열의 최대 길이는 정수 변수가 가질 수 있는 최대 양수이다. 그러나 PCRE는 재귀를 사용하여 서브 패턴과 무한 반복을 처리한다. 이는 사용 가능한 스택 공간이 특정 패턴으로 처리 할 수 있는 제목 문자열의 크기를 제한 할 수 있음을 의미한다. 아래의 예시는 주어진 문장이 회문(palindrome)인지를 판별하는 정규식 예시이다. <?php $strs = ["saippuakauppias", "A man, a plan, a canal: Panama!"]; foreach ($strs as $str) { if (preg_match('/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix', $str)) { printf("'%s' is a palindrome\n", $str); } else { printf("'%s' is not a palindrome\n", $str); } } // 'saippuakauppias' is a palindrome // 'A man, a plan, a canal: Panama!' is a palindrome 다음의 예시는 중첩된 balanced text(좌우에 대칭되는 표식에 의해 둘러싸여 있는 text)를 추출하는 정규식에 대한 예시이다. Can I use Perl regular expressions to match balanced text? <?php $str = <<<STR I have some <brackets in <nested brackets> > and <another group <nested once <nested twice> > > and that's it. <div>sfsd</div> STR; $regex = '/ ( (?# 캡처 버퍼 1의 시작) < (?# 여는 부등호에 일치) (?: [^<>]++ (?# 부등호를 제외한 문자들이 반복, 백트래킹하지 않음) | (?1) (?# < 또는 > 발견, 캡처 버퍼 1을 재귀적으로 부름) )* > (?# 닫는 부등호에 일치) ) (?# 캡처 버퍼 1의 끝) /ix'; preg_match_all($regex, $str, $matches); print_r($matches); //Array //( // [0] => Array // ( // [0] => <brackets in <nested brackets> > // [1] => <another group <nested once <nested twice> > > // [2] => <div> // [3] => </div> // ) // [1] => Array // ( // [0] => <brackets in <nested brackets> > // [1] => <another group <nested once <nested twice> > > // [2] => <div> // [3] => </div> // ) //) PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 마침표(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 선택(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) PHP 정규식(PCRE)의 모든 것 - 주석(Comments) > PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.recursive.php">Recursive patterns</a> (재귀 패턴)</h3>
<p>무한대의 중첩 괄호를 허용하면서 괄호 안의 문자열을 일치시키는 문제를 고려해 보자. 재귀를 사용하지 않고 수행 할 수 있는 최상의 방법은 중첩의 고정된 깊이까지 일치하는 패턴을 사용하는 것이다. 임의의 중첩 깊이는 처리 할 수 ​​없다. Perl 5.6은 정규식을 반복 할 수 있는 실험적 기능을 제공한다. 특수 항목 <code>(?R)</code>은 재귀의 특정 경우에 대해 제공된다.</p>
<p><code>\( ( (?&gt;[^()]+) | (?R) )* \)</code></p>
<p>이 PCRE 패턴은 괄호 문제를 해결한다(공백을 무시하도록 <a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션이 설정되어 있다고 가정한다).</p>
<p>먼저 여는 괄호와 일치한다. 그런 다음 괄호가 아닌 시퀀스 또는 패턴 자체의 재귀 일치 (예 : 올바르게 괄호로 묶은 부분 문자열)가 될 수 있는 임의의 수의 하위 문자열을 찾는다. 마지막으로 닫는 괄호가 있다.</p>
<p>이 특정 예제 패턴에는 중첩된 무제한 반복이 포함되어 있으므로 일치하지 않는 문자열에 패턴을 적용 할 때 괄호가 아닌 문자열을 일치 시키는데 한 번만 사용하는 서브 패턴을 사용하는 것이 중요하다. 예를 들어 &quot;(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()&quot;에 적용하면 신속하게 &quot;일치하지 않음&quot;을 나타낸다. 그러나 once-only 서브 패턴이 사용되지 않으면 매우 오랜 시간 동안 검사가 실행된다. <code>+</code> 및 <code>*</code>의 반복은 모든 경우의 수에 대해 실패할 때까지 테스트해야 하기 때문이다.</p>
<p>캡춰 서브 패턴에 설정되는 값은 서브 패턴 값이 설정되어 있는 재귀의 최외각 레벨의 값이다. 위의 패턴이 <code>(ab(cd)ef)</code>와 일치하면 캡처 괄호의 값은 최상위 수준에서 마지막으로 취해진 값인 &quot;ef&quot;이다. 추가 괄호가 추가되면 <code>\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</code> 다음에 캡처하는 문자열은 &quot;ab(cd)ef&quot; 수준 괄호 패턴에 15개 이상의 캡처 괄호가 있는 경우 PCRE는 재귀 중에 데이터를 저장하기 위해 추가 메모리를 확보해야 한다. 재귀는 pcre_malloc을 사용하여 수행 한 후 나중에 pcre_free를 통해 해제 한다. 메모리를 확보 할 수 없으면 재귀 내에서 메모리 부족 오류를 제공 할 방법이 없기 때문에 처음 15개의 캡처링 괄호에 대한 데이터만 저장한다.</p>
<p><code>(?1)</code>, <code>(?2)</code> 등은 재귀 서브 패턴에도 사용될 수있다. 또한 이름이 지정된 서브 패턴 <code>(?P&gt;name)</code> 또는 <code>(?P&amp;name)</code>을 사용할 수도 있다.</p>
<p>재귀적 서브 패턴 참조 (숫자 또는 이름 기준)의 구문이 참조되는 괄호 밖에서 사용되면 프로그래밍 언어의 서브 루틴처럼 작동한다. 앞의 예는 패턴 <code>(sens|respons)e and \1ibility</code>가 &quot;sense and sensibility&quot;, &quot;response and responsibility&quot;와 일치하지만 &quot;sense and responsibility&quot;와는 일치하지 않는다고 지적했다. 대신에 패턴 <code>(sens|respons)e and (?1)ibility</code>가 사용되면 다른 두 문자열과 마찬가지로 &quot;sense and responsibility&quot;와 일치한다. 그러나 이러한 참조는 참조하는 서브 패턴을 따라야 한다.</p>
<p>문자열의 최대 길이는 정수 변수가 가질 수 있는 최대 양수이다. 그러나 PCRE는 재귀를 사용하여 서브 패턴과 무한 반복을 처리한다. 이는 사용 가능한 스택 공간이 특정 패턴으로 처리 할 수 있는 제목 문자열의 크기를 제한 할 수 있음을 의미한다.</p>
<p>아래의 예시는 주어진 문장이 회문(palindrome)인지를 판별하는 정규식 예시이다.</p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$strs</span> = [<span class="hljs-string">"saippuakauppias"</span>, <span class="hljs-string">"A man, a plan, a canal: Panama!"</span>];
<span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$strs</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$str</span>) {
    <span class="hljs-keyword">if</span> (preg_match(<span class="hljs-string">'/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix'</span>, <span class="hljs-variable">$str</span>)) {
        printf(<span class="hljs-string">"'%s' is a palindrome\n"</span>, <span class="hljs-variable">$str</span>);
    } <span class="hljs-keyword">else</span> {
        printf(<span class="hljs-string">"'%s' is not a palindrome\n"</span>, <span class="hljs-variable">$str</span>);
    }
}
<span class="hljs-comment">// 'saippuakauppias' is a palindrome</span>
<span class="hljs-comment">// 'A man, a plan, a canal: Panama!' is a palindrome</span></pre>
<p>다음의 예시는 중첩된 balanced text(좌우에 대칭되는 표식에 의해 둘러싸여 있는 text)를 추출하는 정규식에 대한 예시이다.</p>
<p><a href="http://learn.perl.org/faq/perlfaq6.html#Can-I-use-Perl-regular-expressions-to-match-balanced-text">Can I use Perl regular expressions to match balanced text?</a></p>
<pre class="hljs php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-variable">$str</span> = <span class="hljs-string">&lt;&lt;&lt;STR
I have some &lt;brackets in &lt;nested brackets&gt; &gt; and &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
and that's it.
&lt;div&gt;sfsd&lt;/div&gt;
STR;</span>

<span class="hljs-variable">$regex</span> = <span class="hljs-string">'/
        (                   (?# 캡처 버퍼 1의 시작)
        &lt;                   (?# 여는 부등호에 일치)
            (?:
                [^&lt;&gt;]++     (?# 부등호를 제외한 문자들이 반복, 백트래킹하지 않음)
                  |
                (?1)        (?# &lt; 또는 &gt; 발견, 캡처 버퍼 1을 재귀적으로 부름)
            )*
        &gt;                   (?# 닫는 부등호에 일치)
        )                   (?# 캡처 버퍼 1의 끝)
        /ix'</span>;
preg_match_all(<span class="hljs-variable">$regex</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$matches</span>);
print_r(<span class="hljs-variable">$matches</span>);

<span class="hljs-comment">//Array</span>
<span class="hljs-comment">//(</span>
<span class="hljs-comment">//  [0] =&gt; Array</span>
<span class="hljs-comment">//      (</span>
<span class="hljs-comment">//          [0] =&gt; &lt;brackets in &lt;nested brackets&gt; &gt;</span>
<span class="hljs-comment">//            [1] =&gt; &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;</span>
<span class="hljs-comment">//            [2] =&gt; &lt;div&gt;</span>
<span class="hljs-comment">//          [3] =&gt; &lt;/div&gt;</span>
<span class="hljs-comment">//      )</span>
<span class="hljs-comment">//    [1] =&gt; Array</span>
<span class="hljs-comment">//      (</span>
<span class="hljs-comment">//          [0] =&gt; &lt;brackets in &lt;nested brackets&gt; &gt;</span>
<span class="hljs-comment">//            [1] =&gt; &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;</span>
<span class="hljs-comment">//            [2] =&gt; &lt;div&gt;</span>
<span class="hljs-comment">//          [3] =&gt; &lt;/div&gt;</span>
<span class="hljs-comment">//      )</span>
<span class="hljs-comment">//)</span>
</pre>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 마침표(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 선택(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li><a href="/2017/01/23/php-regex-comments/">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</strong></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>
<entry><id>https://blog.asamaru.net/2017/01/23/php-regex-comments/</id><title type="html">PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</title><link rel="alternate" type="text/html" href="https://blog.asamaru.net/2017/01/23/php-regex-comments/"/><published>2017-01-23T14:12:12+09:00</published><updated>2017-01-23T14:12:12+09:00</updated><author><name>유영재</name><uri>https://blog.asamaru.net/</uri><email>asamaru@asamaru.net</email></author><category term="php" label="php" /><summary><![CDATA[Comments (주석) 시퀀스 (?#는 다음 닫는 괄호까지 이어지는 주석의 시작을 표시한다. 중첩된 괄호는 허용되지 않으며 주석을 구성하는 문자는 패턴 일치에 전혀 영향을 미치지 않는다. PCRE_EXTENDED 옵션을 설정하면 캐릭터 클래스 외부의 이스케이프 처리되지 않은 # 문자가 패턴의 다음 줄바꿈 문자까지 이어지는 주석을 나타낸다. <?php $string = 'test'; echo preg_match('/te(?# 주석테스트)st/', $string) . "\n"; echo preg_match('/te#~~~~ st/', $string) . "\n"; echo preg_match('/te#~~~~ st/x', $string) . "\n"; // result // 1 // 0 // 1 // 두 번째 정규식의 경우 x(PCRE_EXTENDED) 옵션이 없으므로 #~~~~을 주석으로 인정하지 않아 실패를 반환 PHP 정규식(PCRE)의 모든 것 - 프롤로그 PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters) PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters) PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences) PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties) PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors) PHP 정규식(PCRE)의 모든 것 - 마침표(Dot) PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes) PHP 정규식(PCRE)의 모든 것 - 선택(Alternation) PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting) PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns) PHP 정규식(PCRE)의 모든 것 - 반복(Repetition) PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references) PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions) PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns) PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns) > PHP 정규식(PCRE)의 모든 것 - 주석(Comments) PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns) PHP 정규식(PCRE)의 모든 것 - 에필로그]]></summary><content type="html"><![CDATA[<h3><a href="http://php.net/manual/kr/regexp.reference.comments.php">Comments</a> (주석)</h3>
<p>시퀀스 <code>(?#</code>는 다음 닫는 괄호까지 이어지는 주석의 시작을 표시한다.
중첩된 괄호는 허용되지 않으며 주석을 구성하는 문자는 패턴 일치에 전혀 영향을 미치지 않는다.</p>
<p><a href="/2017/01/04/php-pcre-pattern-modifiers/">PCRE_EXTENDED</a> 옵션을 설정하면 <a href="/2017/01/14/php-regex-character-classes/">캐릭터 클래스</a> 외부의 <a href="/2017/01/10/php-regex-escape-sequences/">이스케이프</a> 처리되지 않은 <code>#</code> 문자가 패턴의 다음 줄바꿈 문자까지 이어지는 주석을 나타낸다.</p>
<pre><code>&lt;?php
$string = 'test';
echo preg_match('/te(?# 주석테스트)st/', $string) . "\n";
echo preg_match('/te#~~~~
st/', $string) . "\n";
echo preg_match('/te#~~~~
st/x', $string) . "\n";

// result
// 1
// 0
// 1
// 두 번째 정규식의 경우 x(PCRE_EXTENDED) 옵션이 없으므로 #~~~~을 주석으로 인정하지 않아 실패를 반환</code></pre>
<hr />
<ul>
<li><a href="/2017/01/07/php-regex-prolog/">PHP 정규식(PCRE)의 모든 것 - 프롤로그</a></li>
<li><a href="/2017/01/08/php-regex-delimiters/">PHP 정규식(PCRE)의 모든 것 - 구분기호(Delimiters)</a></li>
<li><a href="/2017/01/09/php-regex-meta-characters/">PHP 정규식(PCRE)의 모든 것 - 메타문자(Meta-characters)</a></li>
<li><a href="/2017/01/10/php-regex-escape-sequences/">PHP 정규식(PCRE)의 모든 것 - 이스케이프 시퀀스(Escape Sequences)</a></li>
<li><a href="/2017/01/11/php-regex-unicode-character-properties/">PHP 정규식(PCRE)의 모든 것 - 유니코드 문자 속성(Unicode character properties)</a></li>
<li><a href="/2017/01/12/php-regex-anchors/">PHP 정규식(PCRE)의 모든 것 - 앵커(Anchors)</a></li>
<li><a href="/2017/01/13/php-regex-dot/">PHP 정규식(PCRE)의 모든 것 - 마침표(Dot)</a></li>
<li><a href="/2017/01/14/php-regex-character-classes/">PHP 정규식(PCRE)의 모든 것 - 캐릭터 클래스(Character classes)</a></li>
<li><a href="/2017/01/15/php-regex-alternation/">PHP 정규식(PCRE)의 모든 것 - 선택(Alternation)</a></li>
<li><a href="/2017/01/16/php-regex-internal-option-setting/">PHP 정규식(PCRE)의 모든 것 - 내부 옵션 설정(Internal option setting)</a></li>
<li><a href="/2017/01/17/php-regex-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 서브 패턴(Subpatterns)</a></li>
<li><a href="/2017/01/18/php-regex-repetition/">PHP 정규식(PCRE)의 모든 것 - 반복(Repetition)</a></li>
<li><a href="/2017/01/19/php-regex-back-references/">PHP 정규식(PCRE)의 모든 것 - 역 참조(Back references)</a></li>
<li><a href="/2017/01/20/php-regex-assertions/">PHP 정규식(PCRE)의 모든 것 - 어설션(Assertions)</a></li>
<li><a href="/2017/01/21/php-regex-once-​only-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 일회성 서브 패턴(Once-​only subpatterns)</a></li>
<li><a href="/2017/01/22/php-regex-conditional-subpatterns/">PHP 정규식(PCRE)의 모든 것 - 조건부 서브 패턴(Conditional subpatterns)</a></li>
<li>> <strong>PHP 정규식(PCRE)의 모든 것 - 주석(Comments)</strong></li>
<li><a href="/2017/01/24/php-regex-recursive-patterns/">PHP 정규식(PCRE)의 모든 것 - 재귀 패턴(Recursive patterns)</a></li>
<li><a href="/2017/01/25/php-regex-epilogue/">PHP 정규식(PCRE)의 모든 것 - 에필로그</a></li>
</ul>]]></content></entry>


</feed>