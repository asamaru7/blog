<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-09-15T19:50:49+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AsyncTask의 생성을 UIThread에서 하지 않으면 발생하는 문제 해결]]></title>
    <link href="http://blog.asamaru.net/2015/09/09/asynctask-init-problem/"/>
    <updated>2015-09-09T21:36:59+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/09/asynctask-init-problem</id>
    <content type="html"><![CDATA[<p>최근에 안드로이드의 앱 성능 개선에 관련하여 여러가지 자료를 확인중이다. 대표적인 것들이 memory leak에 관련된 문제와 thread 사용에 대한 것들이 있다. 오늘 하고자 하는 얘기는 이 thread 관련된 정보를 조사하다가 알게된 부분을 공유하고자 한다.</p>

<p>이 내용의 출처는 <a href="" title="https://gist.github.com/benelog/5954649">여기</a>다.</p>

<p>AsyncTask가 UI 스레드가 아닌 곳에서 처음으로 호출된다면 아래와 같은 에러스택이 발생할 수 있다고 한다. 이건 또 무슨 말도 안되는 소린가? 정말 안드로이드는 말도 안되는 이상한 현상들이 너무나도 많다. 하지만 위에 안내한 출처에서 명확한 원인과 해결 방법을 제시하고 있다.</p>

<pre><code>android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
    at android.view.ViewRoot.checkThread(ViewRoot.java:3011)
    at android.view.ViewRoot.requestLayout(ViewRoot.java:634)
    at android.view.View.requestLayout(View.java:8284)
    at android.view.View.setFlags(View.java:4658)
    at android.view.View.setVisibility(View.java:3133)
    at android.app.Dialog.hide(Dialog.java:254)
</code></pre>

<pre><code> Handler{40797d88} sending message to a Handler on a dead thread
 java.lang.RuntimeException: Handler{40797d88} sending message to a Handler on a dead thread
     at android.os.MessageQueue.enqueueMessage(MessageQueue.java:196)
     at android.os.Handler.sendMessageAtTime(Handler.java:457)
     at android.os.Handler.sendMessageDelayed(Handler.java:430)
     at android.os.Handler.sendMessage(Handler.java:367)
     at android.os.Message.sendToTarget(Message.java:349)
     at android.os.AsyncTask$3.done(AsyncTask.java:214)
     at java.util.concurrent.FutureTask$Sync.innerSet(FutureTask.java:253)
     at java.util.concurrent.FutureTask.set(FutureTask.java:113)
     at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:311)
     at java.util.concurrent.FutureTask.run(FutureTask.java:138)
     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1088)
     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:581)
     at java.lang.Thread.run(Thread.java:1019)
</code></pre>

<h2>원인</h2>

<p>AsyncTask 내에는 sHandler라는 static 멤버 변수가 있다고 해서 실제로 확인해 봤다. 현재 출처에서 밝힌 소스와는 조금 다르게 변경되어 있었다. sHandler는 앱에서 AsyncTask를 최초 선언한 순간 객체가 할당되고, UI작업을 처리하는 onPostExecute()가 호출될 때 사용된다고 설명되어 있었으나 설명과 다르게 선언시에는 아래와 같이 초기화를 하지 않도록 변경되었다. 대신 내부에서 getHandler() 함수가 처음 실행될 때 초기화 된다.</p>

<pre><code>private static final InternalHandler sHandler;
...
private static Handler getHandler() {
    synchronized (AsyncTask.class) {
        if (sHandler == null) {
            sHandler = new InternalHandler();
        }
        return sHandler;
    }
}
...
private static class InternalHandler extends Handler {
     ...
}
</code></pre>

<blockquote><p>앱을 실행하고 최초로 AsyncTask를 선언한 부분이 메인쓰레드가 아니라면 InternalHandler는 메인쓰레드가 아닌 쓰레드의 Handler를 가지고 있고 이 Handler로는 UI 작업을 하지 못하기 때문에 &ldquo;android.view.ViewRoot$CalledFromWrongThreadException&rdquo; 오류를 냅니다.</p>

<p>이 문제는 API Level 16미만 에서만 발생합니다. API Level 16이상에서는 메인스레드를 관리하는 ActivityThread 클래스가 시작할 때 main 메소드에서 static 메소드인 AsyncTask.init()을 호출하여 AsyncTask 클래스를 로드하고 있습니다. 관련 Commit은 다음 링크에서 확인하실 수 있습니다.</p>

<p><a href="https://github.com/android/platform_frameworks_base/commit/5e9120d4adfb07aeeadb0e0de1de2eb9ebbd80e0">https://github.com/android/platform_frameworks_base/commit/5e9120d4adfb07aeeadb0e0de1de2eb9ebbd80e0</a></p></blockquote>

<p>이렇게 설명되어 있으나 위에 얘기한 것 처럼 현재는 다시 조금 변경되어 있었다. 정확히는 AsyncTask.init() 이 부분이 없다. init() 함수도 선언되어 있지 않다.</p>

<p>그렇다면 문제가 없는 것일까? 해서 다시 조금 찾아봤다. 이 부분에 대해서는 <a href="" title="http://sjava.net/?p=1570">여기</a>에서 설명하고 있었다.
내용을 보니 5.1이 나오면서 내부적 처리가 변경된 것으로 보인다. 그리고 설명대로라면 사용상의 변경은 크지 않으므로 역시 초기화 과정은 필요없다.</p>

<p>덤으로 위 사이트에서 안내된 내용 중에 아래의 내용도 있다.</p>

<h3>Threading rules</h3>

<blockquote><p>There are a few threading rules that must be followed for this class to work properly:</p></blockquote>

<ul>
<li>The AsyncTask class must be loaded on the UI thread. This is done automatically as of JELLY_BEAN.</li>
<li>The task instance must be created on the UI thread.</li>
<li>execute(Params&hellip;) must be invoked on the UI thread.</li>
<li>Do not call onPreExecute(), onPostExecute(Result), doInBackground(Params&hellip;), onProgressUpdate(Progress&hellip;) manually.</li>
<li>The task can be executed only once (an exception will be thrown if a second execution is attempted.)</li>
</ul>


<h2>해결</h2>

<p>주저리 주저리 얘기가 많았는데 그래서 결론은 무엇인가? 젤리빈(API 16) 이상은 UIThread 내부에서 생성해야 한다는 제약사항 없이 어디서나 사용해도 무방하다. 그럼 그 이하는 어떻게 하나?
아래의 코드를 actiity 또는 application 시작 지점에 추가 한다. 메인스레드에서 단순히 클래스 로딩을 한번만 해도 AsyncTask내의 static 멤버 변수가 정상적으로 초기화된다고 한다.
그래서 난 appication class의 onCreate 함수 내부에 아래의 코드를 추가해 두었다.</p>

<pre><code class="java">if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) {
    try {
        Class.forName("android.os.AsyncTask");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드에서 findViewById 사용시 Generics을 이용해 Type Casting 없애기]]></title>
    <link href="http://blog.asamaru.net/2015/09/08/cleaner-view-casting-with-generics/"/>
    <updated>2015-09-08T22:27:15+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/08/cleaner-view-casting-with-generics</id>
    <content type="html"><![CDATA[<p>안드로이드 작업을 하다보면 findViewById를 아주 빈번하게 사용하게 된다. 이 작업이 생각보다 귀찮다보니 <a href="" title="http://jakewharton.github.io/butterknife/">butterknife</a>나 <a href="" title="http://androidannotations.org/">androidannotations</a> 같은 라이브러리를 사용하게 된다.(당연히 그 함수를 사용이 귀찮다는 이유만은 아니지만)</p>

<p>아래의 방법은 저런 라이브러리를 사용할 때만큼 여러가지 일을 할 수는 없지만 findViewById를 사용함에 가장 귀찮은 작업인 View Type Casting을 하지 않아도 된다.</p>

<p>우린 일반적으로 아래와 같은 방식으로 함수를 사용한다.</p>

<pre><code class="java">TextView textView = (TextView) findViewById(R.id.textview);
</code></pre>

<p>이를 개선하기 위해 아래의 함수 하나를 추가한다. 어디든 상관 없이 사용하고자 하는 클래스의 내부에 넣는다. 사실 사용시마다 이 함수를 추가하는 작업이 더 귀찮을 수 있다. 그래서 난 기본 Activity와 Fragment 안에 넣어두고 사용한다. (난 여러가지 이유로 작업시 base activity, fragment를 만들어 두고 실제 작업시 상속받아 사용한다. 이렇게하면 이번 경우와 같이 유틸성 함수를 함께 쓰기도 좋고 제어하기도 좋기 때문이다.)</p>

<pre><code class="java">@SuppressWarnings("unchecked")
public final &lt;E extends View&gt; E findView (int id) {
    return (E) findViewById(id);
}
</code></pre>

<p>그리고 아래와 같이 사용할 수 있다.</p>

<pre><code class="java">TextView textView = findView(R.id.textview);
Button button = findView(R.id.button);
ImageView image = findView(R.id.imageview);
</code></pre>

<p>사실 별차이 아니다. 하지만 작업 해본 사람은 안다. Type Casting을 일일이 넣는게 얼마나 귀찮은지.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 스튜디오에서 WIFI로 Run/Install/Debug 하기]]></title>
    <link href="http://blog.asamaru.net/2015/09/07/android-run-slash-install-slash-debug-applications-over-wifi/"/>
    <updated>2015-09-07T20:43:33+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/07/android-run-slash-install-slash-debug-applications-over-wifi</id>
    <content type="html"><![CDATA[<p>이제 안드로이드 개발을 시작한지 6개월 가량 된 것 같다. 나이 주 개발 영역은 웹이다. 프론드/백엔드, 서버 등등 웹에 관련된 일을 주로하며 예전엔 아이폰 개발도 일부 했었다. 하지만 회사 업무로 인해 안드로이드를 시작하게 되었고 6개월이나 했음에도 아직 초보를 벗어나지 못한 것 같다. 불필요한 사설이 길었지만 6개월간 왜 불편함을 그냥 당연하게 생각하고 작업을 했는지 안타깝다.</p>

<p>어제는 불현듯 책생 위에 널브러져 케이블들을 보며 이걸 없앨 수 없나? 라는 생각이 들었다. 내 책상 위에는 아이폰이 3개, 안드로이드 폰이 2개, 충전선 등이 있다. 굳이 다 필요하진 않지만&hellip;
그래서 찾아봤다. 안드로이드 빌드 후 실행을 케이블 없이 할 수 있는가? 결과는 있다. 아 왜 진작 찾아보지 않았던가? 사실은 선 정리보다 더 중요한 문제가 있었다. 안드로이드 연결 케이블이 불안정한 것이다. adb에 붙었다 떨어졌다 하는 현상이 사용하는 케이블에 따라 상태가 천차만별이었다. 정말 안드로이드는 맘에 안든다.</p>

<p>이제 정말 각설하고 본론을&hellip;</p>

<p>일단 이 방법에서의 최대 단점은 최초 연결시에는 USB 케이블이 필요하다는 것이다. 그리고 같은 망으로 연결되어야 한다는 점.</p>

<h3>1. 일단 기존처럼 USB로 안드로이드폰을 연결한다.</h3>

<h3>2. Shell을 열어 기기가 연결된 것을 확인한다. (사실 이 단계는 확인단계로 그냥 건너뛰어도 된다.)</h3>

<pre><code class="bash">$ adb devices -l

List of devices attached
6a1d4134               device usb:4245815296X product:hltelgt model:SM_N900L device:hltelgt
</code></pre>

<h3>3. 연결된 기기의 IP를 확인한다. adb shell 실행 후 shell이 뜨면 netcfg 입력. exit로 종료.</h3>

<pre><code class="bash">$ adb shell

shell@hltelgt:/ $ netcfg

rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 2e:80:5c:86:19:5f
...
sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00
p2p0     UP                                     0.0.0.0/0   0x00001003 ca:14:79:ea:48:5f
lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00
wlan0    UP                             192.168.219.101/24  0x00001043 c8:14:79:ea:48:5f

shell@hltelgt:/ $ exit
</code></pre>

<h3>4. adb를 통해 포트 5555(원하는 포트)로 변경한다.</h3>

<pre><code class="bash">$ adb tcpip 5555
</code></pre>

<h3>5. 기기 IP를 통해서 연결</h3>

<pre><code class="bash">$ adb connect &lt;DEVICE_IP_ADDRESS&gt;:5555
</code></pre>

<p>끝이다. 이제는 USB에서 기기를 분리해도 된다.
이제부터는 안드로이드 스튜디오에서 빌드를 하고 실행하려고 하면 원격으로 연결된 기기가 뜬다.</p>

<p>아직 많이 써보진 않았지만 아무래도 직접 USB로 연결한 것 보다는 조금 느린 것 같긴하다. 하지만 계속 션으로 연결하지 않아도 된다는 것으로 만족.</p>

<p>마지막으로 리모트 연결을 다시 USB 연결로 바꾸는 방법</p>

<pre><code class="bash">adb -s &lt;DEVICE_IP_ADDRESS&gt;:5555 usb
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드에서 Dialog 사용시 WindowManager$BadTokenException 발생]]></title>
    <link href="http://blog.asamaru.net/2015/09/04/android-dialog-windowmanager-badtokenexception/"/>
    <updated>2015-09-04T20:49:21+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/04/android-dialog-windowmanager-badtokenexception</id>
    <content type="html"><![CDATA[<p>안드로이드에서는 거의 모든 작업에 context를 사용한다. 그런데 이 context는 크게 application contet와 activity context가 있다. 문제는 사용시에 구분해서 사용하지 않는다는 것이다. 명시적으로 특정 context를 요구하지 않는다. 이로 인해 많은 혼란이 있고 crash도 많이 발생한다.</p>

<p>사실 오류를 줄이려면 가능한한 activity context를 사용하는 것이 좋다.(경험상&hellip;) 하지만 안드로이드에서는 가급적 application context를 사용하기를 권장한다.</p>

<p>가장 대표적인 이유는 메모리릭 때문이다. 메모리릭에 대한 문제는 context의 종류에 직접적인 관련이 있는 것은 아니나 activity 내부에서 객체를 생성하면서 자신을 context로 넘겨줄 경우 순환참조 등의 이유로 객체가 소멸하지 못할 수 있다. 메모리릭 문제는 상상보다 더 다양한 경우에 발생하는데 여기서 논하고자하는 범위를 벋어나니 일단 넘어가자. 사실 검색해 보면 많은 자료가 있다.
어쨌든 생성된 객체가 죽지 못한다면 activity도 소멸하지 못하므로 대량의 메모리 점유를 경험하게 될 수 있다. 당연히 앱이 크지 않다면 OOM(Out Of Memory)을 쉽게 만나지는 않을 것이다.
사설이 길었는데 어쨌든 이러한 이유로 나는 가급적 application context를 사용하려고 한다.
문제는 여기서 시작되었다.</p>

<p>기존에 WebView를 생성할 때는 activity를 넘겨주었었다. 이 코드를 얼마전 확인하고 application context로 변경했다. 그리고 빌드, 실행. 문제가 없었다. 잘 나왔다. 안심했다.</p>

<p>그런데 오늘 동료 직원이 이상한 부분이 있다고 확인을 요청했다.</p>

<blockquote><p>WebView 내부에 있는 select box를 터치하면 앱이 죽는다.</p></blockquote>

<p>처음엔 뭔가 했다. 그런데 오류를 확인하니 다음과 같았다.</p>

<pre><code>W/System.err﹕ android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an application
W/System.err﹕ at android.view.ViewRootImpl.setView(ViewRootImpl.java:691)
W/System.err﹕ at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:288)
W/System.err﹕ at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)
W/System.err﹕ at android.app.Dialog.show(Dialog.java:312)
W/System.err﹕ at org.chromium.content.browser.input.SelectPopupDialog.show(SelectPopupDialog.java:133)
W/System.err﹕ at org.chromium.content.browser.ContentViewCore.showSelectPopup(ContentViewCore.java:2437)
W/System.err﹕ at org.chromium.base.SystemMessageHandler.nativeDoRunLoopOnce(Native Method)
W/System.err﹕ at org.chromium.base.SystemMessageHandler.handleMessage(SystemMessageHandler.java:53)
W/System.err﹕ at android.os.Handler.dispatchMessage(Handler.java:102)
W/System.err﹕ at android.os.Looper.loop(Looper.java:145)
W/System.err﹕ at android.app.ActivityThread.main(ActivityThread.java:5942)
W/System.err﹕ at java.lang.reflect.Method.invoke(Native Method)
W/System.err﹕ at java.lang.reflect.Method.invoke(Method.java:372)
W/System.err﹕ at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1399)
</code></pre>

<p>이런 Dialog를 생성하려는 시점에서 context가 적절하지 못하다. 그렇다. WebView에서 select box를 선택하면 앱의 경우는 선택 dialog가 자동으로 뜬다. 이때 이 dialog를 생성할 때 WebView 생성시 넣어 줬던 context를 사용하는 것이다.</p>

<p>아&hellip; 그럼 처음부터 application context를 넣지 못하도록 하던지&hellip; 정말 안드로이드는 누가 설계 했는지 너무 엉망이다. UIThread 문제, Network Main Thread 문제.. 등등 상식적으로 해결 방법이 있을 법한데 모두 개발자가 알아서 하란다. 이런&hellip;</p>

<p>어쨌든 Dialog 생성시에는 activity context를 사용해야 한다. 일반 dialog는 테스트시에 바로 표시가 나니 금방 고칠 수 있지만 이런 경우는 참 난해하다.</p>

<p>결론은 WebView 생성시에는 activity context를 넣자.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 View.isLaidOut / View.post]]></title>
    <link href="http://blog.asamaru.net/2015/09/04/android-view-dot-islaidout-and-view-dot-post/"/>
    <updated>2015-09-04T10:12:29+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/04/android-view-dot-islaidout-and-view-dot-post</id>
    <content type="html"><![CDATA[<p>안드로이드 View는 isLaidOut이라는 함수를 가지고 있다. 단, API 19(KITKAT)부터 사용가능하다. 사실 그 이하의 기기에서도 다른 방법을 통해서 사용가능하다. 아주 간단히. 이 부분은 나중에 다시 설명하겠다.</p>

<p>우선 isLaidOut 함수에 대해 안드로이드 메뉴얼에는 다음과 같이 나와있다.</p>

<blockquote><p>public boolean isLaidOut ()</p>

<p>Added in API level 19</p>

<p>Returns true if this view has been through at least one layout since it was last attached to or detached from a window.</p></blockquote>

<p>쉽게 말해서 &ldquo;해당 View가 layout이 그려졌는가?"를 반환하는 함수다.</p>

<p>다음은 post 함수에 대한 안드로이드 메뉴얼이다.</p>

<blockquote><p>public boolean post (Runnable action)</p>

<p>Added in API level 1</p>

<p>Causes the Runnable to be added to the message queue. The runnable will be run on the user interface thread.</p></blockquote>

<p>Runnalbe을 넘겨 받아 UIThread에서 실행시켜준다고 한다.</p>

<p>그래서 어디에 써먹을 수 있나?
한가지 예를들어 보자면 TextView의 getLineCount()의 반환값 문제를 해결할 수 있다.</p>

<p>구글에서 &ldquo;<a href="https://www.google.co.kr/search?q=isLaidOut&amp;gws_rd=ssl#newwindow=1&amp;safe=off&amp;q=textview+getlinecount">textview getlinecount</a>"로 검색하면 많이 나오는 것 중 하나가 "textview.getLineCount always 0 in android"라는 질문이다.</p>

<p>textview의 getLineCount()를 요청하면 항상 0이 나오는 문제가 있다는 얘기인데, 이런 문제의 원인은 getLineCount() 함수가 TextView가 그려진 후 그 상황에 맞는 라인수를 반환한다는 것이다. 따라서 그려지기 전에는 항상 0을 반환한다.</p>

<p>그럼 이 문제를 isLaidOut을 써서 해결해보자.</p>

<pre><code class="java">TextView textView = new TextView(context);

...

textView.setText("test message");
if (textView.isLaidOut()) {
    Log.d("TEXTVIEW", "line count : " + textView.getLineCount());
} else {
    final TextView postTextView = textView;
    textView.post(new Runnable() {
        @Override
        public void run() {
            Log.d("TEXTVIEW", "line count : " + postTextView.getLineCount());
        }
    });
}
</code></pre>

<p>여러가지 상황이 있을 수 있다. 위의 예시와 다르게 layout xml에서 TextView가 정의될 수도 있고.
중요한 것은 TextView가 그려지기 전에 getLineCount() 함수를 사용하려는 것이다.</p>

<p>그런데 여기서도 한계는 있다. 값을 가져오는 부분이 비동기 방식이 된다는 것이다. 이를 해결하기 위해서는 다른 방법이 필요하다. 하지만 여기서는 isLaidOut에 대한 설명을 하고자 하는 것이므로 다음으로 넘긴다. 사실 찾아보면 여러가지 방법들이 제시되어 있는데 아주 깔끔한 방법은 현재로써는 찾기 힘들다.</p>

<p>위의 TextView 사례는 말그대로 예시일뿐 isLaidOut에 대한 활용 범위는 아주 다양할 수 있다.</p>

<p>마지막으로 isLaidOut을 API 19 이하에서 사용할 수 있는 방법은 다음의 예시를 참고하자.</p>

<pre><code class="java">TextView textView = new TextView(context);

...

textView.setText("test message");
if (ViewCompat.isLaidOut(textView)) {
    Log.d("TEXTVIEW", "line count : " + textView.getLineCount());
} else {
    final TextView postTextView = textView;
    textView.post(new Runnable() {
        @Override
        public void run() {
            Log.d("TEXTVIEW", "line count : " + postTextView.getLineCount());
        }
    });
}
</code></pre>

<p>중요한 부분은 ViewCompat을 사용한다는 부분이다. 아주 간단한 방법으로 사용할 수 있으므로 하위 버전을 지원해야 한다하더라도 사용할 수 있다.</p>

<pre><code class="java">ViewCompat.isLaidOut(textView)
</code></pre>
]]></content>
  </entry>
  
</feed>
