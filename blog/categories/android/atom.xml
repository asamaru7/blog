<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-10-12T16:56:18+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[java.lang.IllegalStateException: Recursive entry to executePendingTransactions 오류]]></title>
    <link href="http://blog.asamaru.net/2015/10/12/java-dot-lang-dot-illegalstateexception-recursive-entry-to-executependingtransactions/"/>
    <updated>2015-10-12T12:07:06+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/12/java-dot-lang-dot-illegalstateexception-recursive-entry-to-executependingtransactions</id>
    <content type="html"><![CDATA[<p>안드로이드 작업중 <code>java.lang.IllegalStateException: Recursive entry to executePendingTransactions</code> 오류를 만났다. 오류가 발생한 상황은 다음과 같다.</p>

<p>작업중 Fragment에서 하위에 또 다른 Fragment를 추가할 일이 생겼다. 이 작업 중에 하위에 추가되는 Fragment에서 <code>executePendingTransactions()</code> 함수를 호출하니 위 오류가 발생했다. 이해를 위해 처리 과정 중 문제가 발생한 부분만 적는다.</p>

<pre><code class="java">FragmentManager ft = getActivity().getSupportFragmentManager();
ft.beginTransaction()
        .add(R.id.fragmentContainer, (Fragment) fragment)
        .commit();
ft.executePendingTransactions();
</code></pre>

<p>FragmentManager를 얻기 위해 현재 Fragment의 Activity를 가져와 <code>getSupportFragmentManager()</code>를 사용했다. 이 부분이 문제가 생기는 이유다. 이런 경우는 아래와 같이 처리할 수 있다.</p>

<pre><code class="java">FragmentManager ft = getChildFragmentManager();
ft.beginTransaction()
        .add(R.id.fragmentContainer, (Fragment) fragment)
        .commit();
ft.executePendingTransactions();
</code></pre>

<p><code>getChildFragmentManager()</code>를 사용해서 FragmentManager를 얻어서 처리하면 위 오류는 발생하지 않는다.</p>

<p>이와 관련된 설명은 <a href="http://developer.android.com/intl/ru/about/versions/android-4.2.html#NestedFragments">Nested Fragments</a>를 보면 된다. 4.2에 변경된 내용으로 나와 있지만 support library를 사용한다면 하위 호환이 가능한 상황이라 문제되지 않는다.</p>

<p>추가적으로 <a href="http://developer.android.com/intl/ko/reference/android/app/FragmentManager.html#executePendingTransactions%28%29">public abstract boolean executePendingTransactions()</a>에 대해서 궁금하다면 <a href="http://developer.android.com/intl/ko/guide/components/fragments.html#Transactions">프래그먼트 트랜잭션 수행</a>)를 참고하면 된다.</p>

<blockquote><p>commit()을 호출해도 그 즉시 트랜잭션을 수행하지는 않습니다. 그보다는, 액티비티의 UI 스레드(&ldquo;주요&rdquo; 스레드)를 스레드가 할 수 있는 한 빨리 이 트랜잭션을 수행하도록 일정을 예약하는 것에 가깝습니다. 하지만 필요한 경우 UI 스레드로부터 executePendingTransactions()를 호출하면 commit()이 제출한 트랜잭션을 즉시 실행할 수 있습니다. 트랜잭션이 다른 스레드의 작업에 대한 종속성이 아니라면 굳이 이렇게 해야만 하는 것은 아닙니다.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드에서 인턴트 호출시 Intent.FLAG_ACTIVITY_CLEAR_TOP 또는 Intent.FLAG_ACTIVITY_SINGLE_TOP 사용시 Androidannotations @Extra가 동작하지 않는 문제]]></title>
    <link href="http://blog.asamaru.net/2015/10/12/androidannotations-at-extra-with-intent-dot-flag-activity-clear-top-or-intent-dot-flag-activity-single-top/"/>
    <updated>2015-10-12T10:14:56+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/12/androidannotations-at-extra-with-intent-dot-flag-activity-clear-top-or-intent-dot-flag-activity-single-top</id>
    <content type="html"><![CDATA[<p><a href="http://androidannotations.org/">Androidannotations</a>를 사용하면 <code>@Extra</code>를 사용해서 인자를 받을 수 있다. 그런데 여기서 주의할 점이 있다. 인턴트 호출시 <code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code> 또는 <code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>를 사용하게되면 인턴트가 이미 존재할 경우 <code>@Extra</code>가 동작하지 않는다. 이와 관련해서 <a href="https://github.com/excilys/androidannotations/issues/1578">Always call #onNewIntent(), even without @AfterExtras method(s)</a>에서도 이슈가 진행중이다. 앞서 이야기한 문제와 이 이슈는 정확하게 같은 내용은 아니지만 동일한 이유로 발생하며 유사한 내용이라고도 볼 수 있다.</p>

<p>간단히 요약하자면 <code>@Extra</code>는 관련 처리를 <code>setIntent()</code>와 <code>onCraete()</code>에서 하는데 <code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code> 또는 <code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>를 사용하게되면 인턴트가 존재할 경우 두 함수가 실행되지 않는다는 것이다(<code>onCraete()</code> 대신에 <code>onNewIntent(Intent intent)</code>가 호출이 되고 그 다음 onResume() 이 호출이 된다).</p>

<p>현재까지는 <a href="http://androidannotations.org/">Androidannotations</a>에서 해당 문제를 해결하지 않았으므로 그에 따른 대응이 필요하다(Androidannotations을 사용하지 않는 상황이라면 <code>onResume</code>에서 extra 값을 받아오도록 하면 당연히 문제가 없다).</p>

<p>현재로써는 특별한 방법이 없어 아래와 같이 <code>onNewIntent()</code>애서 직접 값을 받도록 처리했다.</p>

<pre><code class="java">@Override
protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    moveOwnLocation = intent.getBooleanExtra("EXTRA_NAME", false);
}
</code></pre>

<p>하지만 이렇게 한다면 <code>@Extra</code>를 사용하는 의미가 없고 <code>@AfterExtras</code>도 정상적으로 사용할 수 없으므로 패치를 기다렸다가 코드를 다시 처리 해야할 것 같다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Play services 와 DEX method limits 문제]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/google-play-services-and-dex-method-limits/"/>
    <updated>2015-10-05T20:49:03+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/google-play-services-and-dex-method-limits</id>
    <content type="html"><![CDATA[<p><a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>에서 잠시 언급했던 multidex와 <a href="https://developers.google.com/android/guides/overview">Google Play services</a>와의 관계에 대해서 잠시 이야기 하고자 한다. 그 당시에도 설명했던 것과 같이 multidex를 사용해야 하는 상황은 가급적 피하는 것이 좋다. 하지만 오래된 버전의 Google Play services를 사용하면 65K이상의 method를 사용하게될 확률이 높다. 이 라이브러리에서 사용하고 있는 method의 수가 상당하기 때문에 proguard를 통해 사용하지 않는 함수를 제거하지 않는 이상 65K개를 넘어설 확률이 높은 것이다(대부분 여러가지 라이브러리를 사용해서 앱을 개발하므로). 문제는 proguard를 적용하게되면 빌드 시간이 증가하기 때문에 작업시 불편하다. <a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>에서 언급 했던 내용들을 적용한다면 상당한 속도 향상을 가져올 수 있지만 그래도 1초라도 시간을 줄이는 것이 좋지 않은가? 하루에 한번만 빌드할 것도 아닌데.</p>

<p>이와 관련해서는 <a href="http://android-developers.blogspot.kr/2014/12/google-play-services-and-dex-method.html">Google Play services and DEX method limits</a>라는 글에 잘 설명하고 있다.</p>

<p>Google Play services의 버전을 6.5(2015.10.05. 기준 8.1이 최신) 이상 사용한다면 아래와 같이 필요한 부분만 적용함으로써 이 문제를 어느 정도 해결할 수 있다(6.5 미만에서는 무조건 통째로 불러서 사용할 수 밖에 없다).</p>

<pre><code>// 기존
compile 'com.google.android.gms:play-services:6.5.87'

// 6.5 이후
compile 'com.google.android.gms:play-services-maps:6.5.87'
compile 'com.google.android.gms:play-services-base:6.5.87'
</code></pre>

<p><a href="https://developers.google.com/android/guides/setup">Setting Up Google Play Services</a> 문서를 참고하면 사용할 수 있는 전체 목록을 확인할 수 있다. 아래는 현재 기준 목록이다.</p>

<table>
<thead>
<tr>
<th> Google Play services API   </th>
<th>     Description in build.gradle </th>
</tr>
</thead>
<tbody>
<tr>
<td> Google+ </td>
<td> com.google.android.gms:play-services-plus:8.1.0 </td>
</tr>
<tr>
<td> Google Account Login </td>
<td> com.google.android.gms:play-services-identity:8.1.0 </td>
</tr>
<tr>
<td> Google Actions, Base Client Library </td>
<td> com.google.android.gms:play-services-base:8.1.0 </td>
</tr>
<tr>
<td> Google App Indexing </td>
<td> com.google.android.gms:play-services-appindexing:8.1.0 </td>
</tr>
<tr>
<td> Google App Invites </td>
<td> com.google.android.gms:play-services-appinvite:8.1.0 </td>
</tr>
<tr>
<td> Google Analytics </td>
<td> com.google.android.gms:play-services-analytics:8.1.0 </td>
</tr>
<tr>
<td> Google Cast </td>
<td> com.google.android.gms:play-services-cast:8.1.0 </td>
</tr>
<tr>
<td> Google Cloud Messaging </td>
<td> com.google.android.gms:play-services-gcm:8.1.0 </td>
</tr>
<tr>
<td> Google Drive </td>
<td> com.google.android.gms:play-services-drive:8.1.0 </td>
</tr>
<tr>
<td> Google Fit </td>
<td> com.google.android.gms:play-services-fitness:8.1.0 </td>
</tr>
<tr>
<td> Google Location, Activity Recognition, and Places </td>
<td> com.google.android.gms:play-services-location:8.1.0 </td>
</tr>
<tr>
<td> Google Maps </td>
<td> com.google.android.gms:play-services-maps:8.1.0 </td>
</tr>
<tr>
<td> Google Mobile Ads </td>
<td> com.google.android.gms:play-services-ads:8.1.0 </td>
</tr>
<tr>
<td> Mobile Vision </td>
<td> com.google.android.gms:play-services-vision:8.1.0 </td>
</tr>
<tr>
<td> Google Nearby </td>
<td> com.google.android.gms:play-services-nearby:8.1.0 </td>
</tr>
<tr>
<td> Google Panorama Viewer </td>
<td> com.google.android.gms:play-services-panorama:8.1.0 </td>
</tr>
<tr>
<td> Google Play Game services </td>
<td> com.google.android.gms:play-services-games:8.1.0 </td>
</tr>
<tr>
<td> SafetyNet </td>
<td> c m.google.android.gms:play-services-safetynet:8.1.0 </td>
</tr>
<tr>
<td> Google Wallet </td>
<td> com.google.android.gms:play-services-wallet:8.1.0 </td>
</tr>
<tr>
<td> Android Wear </td>
<td> com.google.android.gms:play-services-wearable:8.1.0 </td>
</tr>
</tbody>
</table>


<p>어쨌든 java라는 언어의 특성상 method의 수가 많을 수 밖에 없는데 65K limit은 최초의 설계부터 잘못된 것이 아닌가? 하는 생각이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle applicationIdSuffix 사용시 AndroidAnnotations 설정]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/using-applicationidsuffix-with-androidannotations/"/>
    <updated>2015-10-05T10:05:11+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/using-applicationidsuffix-with-androidannotations</id>
    <content type="html"><![CDATA[<p><a href="/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix/">Gradle DSL method not found: &lsquo;packageNameSuffix()&rsquo; 오류 해결</a>에서 오류 해결 방법을 안내하면서 언급했던 applicationIdSuffix를 사용시 유의사항이 있다. <strong>applicationId가 debug 모드에서 변경됨에 따라 관련된 부분에서 문제가 일어날 수 있다는 것이다.</strong></p>

<p>나의 경우는 AndroidAnnotations을 함께 사용하는 부분에서 오류를 만났다. AndroidAnnotations에서 applicationId를 기준으로 resource에 접근해서 자동 생성된 class들을 찾지 못하는 문제이다.</p>

<p>이런 경우에 대비해서 AndroidAnnotations에는 resourcePackageName라는 속성을 제공한다.</p>

<p><a href="https://github.com/excilys/androidannotations/wiki/CustomizeAnnotationProcessing">CustomizeAnnotationProcessing</a>에 보면 아래와 같이 안내되어 있다.</p>

<blockquote><p><strong>resourcePackageName</strong></p>

<p>Type: string
By default, AndroidAnnotations try to find the R class by extracting application package from AndroidManifest.xml file. But in some cases you may want to specify a custom package to look for the R class. This is why we added resourcePackageName option.</p></blockquote>

<p>결론은 아래처럼 resourcePackageName에 기존 packageName을 넣어줌으로써 해결이 가능하다.</p>

<pre><code>apt {
    arguments {
        resourcePackageName "net.yourdomain"
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle DSL method not found: 'packageNameSuffix()' 오류 해결]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix/"/>
    <updated>2015-10-05T08:13:08+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix</id>
    <content type="html"><![CDATA[<p>안드로이드에서 빌드시 packageName을 동적으로 변경하기 위해 packageNameSuffix를 사용하는 경우가 있다. 예를들어 배포된 앱과 개발중인 앱을 동시에 사용하기 위해 packageNameSuffix를 사용할 수 있다.</p>

<p>아래의 예시를 보자.</p>

<pre><code>android {
    buildTypes {
        debug {
            packageNameSuffix '.debug'
            versionNameSuffix '-debug'
        }
    }
}
</code></pre>

<p>debug 모드에서 빌드할 경우에는 packageName 뒤에 <code>.debug</code>를 붙이도록 설정한 것이다. 이렇게 함으로써 release와 debug가 packageName이 달라져서 두개의 앱으로 인식되므로 모두를 설치할 수 있다.
이 방법을 모를때는 매번 앱을 지우고 새로 깔고&hellip; 귀찮은 작업을 반복하며 작업을 했었다.</p>

<p>그런데 이렇게 사용하면 아래의 경우를 만날 수 있다.</p>

<pre><code> Gradle sync failed: Gradle DSL method not found: 'packageNameSuffix()'
            Consult IDE log for more details (Help | Show Log)
</code></pre>

<p>이유는 packageNameSuffix라는 속성이 applicationIdSuffix로 변경되었기 때문이다. 관련 메뉴얼은 <a href="http://tools.android.com/tech-docs/new-build-system/applicationid-vs-packagename">ApplicationId versus PackageName</a>에서 볼 수 있다.</p>

<p>그래서 아래와 같이 수정하면 정상적으로 사용이 가능하다.</p>

<pre><code>android {
    buildTypes {
        debug {
            applicationIdSuffix '.debug'
            versionNameSuffix '-debug'
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
