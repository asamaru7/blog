<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-10-13T15:04:56+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[안드로이드 TabLayout 사용시 Tab Text가 두줄로 나오는 문제 해결]]></title>
    <link href="http://blog.asamaru.net/2015/10/13/remove-line-break-in-tablayout/"/>
    <updated>2015-10-13T11:35:54+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/13/remove-line-break-in-tablayout</id>
    <content type="html"><![CDATA[<p>TabLayout에 대한 사용법은 <a href="https://guides.codepath.com/android/Google-Play-Style-Tabs-using-TabLayout">Google Play Style Tabs using TabLayout</a>에 잘 나와 있으므로 생략한다.</p>

<p>안드로이드의 TabLayout 사용시 Tab 안의 Text가 두줄로 나오는 문제가 있다. 정확하게 이야기하자면 Desigon Support Library 23.0.1 미만에서 문제가 있다(자세한 내용은 아래에서 설명한다). 예를들어 아래와 같은 경우다.</p>

<p><img src="/img/2015-10-13-remove-line-break-in-tablayout-1.png" alt="Remove line break in TabLayou"></p>

<p>위 이미지는 <a href="http://stackoverflow.com/questions/31698756/remove-line-break-in-tablayout">Remove line break in TabLayout</a>에서 질문을 위해 올린 이미지인데 새로 캡춰해서 넣기 귀찮아서 복사해 왔다. 이 글에서도 동일한 문제에 대해 질문하고 있는데 이 문제는 <code>app:tabMode=&quot;fixed&quot;</code>를 사용할 때 발생한다. 당연히 <code>app:tabMode=&quot;scrollable&quot;</code>를 사용하면 해결될 수 있는 문제이지만 Text가 짧으면 가로 사이즈에 맞춰서 fit하고 싶을 경우는 무조건 scrollable을 사용할 순 없는 것이다. 이 질문에 대한 답변에 보면 <a href="https://developer.android.com/intl/ru/reference/android/support/design/widget/TabLayout.Tab.html#setCustomView%28android.view.View%29">setCustomView (View view)</a>를 사용하는 방법을 안내하고 있다. 그냥 글자를 한줄로 나오게만 하고 싶은 것이라면 이 방법을 사용하는 것도 해결 방법이 될 수 있지만 fixed와 scrollable을 선택적으로 사용하는 것에는 사용될 수 없다(사실 그런 기능은 원래 없다).</p>

<p>다시 정리하자면 Tab의 개수나 Tab의 Text의 길이가 유동적인 경우에 들어갈 수 있는 공간이 충분하다면 fixed를 사용하고 길다면 scrollable을 사용하고 싶은 경우에는 어떻게 해야할까? 이 문제를 해결해주는 오픈소스 <a href="https://github.com/h6ah4i/android-tablayouthelper">android-tablayouthelper</a>가 있다.</p>

<p><a href="https://github.com/h6ah4i/android-tablayouthelper">android-tablayouthelper</a>를 사용하면 Tab 들의 길이에 맞춰서 fixed와 scrollable을 자동 변경해 준다.</p>

<p>그런데 여기서도 문제가 있다. 이 라이브러리에서는 Tab의 길이를 내부적으로 계산해서 fixed와 scrollable를 선택해 주는데 fixed일때와 scrollable일때 가로 사이즈가 차이가 날 수 있다(내부적으로 스타일이 약간 다르게 지정되는 것으로 보인다). 특히 Tab의 Text가 여러줄이 될 수 있도록 되어 있으면 문제가 더 심하게 나타난다(경험적으로). 이 문제를 개선하려면 Tab의 Text를 무조건 한줄로 나오게 하면 된다. 아래의 예시를 보자.</p>

<p><code>xml layout.xml
&lt;android.support.design.widget.TabLayout
        android:id=&quot;@+id/tabs&quot;
        style=&quot;@style/MyCustomTabLayout&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;
&lt;/android.support.design.widget.TabLayout&gt;
</code></p>

<p><code>xml styles.xml
&lt;style name=&quot;MyCustomTabLayout&quot; parent=&quot;Widget.Design.TabLayout&quot;&gt;
    &lt;item name=&quot;tabTextAppearance&quot;&gt;@style/MyCustomTabTextAppearance&lt;/item&gt;
&lt;/style&gt;
&lt;style name=&quot;MyCustomTabTextAppearance&quot; parent=&quot;TextAppearance.Design.Tab&quot;&gt;
    &lt;item name=&quot;android:singleLine&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:maxLines&quot;&gt;1&lt;/item&gt;
&lt;/style&gt;
</code></p>

<p>위 방법으로 Tab의 Text를 1줄로 표시할 수 있다. 그런데 이 부분에 또 문제가 있다. Desigon Support Library 23.0.1 미만에서는 maxLines가 적용되지 않는다. 이유는 <a href="https://code.google.com/p/android/issues/detail?id=175516">TabLayout hard codes maxLines to 2</a>를 보면 알 수 있다. 예전 버전에서는 TabLayout 소스 코드에 MAX_TAB_TEXT_LINES가 상수로 2로 선언되어 있었다. 내용에 보면 v22.2.1에 수정되었다고 했다가 해결되지 않았고 v23.0.1에서 반영되었다. v23.0.1에서 해결된 것은 직접 확인했다. 관련된 부분이 필요해서 기존에 프로젝트에서 tablayouthelper를 상속받아 직접 처리 했었던 부분을 제거하고 정상 동작하는 것을 확인했다.</p>

<p>매번 이야기하는 것이지만 안드로이드는 정말 너무 엉망이다. 이런 문제들을 너무 많이 봤다.</p>

<p><strong>결론은 Desigon Support Library 23.0.1 이상을 사용한다면 문제들을 해결할 수 있다.</strong></p>

<p>자 마지막으로 한가지만 더 설명하겠다. 위의 예시는 TabLayout을 layout xml에서 직접 사용할 때 처리하는 방법이다. 그렇다면 소스 코드에서 TabLayout 인스턴스를 만들어야 할 경우는 어떻게 style을 적용할까? 현재 시점에서는 기본적으론 방법이 없다. 아래의 코드를 보자.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TabLayout</span> <span class="n">tabLayout</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TabLayout</span><span class="o">(</span><span class="n">getContext</span><span class="o">());</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">TabLayout</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;mTabTextAppearance&quot;</span><span class="o">);</span>
    <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="n">field</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">tabLayout</span><span class="o">,</span> <span class="n">R</span><span class="o">.</span><span class="na">style</span><span class="o">.</span><span class="na">MyCustomTabTextAppearance</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>그렇다 직접 지정할 방법이 없어서 reflection을 사용했다. 정말 이렇게까지 하고 싶지는 않아서 다른 방법들을 찾아봤지만 아직은 발견하지 못했다.</p>

<p>다만, 안드로이드 메뉴얼 중 <a href="http://developer.android.com/intl/ru/reference/android/view/View.html#View%28android.content.Context,%20android.util.AttributeSet,%20int,%20int%29">View</a>를 보면 <code>int defStyleRes</code>를 네번째 인자로 가지는 생성자가 있는 것을 발견했다. 단, api 21 이후부터 추가된 생성자다. 예상하기론 defStyleRes를 지정할 수 있으면 MyCustomTabLayout를 지정해서 소스 코드에서도 스타일을 지정할 수 있을 것 같긴한데 TabLayout은 <code>public TabLayout (Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)</code> 생성자를 제공하지 않는다(v23.0.1 기준).</p>

<p>TabLayout의 <code>public TabLayout(Context context, AttributeSet attrs, int defStyleAttr)</code> 생성자에 있는 내용을 보면 아래의 코드가 있다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TypedArray</span> <span class="n">a</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">obtainStyledAttributes</span><span class="o">(</span><span class="n">attrs</span><span class="o">,</span> <span class="n">styleable</span><span class="o">.</span><span class="na">TabLayout</span><span class="o">,</span> <span class="n">defStyleAttr</span><span class="o">,</span> <span class="n">style</span><span class="o">.</span><span class="na">Widget_Design_TabLayout</span><span class="o">);</span>
</code></pre></div>
<p>여기서 <code>style.Widget_Design_TabLayout</code> 대신 defStyleRes를 넘겨받아 넣어주도록만 해줘도 가능할 것 같은데 아직은 지원하지 않는 것이다.</p>

<p>어쨌든 현재 시점을 기준으로 해결 방법은 위의 예시처럼 reflection을 사용하는 방법뿐이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java.lang.IllegalStateException: Recursive entry to executePendingTransactions 오류]]></title>
    <link href="http://blog.asamaru.net/2015/10/12/java-dot-lang-dot-illegalstateexception-recursive-entry-to-executependingtransactions/"/>
    <updated>2015-10-12T12:07:06+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/12/java-dot-lang-dot-illegalstateexception-recursive-entry-to-executependingtransactions</id>
    <content type="html"><![CDATA[<p>안드로이드 작업중 <code>java.lang.IllegalStateException: Recursive entry to executePendingTransactions</code> 오류를 만났다. 오류가 발생한 상황은 다음과 같다.</p>

<p>작업중 Fragment에서 하위에 또 다른 Fragment를 추가할 일이 생겼다. 이 작업 중에 하위에 추가되는 Fragment에서 <code>executePendingTransactions()</code> 함수를 호출하니 위 오류가 발생했다. 이해를 위해 처리 과정 중 문제가 발생한 부분만 적는다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">FragmentManager</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">getActivity</span><span class="o">().</span><span class="na">getSupportFragmentManager</span><span class="o">();</span>
<span class="n">ft</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">()</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">fragmentContainer</span><span class="o">,</span> <span class="o">(</span><span class="n">Fragment</span><span class="o">)</span> <span class="n">fragment</span><span class="o">)</span>
        <span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="n">ft</span><span class="o">.</span><span class="na">executePendingTransactions</span><span class="o">();</span>
</code></pre></div>
<p>FragmentManager를 얻기 위해 현재 Fragment의 Activity를 가져와 <code>getSupportFragmentManager()</code>를 사용했다. 이 부분이 문제가 생기는 이유다. 이런 경우는 아래와 같이 처리할 수 있다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">FragmentManager</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">getChildFragmentManager</span><span class="o">();</span>
<span class="n">ft</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">()</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">fragmentContainer</span><span class="o">,</span> <span class="o">(</span><span class="n">Fragment</span><span class="o">)</span> <span class="n">fragment</span><span class="o">)</span>
        <span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="n">ft</span><span class="o">.</span><span class="na">executePendingTransactions</span><span class="o">();</span>
</code></pre></div>
<p><code>getChildFragmentManager()</code>를 사용해서 FragmentManager를 얻어서 처리하면 위 오류는 발생하지 않는다.</p>

<p>이와 관련된 설명은 <a href="http://developer.android.com/intl/ru/about/versions/android-4.2.html#NestedFragments">Nested Fragments</a>를 보면 된다. 4.2에 변경된 내용으로 나와 있지만 support library를 사용한다면 하위 호환이 가능한 상황이라 문제되지 않는다.</p>

<p>추가적으로 <a href="http://developer.android.com/intl/ko/reference/android/app/FragmentManager.html#executePendingTransactions%28%29">public abstract boolean executePendingTransactions()</a>에 대해서 궁금하다면 <a href="http://developer.android.com/intl/ko/guide/components/fragments.html#Transactions">프래그먼트 트랜잭션 수행</a>)를 참고하면 된다.</p>

<blockquote>
<p>commit()을 호출해도 그 즉시 트랜잭션을 수행하지는 않습니다. 그보다는, 액티비티의 UI 스레드(&quot;주요&quot; 스레드)를 스레드가 할 수 있는 한 빨리 이 트랜잭션을 수행하도록 일정을 예약하는 것에 가깝습니다. 하지만 필요한 경우 UI 스레드로부터 executePendingTransactions()를 호출하면 commit()이 제출한 트랜잭션을 즉시 실행할 수 있습니다. 트랜잭션이 다른 스레드의 작업에 대한 종속성이 아니라면 굳이 이렇게 해야만 하는 것은 아닙니다.</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드에서 인턴트 호출시 Intent.FLAG_ACTIVITY_CLEAR_TOP 또는 Intent.FLAG_ACTIVITY_SINGLE_TOP 사용시 Androidannotations @Extra가 동작하지 않는 문제]]></title>
    <link href="http://blog.asamaru.net/2015/10/12/androidannotations-at-extra-with-intent-dot-flag-activity-clear-top-or-intent-dot-flag-activity-single-top/"/>
    <updated>2015-10-12T10:14:56+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/12/androidannotations-at-extra-with-intent-dot-flag-activity-clear-top-or-intent-dot-flag-activity-single-top</id>
    <content type="html"><![CDATA[<p><a href="http://androidannotations.org/">Androidannotations</a>를 사용하면 <code>@Extra</code>를 사용해서 인자를 받을 수 있다. 그런데 여기서 주의할 점이 있다. 인턴트 호출시 <code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code> 또는 <code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>를 사용하게되면 인턴트가 이미 존재할 경우 <code>@Extra</code>가 동작하지 않는다. 이와 관련해서 <a href="https://github.com/excilys/androidannotations/issues/1578">Always call #onNewIntent(), even without @AfterExtras method(s)</a>에서도 이슈가 진행중이다. 앞서 이야기한 문제와 이 이슈는 정확하게 같은 내용은 아니지만 동일한 이유로 발생하며 유사한 내용이라고도 볼 수 있다.</p>

<p>간단히 요약하자면 <code>@Extra</code>는 관련 처리를 <code>setIntent()</code>와 <code>onCraete()</code>에서 하는데 <code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code> 또는 <code>Intent.FLAG_ACTIVITY_SINGLE_TOP</code>를 사용하게되면 인턴트가 존재할 경우 두 함수가 실행되지 않는다는 것이다(<code>onCraete()</code> 대신에 <code>onNewIntent(Intent intent)</code>가 호출이 되고 그 다음 onResume() 이 호출이 된다).</p>

<p>현재까지는 <a href="http://androidannotations.org/">Androidannotations</a>에서 해당 문제를 해결하지 않았으므로 그에 따른 대응이 필요하다(Androidannotations을 사용하지 않는 상황이라면 <code>onResume</code>에서 extra 값을 받아오도록 하면 당연히 문제가 없다).</p>

<p>현재로써는 특별한 방법이 없어 아래와 같이 <code>onNewIntent()</code>애서 직접 값을 받도록 처리했다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onNewIntent</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onNewIntent</span><span class="o">(</span><span class="n">intent</span><span class="o">);</span>
    <span class="n">moveOwnLocation</span> <span class="o">=</span> <span class="n">intent</span><span class="o">.</span><span class="na">getBooleanExtra</span><span class="o">(</span><span class="s">&quot;EXTRA_NAME&quot;</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>하지만 이렇게 한다면 <code>@Extra</code>를 사용하는 의미가 없고 <code>@AfterExtras</code>도 정상적으로 사용할 수 없으므로 패치를 기다렸다가 코드를 다시 처리 해야할 것 같다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Play services 와 DEX method limits 문제]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/google-play-services-and-dex-method-limits/"/>
    <updated>2015-10-05T20:49:03+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/google-play-services-and-dex-method-limits</id>
    <content type="html"><![CDATA[<p><a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>에서 잠시 언급했던 multidex와 <a href="https://developers.google.com/android/guides/overview">Google Play services</a>와의 관계에 대해서 잠시 이야기 하고자 한다. 그 당시에도 설명했던 것과 같이 multidex를 사용해야 하는 상황은 가급적 피하는 것이 좋다. 하지만 오래된 버전의 Google Play services를 사용하면 65K이상의 method를 사용하게될 확률이 높다. 이 라이브러리에서 사용하고 있는 method의 수가 상당하기 때문에 proguard를 통해 사용하지 않는 함수를 제거하지 않는 이상 65K개를 넘어설 확률이 높은 것이다(대부분 여러가지 라이브러리를 사용해서 앱을 개발하므로). 문제는 proguard를 적용하게되면 빌드 시간이 증가하기 때문에 작업시 불편하다. <a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>에서 언급 했던 내용들을 적용한다면 상당한 속도 향상을 가져올 수 있지만 그래도 1초라도 시간을 줄이는 것이 좋지 않은가? 하루에 한번만 빌드할 것도 아닌데.</p>

<p>이와 관련해서는 <a href="http://android-developers.blogspot.kr/2014/12/google-play-services-and-dex-method.html">Google Play services and DEX method limits</a>라는 글에 잘 설명하고 있다.</p>

<p>Google Play services의 버전을 6.5(2015.10.05. 기준 8.1이 최신) 이상 사용한다면 아래와 같이 필요한 부분만 적용함으로써 이 문제를 어느 정도 해결할 수 있다(6.5 미만에서는 무조건 통째로 불러서 사용할 수 밖에 없다).</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// 기존
compile &#39;com.google.android.gms:play-services:6.5.87&#39;

// 6.5 이후
compile &#39;com.google.android.gms:play-services-maps:6.5.87&#39;
compile &#39;com.google.android.gms:play-services-base:6.5.87&#39;
</code></pre></div>
<p><a href="https://developers.google.com/android/guides/setup">Setting Up Google Play Services</a> 문서를 참고하면 사용할 수 있는 전체 목록을 확인할 수 있다. 아래는 현재 기준 목록이다.</p>

<table><thead>
<tr>
<th>Google Play services API</th>
<th>Description in build.gradle</th>
</tr>
</thead><tbody>
<tr>
<td>Google+</td>
<td>com.google.android.gms:play-services-plus:8.1.0</td>
</tr>
<tr>
<td>Google Account Login</td>
<td>com.google.android.gms:play-services-identity:8.1.0</td>
</tr>
<tr>
<td>Google Actions, Base Client Library</td>
<td>com.google.android.gms:play-services-base:8.1.0</td>
</tr>
<tr>
<td>Google App Indexing</td>
<td>com.google.android.gms:play-services-appindexing:8.1.0</td>
</tr>
<tr>
<td>Google App Invites</td>
<td>com.google.android.gms:play-services-appinvite:8.1.0</td>
</tr>
<tr>
<td>Google Analytics</td>
<td>com.google.android.gms:play-services-analytics:8.1.0</td>
</tr>
<tr>
<td>Google Cast</td>
<td>com.google.android.gms:play-services-cast:8.1.0</td>
</tr>
<tr>
<td>Google Cloud Messaging</td>
<td>com.google.android.gms:play-services-gcm:8.1.0</td>
</tr>
<tr>
<td>Google Drive</td>
<td>com.google.android.gms:play-services-drive:8.1.0</td>
</tr>
<tr>
<td>Google Fit</td>
<td>com.google.android.gms:play-services-fitness:8.1.0</td>
</tr>
<tr>
<td>Google Location, Activity Recognition, and Places</td>
<td>com.google.android.gms:play-services-location:8.1.0</td>
</tr>
<tr>
<td>Google Maps</td>
<td>com.google.android.gms:play-services-maps:8.1.0</td>
</tr>
<tr>
<td>Google Mobile Ads</td>
<td>com.google.android.gms:play-services-ads:8.1.0</td>
</tr>
<tr>
<td>Mobile Vision</td>
<td>com.google.android.gms:play-services-vision:8.1.0</td>
</tr>
<tr>
<td>Google Nearby</td>
<td>com.google.android.gms:play-services-nearby:8.1.0</td>
</tr>
<tr>
<td>Google Panorama Viewer</td>
<td>com.google.android.gms:play-services-panorama:8.1.0</td>
</tr>
<tr>
<td>Google Play Game services</td>
<td>com.google.android.gms:play-services-games:8.1.0</td>
</tr>
<tr>
<td>SafetyNet</td>
<td>c m.google.android.gms:play-services-safetynet:8.1.0</td>
</tr>
<tr>
<td>Google Wallet</td>
<td>com.google.android.gms:play-services-wallet:8.1.0</td>
</tr>
<tr>
<td>Android Wear</td>
<td>com.google.android.gms:play-services-wearable:8.1.0</td>
</tr>
</tbody></table>

<p>어쨌든 java라는 언어의 특성상 method의 수가 많을 수 밖에 없는데 65K limit은 최초의 설계부터 잘못된 것이 아닌가? 하는 생각이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle applicationIdSuffix 사용시 AndroidAnnotations 설정]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/using-applicationidsuffix-with-androidannotations/"/>
    <updated>2015-10-05T10:05:11+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/using-applicationidsuffix-with-androidannotations</id>
    <content type="html"><![CDATA[<p><a href="/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix/">Gradle DSL method not found: &#39;packageNameSuffix()&#39; 오류 해결</a>에서 오류 해결 방법을 안내하면서 언급했던 applicationIdSuffix를 사용시 유의사항이 있다. <strong>applicationId가 debug 모드에서 변경됨에 따라 관련된 부분에서 문제가 일어날 수 있다는 것이다.</strong></p>

<p>나의 경우는 AndroidAnnotations을 함께 사용하는 부분에서 오류를 만났다. AndroidAnnotations에서 applicationId를 기준으로 resource에 접근해서 자동 생성된 class들을 찾지 못하는 문제이다.</p>

<p>이런 경우에 대비해서 AndroidAnnotations에는 resourcePackageName라는 속성을 제공한다.</p>

<p><a href="https://github.com/excilys/androidannotations/wiki/CustomizeAnnotationProcessing">CustomizeAnnotationProcessing</a>에 보면 아래와 같이 안내되어 있다.</p>

<blockquote>
<p><strong>resourcePackageName</strong></p>

<p>Type: string
By default, AndroidAnnotations try to find the R class by extracting application package from AndroidManifest.xml file. But in some cases you may want to specify a custom package to look for the R class. This is why we added resourcePackageName option.</p>
</blockquote>

<p>결론은 아래처럼 resourcePackageName에 기존 packageName을 넣어줌으로써 해결이 가능하다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">apt {
    arguments {
        resourcePackageName &quot;net.yourdomain&quot;
    }
}
</code></pre></div>]]></content>
  </entry>
  
</feed>
