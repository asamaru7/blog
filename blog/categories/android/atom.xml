<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-10-05T10:16:04+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gradle applicationIdSuffix 사용시 AndroidAnnotations 설정]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/using-applicationidsuffix-with-androidannotations/"/>
    <updated>2015-10-05T10:05:11+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/using-applicationidsuffix-with-androidannotations</id>
    <content type="html"><![CDATA[<p><a href="/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix/">Gradle DSL method not found: &lsquo;packageNameSuffix()&rsquo; 오류 해결</a>에서 오류 해결 방법을 안내하면서 언급했던 applicationIdSuffix를 사용시 유의사항이 있다. <strong>applicationId가 debug 모드에서 변경됨에 따라 관련된 부분에서 문제가 일어날 수 있다는 것이다.</strong></p>

<p>나의 경우는 AndroidAnnotations을 함께 사용하는 부분에서 오류를 만났다. AndroidAnnotations에서 applicationId를 기준으로 resource에 접근해서 자동 생성된 class들을 찾지 못하는 문제이다.</p>

<p>이런 경우에 대비해서 AndroidAnnotations에는 resourcePackageName라는 속성을 제공한다.</p>

<p><a href="https://github.com/excilys/androidannotations/wiki/CustomizeAnnotationProcessing">CustomizeAnnotationProcessing</a>에 보면 아래와 같이 안내되어 있다.</p>

<blockquote><p><strong>resourcePackageName</strong></p>

<p>Type: string
By default, AndroidAnnotations try to find the R class by extracting application package from AndroidManifest.xml file. But in some cases you may want to specify a custom package to look for the R class. This is why we added resourcePackageName option.</p></blockquote>

<p>결론은 아래처럼 resourcePackageName에 기존 packageName을 넣어줌으로써 해결이 가능하다.</p>

<pre><code>apt {
    arguments {
        resourcePackageName "net.yourdomain"
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle DSL method not found: 'packageNameSuffix()' 오류 해결]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix/"/>
    <updated>2015-10-05T08:13:08+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix</id>
    <content type="html"><![CDATA[<p>안드로이드에서 빌드시 packageName을 동적으로 변경하기 위해 packageNameSuffix를 사용하는 경우가 있다. 예를들어 배포된 앱과 개발중인 앱을 동시에 사용하기 위해 packageNameSuffix를 사용할 수 있다.</p>

<p>아래의 예시를 보자.</p>

<pre><code>android {
    buildTypes {
        debug {
            packageNameSuffix '.debug'
            versionNameSuffix '-debug'
        }
    }
}
</code></pre>

<p>debug 모드에서 빌드할 경우에는 packageName 뒤에 <code>.debug</code>를 붙이도록 설정한 것이다. 이렇게 함으로써 release와 debug가 packageName이 달라져서 두개의 앱으로 인식되므로 모두를 설치할 수 있다.
이 방법을 모를때는 매번 앱을 지우고 새로 깔고&hellip; 귀찮은 작업을 반복하며 작업을 했었다.</p>

<p>그런데 이렇게 사용하면 아래의 경우를 만날 수 있다.</p>

<pre><code> Gradle sync failed: Gradle DSL method not found: 'packageNameSuffix()'
            Consult IDE log for more details (Help | Show Log)
</code></pre>

<p>이유는 packageNameSuffix라는 속성이 applicationIdSuffix로 변경되었기 때문이다. 관련 메뉴얼은 <a href="http://tools.android.com/tech-docs/new-build-system/applicationid-vs-packagename">ApplicationId versus PackageName</a>에서 볼 수 있다.</p>

<p>그래서 아래와 같이 수정하면 정상적으로 사용이 가능하다.</p>

<pre><code>android {
    buildTypes {
        debug {
            applicationIdSuffix '.debug'
            versionNameSuffix '-debug'
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACRA : Please configure 'buildConfigClass' in your ACRA config 오류]]></title>
    <link href="http://blog.asamaru.net/2015/10/01/android-acra-please-configure-buildconfigclass-in-your-acra-config/"/>
    <updated>2015-10-01T19:48:09+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/01/android-acra-please-configure-buildconfigclass-in-your-acra-config</id>
    <content type="html"><![CDATA[<p><a href="/2015/09/25/android-6-apache-http-client-removal/">Android 6(API 23 : marshmallow) : Apache HTTP 클라이언트 제거</a> 포스트에서 언급했던 것처럼 개발 중인 앱에서 Crash Report를 위해 <a href="https://github.com/ACRA/acra">ACRA</a>를 사용중이다. 아직 4.7.0으로 정식 버전업이 되지는 않았지만 4.7.0 RC1 버전이 maven에 올려져 있어서 적용해 보았다.
사실은 미리 적용할 예정은 없었으나 <a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>와 관련하여 Gradle을 2.4로 버전업 하면서 release 빌드 시에 다른 오류(setLatestEventInfo 함수가 제거됨)가 나타나서 어쩔 수 없이 버전업을 해야했다.</p>

<p>그런데 버전업을하고 나서 Crash 테스트를 하는 도중 또 다른 오류를 만났다. 기존에도 오류가 나고 있었는지 버전업 후의 문제인지는 확실치는 않다. 안드로이드 작업은 끝없는 오류 해결의 연속인 듯하다. 오류는 아래와 같다.</p>

<pre><code class="java">E/ACRA: Not adding buildConfig to log. Class Not found : net.yourdomain.BuildConfig. Please configure 'buildConfigClass' in your ACRA config
</code></pre>

<p>우선 ACRA를 초기화하는 코드를 살펴보자. 당연하지만 실제 적용코드가 아닌 부분적으로 정리된 코드다.</p>

<pre><code>ACRAConfiguration config = ACRA.getNewDefaultConfig(this);
config.setFormUri("http://dev.yourdomain.net/AppCrash");
ACRA.init(this, config); // The following line triggers the initialization of ACRA
</code></pre>

<p>@ReportsCrashes 어노테이션을 사용하지 않고 동적으로 초기화시켜주는 코드다. 실제로 Crash를 발생시키면 위에서 보여준 오류가 난다. 사실 이 문제는 원인을 확인한 결과 Proguard가 적용되었을 때만 오류가 발생한다. 아래의 ACRA 소스 코드의 일부를 보자.</p>

<p><strong><a href="https://github.com/ACRA/acra/blob/master/src/main/java/org/acra/collector/CrashReportDataFactory.java">CrashReportDataFactory.java</a></strong></p>

<pre><code class="java">private Class&lt;?&gt; getBuildConfigClass() throws ClassNotFoundException {
    final Class configuredBuildConfig = ACRA.getConfig().buildConfigClass();
    if ((configuredBuildConfig != null) &amp;&amp; !configuredBuildConfig.equals(Object.class)) {
        // If set via annotations or programatically then it will have a real value,
        // otherwise it will be Object.class (annotation default) or null (explicit programmatic).
        return configuredBuildConfig;
    }

    final String className = context.getClass().getPackage().getName() + ".BuildConfig";
    try {
        return Class.forName(className);
    } catch (ClassNotFoundException e) {
        ACRA.log.e(LOG_TAG, "Not adding buildConfig to log. Class Not found : " + className + ". Please configure 'buildConfigClass' in your ACRA config");
        throw e;
    }
}
</code></pre>

<p><code>final String className = context.getClass().getPackage().getName() + ".BuildConfig";</code> 이 부분을 보면 패키지명에 BuildConfig를 더해 Class를 찾고 있다. 이 부분이 문제다. Proguard에서 BuildConfig를 난독화해버려서 리플렉션으로 찾을 수 없는 것이다.
해결을 위한 아래의 코드를 보자.</p>

<pre><code class="java">ACRAConfiguration config = ACRA.getNewDefaultConfig(this);
config.setBuildConfigClass(BuildConfig.class);
config.setFormUri("http://dev.yourdomain.net/AppCrash");
ACRA.init(this, config); // The following line triggers the initialization of ACRA
</code></pre>

<p><code>config.setBuildConfigClass(BuildConfig.class);</code> 이 부분을 추가했다. ACRA 코드에서 보듯이 setBuildConfigClass로 직접 BuildConfig를 넘겨주면 패키지명으로 찾지 않는다. 따라서 Proguard가 적용되어도 문제가 없다.</p>

<hr />

<p>이 오류는 이것으로 해결이 가능하다. 하지만 나는 지금 다른 문제로 다시 고군분투 중이다.
오류 발생시 HTTP/POST를 통해 오류 관련 정보를 전송하도록 사용중이었다. 그런데 앞서 이야기 한것과 같이 이번에 버전업이 되면서 HTTP 접속 관련 부분이 변경되었다. 여기에 문제가 있다.</p>

<pre><code class="java">...
urlConnection.setChunkedStreamingMode(0);
...
</code></pre>

<p>위 부분은 ACRA에서 HTTP 전송시 사용하는 HttpRequest.java 의 일부분이다. <code>setChunkedStreamingMode</code>에 대해서는 여기서 설명하기엔 너무 길고 간단히 요약하자면 chunked 상태로 데이터가 전송된다.
그런데 이 상태로 전송되면 현재 내가 사용하고 있는 서버에서 POST 값이 모두 비어 있다. request의 body가 수신되지 못하는 것이다. 이 부분은 나의 환경인 php-fpm가 proxy로 연결되어 있는 것과 관련이 있는 것으로 보인다. 이 부분에 대해서는 여러가지로 시도해 보았으나 해결이 되지 않았고 일단은 몇개의 클래스를 재정의해서 문제를 막아 놓았다. 그리고 관련해서는 ACRA에 Issue로 등록해 두었다. 개선이 될런지는 미지수인데 안된다면 앞으로 사용상에 걸림돌이 될 것 같다. 이 부분에 관련된 해결책이 나온다면 다시 포스팅을 하도록 하겠다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 Geocoder 사용시 Service not Available 오류]]></title>
    <link href="http://blog.asamaru.net/2015/09/30/service-not-available-geocoder-android/"/>
    <updated>2015-09-30T16:15:20+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/30/service-not-available-geocoder-android</id>
    <content type="html"><![CDATA[<p>안드로이드에서 특정 지점의 좌표를 주소로 변환하는 것이 필요해서 Geocoder 사용했다. 대략적인 코드는 아래와 같다.</p>

<pre><code class="java">static abstract public class GeoCoderTask extends AsyncTask&lt;LatLng, Void, Address[]&gt; {
    @Override
    protected Address[] doInBackground(LatLng... arg0) {
        List&lt;Address&gt; res = new ArrayList&lt;&gt;();
        if (arg0.length &gt; 0) {
            try {
                Geocoder geocoder = new Geocoder(Helper.getAppContext(), Locale.KOREA);
                List&lt;android.location.Address&gt; addresses = geocoder.getFromLocation(arg0[0].latitude, arg0[0].longitude, 1);
                if ((addresses != null) &amp;&amp; (addresses.size() &gt; 0)) {
                    android.location.Address result = addresses.get(0);
                    Address resultAddress = new Address();
                    resultAddress.address = result.getAddressLine(0);
                    resultAddress.lat = result.getLatitude();
                    resultAddress.lng = result.getLongitude();
                    resultAddress.premise = result.getPremises();
                    resultAddress.administrative_area_level_1 = result.getAdminArea();
                    resultAddress.sublocality_level_1 = result.getSubLocality();
                    resultAddress.country = result.getCountryName();
                    resultAddress.postal_code = result.getPostalCode();
                    res.add(resultAddress);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        Address[] array = new Address[res.size()];
        res.toArray(array);
        return array;
    }
}
</code></pre>

<p>위 코드는 데이터를 다른 클래스로 넘겨서 반환하는 형태로 그대로 사용할 수는 없다. 그냥 이렇게 사용했다는 것을 보여주고자 넣은 코드니 참고만하기 바란다.</p>

<p>어쨌든 중요한 것은 잘 동작하던 코드가 테스트 기기에서 Service not Available 오류가 난다는 것이다. 테스트 기기는 nexus s에 4.0.4로 오래된 기기다. 처음엔 OS 버전 문제로 생각했다. 그래서 일단 검색해 봤다. 결론은 아래의 링크를 보고 해결했다.</p>

<p><a href="http://stackoverflow.com/a/13856839">Service not Available - Geocoder Android</a></p>

<p>해결 방법은 <strong>기기 재부팅</strong>. 어의없다. 정말 안드로이드는 정이 안간다.</p>

<p>사실 동일한 오류를 만났을 때 위의 방법으로 해결되지 않을 수 있다. 원인은 다양할 수 있으니&hellip; 그래서 조금 더 찾아보니 여러가지 이슈가 있는 것을 확인 했다. 해결되지 않는다면 구글에서 검색해 보면 여러가지 정보를 얻을 수 있다.</p>

<p>이러한 정보 중에서 한가지는 Geocoder를 사용하지 않고 웹으로 호출해서 결과를 받는 것이다. 사실 나의 경우는 오류 때문이 아니라 api 사용량 때문에 사용하던 코드(API 키를 전달하지 않는 코드로 사용량에 제한을 받지 않는 것으로 보임)였는데 참고할 사람이 있을까하고 남겨본다. 그리고 한가지. 조금 전에 API key를 전달하지 않는다고 했는데 기존에는 이 방법으로 정상 동작했다. 그런데 최근 WIFI에서는 이상이 없는데 LTE 상태에서는 api 한계량 초과라는 메시지를 반환하고 있어서 사용하고 있지 않다. 이 부분은 이유를 정확히 확인해보지 못했다.</p>

<pre><code class="java">static abstract public class WebGeoCoderTask extends AsyncTask&lt;LatLng, Void, Address[]&gt; {
    @Override
    final protected Address[] doInBackground(LatLng... arg0) {
        List&lt;Address&gt; res = new ArrayList&lt;&gt;();
        if (arg0.length &gt; 0) {
            String address = String.format(Locale.getDefault(), "https://maps.googleapis.com/maps/api/geocode/json?latlng=%1$f,%2$f&amp;sensor=false&amp;language=" + Locale.getDefault(), arg0[0].latitude, arg0[0].longitude);
            try {
                URL url = new URL(address);
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                InputStreamReader in = new InputStreamReader(conn.getInputStream());
                StringBuilder jsonResults = new StringBuilder();

                int read;
                char[] buff = new char[1024];
                while ((read = in.read(buff)) != -1) {
                    jsonResults.append(buff, 0, read);
                }
                String json = jsonResults.toString();
                JSONObject jsonObject = new JSONObject(json);
                AFLog.d(json);

                if ("OK".equalsIgnoreCase(jsonObject.getString("status"))) {
                    JSONArray results = jsonObject.getJSONArray("results");
                    if (results.length() &gt; 0) {
                        for (int i = 0, iCnt = results.length(); i &lt; iCnt; i++) {
                            try {
                                JSONObject result = results.getJSONObject(i);

                                Address resultAddress = new Address();
                                resultAddress.address = result.getString("formatted_address");
                                resultAddress.placeId = result.optString("place_id");
                                JSONObject geometry = result.optJSONObject("geometry");
                                if (geometry != null) {
                                    geometry = geometry.optJSONObject("location");
                                    if (geometry != null) {
                                        resultAddress.lat = geometry.getDouble("lat");
                                        resultAddress.lng = geometry.getDouble("lng");
                                    }
                                }

                                JSONArray components = result.getJSONArray("address_components");
                                for (int a = 0; a &lt; components.length(); a++) {
                                    JSONObject component = components.getJSONObject(a);
                                    JSONArray types = component.getJSONArray("types");
                                    for (int j = 0; j &lt; types.length(); j++) {
                                        String type = types.getString(j);
                                        switch (type) {
                                            case "premise":
                                                resultAddress.premise = component.optString("long_name");
                                                break;
                                            case "administrative_area_level_1":
                                                resultAddress.administrative_area_level_1 = component.optString("long_name");
                                                break;
                                            case "sublocality_level_1":
                                                resultAddress.sublocality_level_1 = component.optString("long_name");
                                                break;
                                            case "sublocality_level_2":
                                                resultAddress.sublocality_level_2 = component.optString("long_name");
                                                break;
                                            case "sublocality_level_3":
                                                resultAddress.sublocality_level_3 = component.optString("long_name");
                                                break;
                                            case "sublocality_level_4":
                                                resultAddress.sublocality_level_4 = component.optString("long_name");
                                                break;
                                            case "country":
                                                resultAddress.country = component.optString("long_name");
                                                break;
                                            case "postal_code":
                                                resultAddress.postal_code = component.optString("long_name");
                                                break;
                                            case "political":
                                            case "sublocality":
                                                break;
                                            default:
//                                                  AFLog.d("Not catched : " + type);
                                                break;
                                        }
                                    }
                                }
                                res.add(resultAddress);
                            } catch (JSONException e) {
                                AFLog.e(e);
                            }
                        }
                    }
                }
            } catch (Exception e) {
                AFLog.e(e);
            }
        }
        Address[] array = new Address[res.size()];
        res.toArray(array);
        return array;
    }
}
</code></pre>

<p>이 코드도 마찬가지로 참고만 하기 바란다. 내부적으로 사용중인 클래스들이 있어서 그대로 넣으면 동작하지 않는다. 하지만 코드를 보면 반환 클래스에 관련된 부분이므로 어디를 수정해야 할지 바로 알 수 있을 것으로 보인다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Gradle 빌드 속도 높이기]]></title>
    <link href="http://blog.asamaru.net/2015/09/29/android-gradle-builds-speed-up/"/>
    <updated>2015-09-29T09:26:25+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/29/android-gradle-builds-speed-up</id>
    <content type="html"><![CDATA[<p>안드로이드 개발을 하면서 여러가지 불만이 있지만 그중에 가장 맘에 들지않는 것 중 하나가 빌드 속도이다. 프로젝트의 규모에 따라 다르겠지만 xcode와의 빌드 시간을 비교하면 전체 빌드의 시간은 비슷한 것 같으나 수시로 하게되는 빌드는 안드로이드 스튜디오가 훨씬 느리게 느껴진다. 안드로이드 개발시 빌드에 사용되는 Gradle은 많은 유연성을 제공하지만 빌드에 많은 프로세스 비용이 든다는 것이 단점이다. 그래서 빌드 속도를 높일 수 있는 방법을 찾아서 적용해 보았다.</p>

<p>그리고 빌드 시간에 크게 영향을 주는 것 중에는 proguard와 multidex가 포함된다. proguard는 코드 최적화/난독화 등을 위한 처리이며 multidex는 65K이상의 메소드를 사용할 경우에 대한 대응책으로 사용되며 자세한 내용은 <a href="https://developer.android.com/intl/ko/tools/building/multidex.html">Building Apps with Over 65K Methods</a>에서 참고하면 된다. 메소드 수가 어떻게하면 65K를 넘나 싶을 수 있지만 금방 넘어선다. 라이브러리를 막 추가하다보면 금방 문제를 만나게 된다(proguard 등을 통해 메소드 수를 줄일 수 있다). 이 글에서도 나와있는 것이지만 빌드 속도 문제를 떠나서도 최대한 multidex를 사용하는 상황을 만들지 않는 것이 좋다. 그리고 나는 proguard를 항상 켜둔 상태도 개발을 하는 편이다. 프로젝트 막판에 proguard를 적용하게되면 proguard로 인한 여러가지 문제를 만날 수 있기 때문에 충돌을 미리 발견하기 위해서다. 하지만 이렇게하다보면 빌드 속도가 너무 떨어진다. 그래서 켰다가 껐다가 하긴하는데 너무 귀찮다.</p>

<p>그럼 본격적으로 설정을 시작해보자.</p>

<h2>1. gradle.properties 파일을 변경</h2>

<p>프로젝트 Root에 있는 gradle.properties을 편집한다. 기존에 파일이 없다면 추가한다. 여기에는 gradle 빌드 할 때 인수를 설정할 수 있다.
한가지 더 알려주자면 프로젝트별로 설정하는 것외에도 모든 프로젝트에 설정을 추가할 수도 있다. 해당 파일의 경로는 OSX 기준으로 <code>~/.gradle/gradle.properties</code> 이다. 윈도우나 리눅스도 비슷한 경로에 있을 것으로 생각된다.</p>

<p><strong>gradle.properties</strong></p>

<pre><code class="ini"># Project-wide Gradle settings.
# IDE (eg Android Studio) users :
# Settings specified in this file will override any Gradle settings
# configured through the IDE.
# For more details on how to configure your build environment visit
# http : // www.gradle.org/docs/current/userguide/build_environment.html
# The Gradle daemon aims to improve the startup and execution time of Gradle.
# When set to true the Gradle daemon is to run the build.
# TODO : disable daemon on CI, Since Builds should BE clean and Reliable on servers
org.gradle.daemon = true

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value : -Xmx10248m -XX : MaxPermSize = 256M
org.gradle.jvmargs = -Xmx2048m -XX : MaxPermSize = 512m -XX + HeapDumpOnOutOfMemoryError -Dfile.encoding = UTF-8

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec : decoupled_projects
org.gradle.parallel = true

# Enables new incubating mode that makes Gradle selective when configuring projects.
# Only relevant projects are configured which results in faster builds for large multi-projects.
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html #sec : configuration_on_demand
org.gradle.configureondemand = true
</code></pre>

<p>위 설정에 대한 간략한 설명은 아래와 같다.</p>

<ul>
<li><strong>org.gradle.daemon</strong> : 데몬 프로세스를 사용할지 여부 설정한다. true 설정시 gradle을 daemon 모드로 실행하여 빌드시 gradle을 다시 실행하는 시간을 줄여준다.</li>
<li><strong>org.gradle.jvmargs</strong> : 실행시 JVM 인수로 메모리를 설정을 늘려 메모리 부족으로 인한 속도저하를 막는 것이 목적이다. 따라서 적절한 양의 메모리를 할당해 주면 된다.</li>
<li><strong>org.gradle.parallel</strong> : gradle 병렬 빌드 모드를 설정한다. 여러 프로젝트를 빌드 할 때 효과가 있다.</li>
<li><strong>org.gradle.configureondemand</strong> : 관련 프로젝트가 있다면 필요한 부분만 빌드 설정한다.</li>
</ul>


<p>크게 성능이 향상되는 것 같지는 않지만 조금의 성능 향상은 있는 것 같다. 사실 다음에 소개할 gradle 버전 업이 훨씬 체감 성능 향상에 도움을 준다.</p>

<h2>2. Android Studio 1.3 / Gradle 2.4 이상 사용</h2>

<p>Android Studio 1.3 / Gradle 2.4 이상으로 버전업되면서 대폭 성능 향상이 있었다. 실제로 나의 경우엔 상당한 속도 향상이 있었다. 그래도 proguard를 적용하게되면 느리긴 마찬가지긴 하다.
구글의 설명을 보려면 <a href="https://www.youtube.com/watch?t=502&amp;v=f7ihSQ44WO0">Google I/O 2015 - What&rsquo;s New in Android Development Tools</a>을 참고하면 된다. 단, 주의할 것은 Android Studio 1.3 이상을 사용한다고 Gradle 2.4 이상을 무조건 사용하는 것은 아니라는 것이다. 신규 프로젝트가 아니어서 그런지 나의 프로젝트에서는 2.2.1을 그대로 사용하고 있었다(File > Project Structure > Project > Gradle version에서 2.4로 변경함으로써 적용할 수 있다).</p>

<h2>3. gradle를 오프라인 모드로 변경</h2>

<p>다른 사람들은 이 방법이 아주 효과적이었다고 하는데 나의 경우는 크게 차이가 나지 않았다(proguard로 인한 속도 저하라서 이 방법에 큰 도움이 되지 않았던 것 같다). 어쨌든 이 설정을 적용하면 gradle에서 매번 최신 버전을 확인하러가는 것을 생략 해 준다. 단, 신규 dependency를 추가하거나 변경하는 경우는 이 설정을 해제해야 한다. 약간은 귀찮을 수 있지만 dependency 변경은 크게 자주 발생하는 경우는 아니므로 문제되지 않을 것으로 생각된다.</p>

<p><img src="/img/2015-09-29-android-gradle-builds-speed-up-1.png" alt="Offline work" />
Android Studio> Preferences> Gradle 의 Offline work에 체크.</p>

<h2>4. <a href="http://kevinpelgrims.com/blog/2015/06/11/speeding-up-your-gradle-builds/">Speeding up Gradle builds</a></h2>

<p><a href="http://kevinpelgrims.com/blog/2015/06/11/speeding-up-your-gradle-builds/">Speeding up Gradle builds</a>에서는 몇가지 방법을 더 안내하고 있다. 간략하게 요약하면 아래와 같다(위의 설명들과 유사한 부분도 많다). 상세한 설명은 위 링크를 참조하기 바란다.</p>

<h3>Maven Central vs. JCenter</h3>

<p>mavenCentral() 대신 jcenter()를 사용해라.</p>

<h3>Get the latest version of Gradle</h3>

<p>최신 버전의 Gradle을 사용하라.</p>

<h3>Gradle properties</h3>

<p>아래의 Gradle properties를 적용하라(위의 설명이 더 상세하다).
<code>ini
org.gradle.parallel=true
org.gradle.daemon=true
org.gradle.jvmargs=-Xms256m -Xmx1024m
</code></p>

<h3>How to use Gradle properties</h3>

<p>Gradle properties를 프로젝트별로 설정하기보다 전역으로 설정하라.</p>

<h3>다중 모듈 빌드</h3>

<p>다중 모뮬을 사용하는 경우에 속도 향상 방법이 안내되어 있으니 필요한 경우에 원본글에 가서 참조 바란다.</p>
]]></content>
  </entry>
  
</feed>
