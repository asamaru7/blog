<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-08-28T06:29:02+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 6(API 23)의 getColor() Deprecated 대응 + getDrawable() Deprecated]]></title>
    <link href="http://blog.asamaru.net/2015/08/28/android-getcolor-getdrawable-deprecated/"/>
    <updated>2015-08-28T06:27:49+09:00</updated>
    <id>http://blog.asamaru.net/2015/08/28/android-getcolor-getdrawable-deprecated</id>
    <content type="html"><![CDATA[<p>얼마전 Android API 23 버전이 공개되었다. 이와함께 support library, design support library도 함께 23 버전으로 버전업 되었다.</p>

<p>이에따라 여러가지 UI들이 추가되어 필요한 부분을 적용해 보고자 gradle을 수정하고 build 하니 getColor 함수가 deprecated 되었다는 warning을 보게되었다.</p>

<p>아&hellip; 최근에 안드로이드는 기본 함수들을 너무 많이 바꾼다. 사실 이번 버전업으로 이것뿐아니라 http 관련된  api가 제거 되었다. 이미 이전부터 deprecated 되었었긴하지만 너무 갑작스럽기도 하다.
현재시점에서 ACRA, android-async-http 등의 오픈소스들도 대응이 되지 않았다. 이에 따른 대응방법도 구글에 안내되어 있긴하다.</p>

<p><a href="https://developer.android.com/intl/ko/preview/behavior-changes.html#behavior-apache-http-client">Apache HTTP 클라이언트 제거</a></p>

<p>하지만 임시방편일 뿐 계속 사용하기엔 석연치 않다. 조금더 자세한 내용은 다음에 다시 글을 쓰도록 하겠다.</p>

<p>다시 본론으로 돌아와서 이 부분을 해결하기 위해서는 ContextCompat(android.support.v4.content.ContextCompat)을 사용하면 된다.
단, support library 23 이상이 필요할 수 있다. 이하에서는 확인을 못했다.</p>

<p>함수는 아래와 같이 구성되어 있다.</p>

<pre><code class="java">public static final int getColor(Context context, int id) {
    final int version = Build.VERSION.SDK_INT;
    if (version &gt;= 23) {
        return ContextCompatApi23.getColor(context, id);
    } else {
        return context.getResources().getColor(id);
    }
}
</code></pre>

<p>실제사용은</p>

<pre><code class="java">ContextCompat.getColor(context, resourceId);
</code></pre>

<p>이렇게 하면된다. 어떻게보면 기존보다 더 편하다. 하지만 기존에 getColor를 사용하던 부분을 고치는 것은 우리가 해야한다.</p>

<p>추가로 보다 더 이전에 deprecated된 함수 getDrawable()가 있다. 이건 정확하지 않지만 API 21부터 deprecated 된 것 같다.
이 문제도 동일한 class를 통해 해결 가능하다.</p>

<pre><code class="java">public static final Drawable getDrawable(Context context, int id) {
    final int version = Build.VERSION.SDK_INT;
    if (version &gt;= 21) {
        return ContextCompatApi21.getDrawable(context, id);
    } else {
        return context.getResources().getDrawable(id);
    }
}
</code></pre>

<p>요즘 분위기를 보면 이런식으로 deprecated 되는 함수가 많다. 사실 개인적으로 많은 것은 기존 안드로이드가 워낙 엉망이라고 보기 때문에 문제가 되지 않는다고 생각하지만 처리하는 과정은 맘에 들이 않는다.
한번에 싹 정리하지 않고 눈에 띄면 추가하듯 띄엄띄엄 deprecated 함수를 늘리고 실제 제거까지 오래 기다리지 않는다. 이건 꼭 새로운 버전을 사용하지 말라고 권장하는 것도 아니고 쓰라는 것도 아니고&hellip;</p>

<p>마지막으로 PhoneNumberUtils.formatNumber 함수 예기만 하나더 하자면</p>

<pre><code class="java">public static String formatNumber(String source);
</code></pre>

<p>이 함수도 deprecated 되었다. 이제는 두번째 인자로 포멧팅할 국가 코드를 넣어야 한다.</p>

<pre><code class="java">PhoneNumberUtils.formatNumber(number, "KR");
</code></pre>

<p>그게 대응이 어려운 문제는 아니다. 하지만 위의 문제들과 더불어 굳이 deprecated 했어야 하는가? 하는 부분이다.
개인적인 생각으로 두번째 인자를 생략하면 기존처럼 국가코드를 자동으로 넣으면 되지 않는가? 일부 다국어 지원 앱에서 조금더 명확한 사용을 하기 위해 대다수의 단일국가 지원 앱들이 불편을 감수해야하는가?
다음이 기존함수이다.</p>

<pre><code class="java">@Deprecated
public static String formatNumber(String source) {
    SpannableStringBuilder text = new SpannableStringBuilder(source);
    formatNumber(text, getFormatTypeForLocale(Locale.getDefault()));
    return text.toString();
}
</code></pre>

<p>보다시피 <code>Locale.getDefault()</code> 부분을 넣어주고 있었다. 어쨌든 나는 아래와 같은 호환 함수를 만들어서 사용하고 있다.</p>

<pre><code class="java">static public String getFormattedPhoneNumber(String number) {
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
        return PhoneNumberUtils.formatNumber(number, "KR");
    } else {
        // noinspection deprecation
        return PhoneNumberUtils.formatNumber(number);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ViewPager를 직접 생성시 android.content.res.Resources$NotFoundException: Unable to Find Resource ID #0xffffffff 오류 발생]]></title>
    <link href="http://blog.asamaru.net/2015/08/27/android-viewpager-setid/"/>
    <updated>2015-08-27T10:56:56+09:00</updated>
    <id>http://blog.asamaru.net/2015/08/27/android-viewpager-setid</id>
    <content type="html"><![CDATA[<p>일반적으로 ViewPager 사용시 layout xml에서 정의해서 사용한다.
하지만 간혹 필요에 따라 ViewPager을 프로그램으로 생성해서 사용하는 경우 있다.</p>

<pre><code class="java">ViewPager viewPager = new ViewPager(this);
viewPager.setId(Helper.generateViewId());
</code></pre>

<p>그런데 이렇게 사용할 경우 아래와 같은 오류를 만나게 된다.</p>

<pre><code class="java">android.content.res.Resources$NotFoundException: Unable to find resource ID #0xffffffff
            at android.content.res.Resources.getResourceName(Resources.java:3216)
            at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1008)
            at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1197)
            at android.support.v4.app.BackStackRecord.run(BackStackRecord.java:738)
            at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:1562)
            at android.support.v4.app.FragmentManagerImpl.executePendingTransactions(FragmentManager.java:535)
            at android.support.v4.app.FragmentPagerAdapter.finishUpdate(FragmentPagerAdapter.java:141)
            at android.support.v4.view.ViewPager.populate(ViewPager.java:1106)
            at android.support.v4.view.ViewPager.populate(ViewPager.java:952)
            at android.support.v4.view.ViewPager.onMeasure(ViewPager.java:1474)
            at android.view.View.measure(View.java:18573)
...
</code></pre>

<p>처음엔 웬 리소스를 못 찾는다는 에러가 나오는지 한참을 헤맸다.
결국 알아낸 문제는 사실 개인적으로 조금 어이가 없었다. xml에서 정의된 ViewPager는 인스턴스화되면서 임시 id가 알아서 지정되는 것으로 보이나 프로그램에서 생성한 ViewPager는 그 과정이 누락되는 것이다.
어이없는 상황. 그러나 해결법은 간단하다. id를 지정해 주면 된다.</p>

<p>그래서 아래처럼 해봤다.</p>

<pre><code class="java">ViewPager viewPager = new ViewPager(this);
viewPager.setId(1);
</code></pre>

<p>하지만 그렇게 간단히 해결되면 안드로이드가 아니지&hellip;
그래서 다음과 같은 방법으로 id를 생성해 주어야 한다.</p>

<pre><code class="java">public class IdGen {
    final static private AtomicInteger sNextGeneratedId = new AtomicInteger(1);

    static private int _generateViewId() {
        for (; ; ) {
            final int result = sNextGeneratedId.get();
            // aapt-generated IDs have the high byte nonzero; clamp to the range under that.
            int newValue = result + 1;
            if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.
            if (sNextGeneratedId.compareAndSet(result, newValue)) {
                return result;
            }
        }
    }

    static public int generateViewId() {
        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR1) {
            return _generateViewId();
        } else {
            return View.generateViewId();
        }
    }
}
</code></pre>

<pre><code class="java">ViewPager viewPager = new ViewPager(this);
viewPager.setId(IdGen.generateViewId());
</code></pre>

<p>드디어 이상없이 동작한다.</p>
]]></content>
  </entry>
  
</feed>
