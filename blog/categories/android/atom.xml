<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-09-17T20:47:54+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PHP의 DateTime을 Java (Android)로 전달하기]]></title>
    <link href="http://blog.asamaru.net/2015/09/17/datetime-from-php-to-java-android/"/>
    <updated>2015-09-17T18:45:26+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/17/datetime-from-php-to-java-android</id>
    <content type="html"><![CDATA[<p>안드로이드 앱을 개발하게되면 많은 경우에 서버와의 데이터 연결이 필요하다. 대부분의 데이터 타입은 이 과정에서 큰 문제를 일으키지 않는다(데이터 타입만 명확히 한다면). 하지만 DateTime은 조금 까다로울 수 있다. 프로그램에서 시간은 TimeZone을 가지고 있기 때문에 이 부분을 명확히 하지 않으면 의도치 않은 시간으로 표시된다. 게다가 형식이 맞지 않는다면 제대로 전달되지 않을 수도 있다.</p>

<blockquote><p>네이버 D2에 있는 <a href="http://d2.naver.com/helloworld/645609">Java의 날짜와 시간 API</a>를 보면 Java에서의 Date 처리가 불편하다는 얘기가 있다.</p></blockquote>

<p>이번 작업에서는 서버는 PHP를 사용하고 있는 상황이었고 클라이언트는 <a href="http://androidannotations.org/">AndroidAnnotations</a>의 <a href="https://github.com/excilys/androidannotations/wiki/Rest-API#rest">Rest-API</a>를 사용했다. 수신 데이터의 파싱은 <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/json/GsonHttpMessageConverter.html">GsonHttpMessageConverter</a>를 사용하는 상황이다. 이 글의 주제에서 벗어나므로 <a href="http://androidannotations.org/">AndroidAnnotations</a>나 <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/json/GsonHttpMessageConverter.html">GsonHttpMessageConverter</a>에 대한 부분은 설명하지 않겠다.</p>

<p>GsonHttpMessageConverter를 사용해서 데이터를 파싱하는 경우 대상이되는 class의 멤버변수의 데이터 타입에 맞추어 데이터를 채워준다. 당연히 전송되는 데이터가 JSON 형식이어야 한다. 다른 데이터 타입의 경우 앞서 설명한 것과 같이 데이터 타입만 맞춰준다면 아주 쉽게 데이터를 받을 수 있다(그것이 이것을 사용하는 주요 목적이다). 그런데 DateTime 타입은 조금 신경을 써줘야 한다.</p>

<p>자 그럼 서버에서 데이터를 보낼 수 있는 방법에 어떤 것이 있을까? 가장 일반적인 방법으로는 timestamp(int), string, Date가 있다. 어떤 것을 쓰더라도 무방하지만 앞서 얘기한 것처럼 GsonHttpMessageConverter를 써서 간단히 데이터를 정확한 형식으로 받는 것이 편리하기 때문에 전송시 데이터 타입을 맞추는 것이 좋다.</p>

<pre><code class="php">// string 타입으로 전송
$date = "2015-09-17 10:00:00";
// int 타입으로 전송
$date = (new \DateTime("2015-09-17 10:00:00"))-&gt;getTimestamp();
// Date 타입으로 전송
$date = (new \DateTime("2015-09-17 10:00:00"))-&gt;setTimeZone(new \DateTimeZone('UTC'))-&gt;format('Y-m-d\TH:i:s\Z');
</code></pre>

<p>위의 코드를 보면 PHP에서 전송할 때 넘겨줄 데이터의 예시를 타입별로 제시했다. 앞서 강조했던대로 안드로이드 클라이언트에서 GsonHttpMessageConverter를 이용해 Date 타입으로 바로 받으려면 마지막에 있는 &ldquo;Date 타입으로 전송&rdquo; 방식을 사용하면 된다.</p>

<p>해당 부분을 보면 두가지 처리를 해주고 있다. 첫번째로 TimeZone을 설정한 것이고, 두번째로 Date Format을 지정한 것이다. 사실 이 부분들을 잘 몰라서 삽질을 조금 했었다. 처음엔 Date Format을 어떻게 전달해야할지 몰라 해맸다. 제대로 수신을 하지 못했던 것이다. Format을 맞추고 나니 이젠 보낸 시간과 받은 시간이 달랐다. 이 부분은 TimeZone의 문제이므로 TimeZone을 지정해서 해결했다. TimeZone에 사용한 UTC는 <a href="https://ko.wikipedia.org/wiki/%ED%98%91%EC%A0%95_%EC%84%B8%EA%B3%84%EC%8B%9C">협정 세계시</a>라는 뜻이다. 이것과 세트로 format에서 끝에 \Z를 붙여 데이터가 <a href="https://ko.wikipedia.org/wiki/ISO_8601">ISO 8601</a>에 따라 UTC를 따르고 있음을 표시한 것이다.</p>

<p>결론적으로 위의 형식을 사용하면 GSON으로 바로 받아도 정확한 시간을 사용할 수 있다.</p>

<p>사실 위의 경우는 GsonHttpMessageConverter를 사용한다는 상황을 가정한 것으로 이것을 사용하지 않고 직접 데이터를 받아 GSON을 통해 파싱한다면 아래의 방법을 쓸 수도 있다. Format을 보면 알겠지만 UTC Date여야 한다(정확한 시간 처리를 위해). &ldquo;yyyy-MM-dd HH:mm:ss"이 Format을 쓸 수도 있으나 TimeZone 명시되지 않으므로 시간이 다르게 보일 수 있다.</p>

<pre><code class="java">Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").create();
</code></pre>

<p>아래는 추가적으로 다른 타입으로 수신했을 때 안드로이드 클라이언트에서 Date 타입으로 변환하고자 할때 사용할 수 있는 참고 코드들이다.</p>

<p><strong> string 타입으로 수신시 </strong>
<code>java
try {
    String dateTime = "2015-09-17 10:00:00";
    SimpleDateFormat dateParser = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.KOREA);
    Date date = dateParser.parse(dateTime);
} catch (ParseException e) {
    e.printStackTrace();
}
</code></p>

<p><strong> timestamp(int) 타입으로 수신시 </strong></p>

<p>PHP에서의 TimeStamp는 초단위(s)지만 Java에서는 밀리초(ms) 단위이므로 1000을 곱해서 넣어 주어야 한다.
그리고 Java에서는 Date가 Deprecated되어 <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html">Calendar</a>를 더 권장한다고 한다. <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Date.html">정확하게는 완전히 Deprecated된 것은 아니고 일부 생성자가 그렇다는 것</a>이지만 <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html">Calendar</a>가 더 다양한 기능을 제공하므로 더 권장된다는 것이다. 자세한 이유는 검색해보면 많이 나온다.</p>

<pre><code class="java">// Calendar 사용
Calendar c = Calendar.getInstance();
c.setTimeInMillis(timestamp * 1000);
Date date = c.getTime();

// OR

// Date 사용
Date d = new Date(timestamp * 1000);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드에서 구글맵 사용시 맵의 보여지는 영역의 좌표를 원하는 pixel만큼 제외하고 가져오기]]></title>
    <link href="http://blog.asamaru.net/2015/09/17/android-google-map-getvisibleregion-toscreenlocation-toscreenlocation/"/>
    <updated>2015-09-17T14:18:50+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/17/android-google-map-getvisibleregion-toscreenlocation-toscreenlocation</id>
    <content type="html"><![CDATA[<p>이 글의 제목이 참 길고 어렵다. 나름대로 정하긴 했지만 어떻게 해야 내용을 설명할 수 있을지 잘 모르겠기에 그냥 필요한 상황을 차례로 적어보려 한다.</p>

<ol>
<li><p>안드로이드에서 구글맵을 사용하면서 현재 맵에서 보여지는 영역의 좌표를 얻고 싶을 때가 있다.
중심 좌표와 확대 비율은 center와 zoom을 통해 쉽게 구할 수 있다. 하지만 필요한 것은 보여지는 영역을 모두 포함하는 좌표들이다.
이 좌표들은 대부분 보여지는 화면 내부에 해당하는 데이터를 query 하기 위해서 사용될 것이다. 다른 경우도 당연히 있을 수 있고&hellip;</p></li>
<li><p>위의 목적대로 좌표를 가져오긴 했는데 일부 영역을 제외하고 싶을 때가 있다. 예를들어 지도 상단에 버튼들이 나열되어 있다고 가정할 때 이 영역은 query에서 제외하고 싶을 때가 해당된다. 이 문제는 간단하지가 않은게 버튼들이 차지하는 공간이야 pixel로 얼마든지 계산 가능하지만 이 pixel 사이즈를 좌표에 반영해야 원하는 값을 얻을 수 있기 때문이다.</p></li>
</ol>


<p>위의 상황들의 목적은 결국 하나다. 구글 지도에서 원하는 영역의 평면 좌표를 얻고 싶다는 것이다.</p>

<p>우선 해결 방법을 설명하기 전에 필요한 함수에 대한 설명부터 보자. 이 처리를 하기 위해 가장 중요한 요소는 Projection 이다.</p>

<h2><a href="https://developers.google.com/android/reference/com/google/android/gms/maps/Projection.html">Google APIs for Android - Projection</a></h2>

<p>위 링크를 참고하면 자세한 설명이 나와있지만 간단하게 필요한 것들에 대해서 정리하자면 다음과 같다.</p>

<h3>Projection</h3>

<blockquote><p>Projection은 화면상의 위치와 위경도 좌표(LatLng) 간의 변환하는데 사용된다. 그리고 화면의 위치는 항상 맵 화면의 좌상단(top left)을 기준으로 한다.</p></blockquote>

<h3>getVisibleRegion()</h3>

<pre><code class="java">public VisibleRegion getVisibleRegion ()
</code></pre>

<blockquote><p>화면상의 좌표와 위경도 좌표 간의 변환을 위한 Projection을 가져온다.</p></blockquote>

<h3>toScreenLocation (LatLng location)</h3>

<pre><code class="java">public Point toScreenLocation (LatLng location)
</code></pre>

<blockquote><p>인자로 넘겨준 위경도 좌표가 화면 상에서 어디에 위치하는지를 Point 객체로 반환해 준다. 반환되는 단위는 화면 상의 Pixel(화소가 아닌)이다.</p></blockquote>

<h3>fromScreenLocation (Point point)</h3>

<p>public LatLng fromScreenLocation (Point point)</p>

<blockquote><p>인자로 넘겨준 화면 상의 좌표에 해당하는 위경도를 LatLng 객체로 반환해 준다.</p></blockquote>

<h2>구현</h2>

<p>위와 같이 기본적인 함수들에 대해서 알아보았고 이제는 실제 사용 사례를 살펴보자.</p>

<p>아래는 서두에 얘기한 기능을 수행하게 하기 위해 만들어 본 함수이다.</p>

<pre><code class="java">public LatLngBounds getBoundsWithoutSpacing(int top, int right, int bottom, int left) {
    Projection projection = googleMap.getProjection();
    LatLngBounds bounds = projection.getVisibleRegion().latLngBounds;
    Point northeast = projection.toScreenLocation(bounds.northeast);
    Point toNortheast = new Point(northeast.x - right, northeast.y + top);
    Point southwest = projection.toScreenLocation(bounds.southwest);
    Point toSouthwest = new Point(southwest.x + left, southwest.y - bottom);

    LatLngBounds.Builder builder = new LatLngBounds.Builder();
    builder.include(projection.fromScreenLocation(toNortheast));
    builder.include(projection.fromScreenLocation(toSouthwest));
    return builder.build();
}
</code></pre>

<p>설명하자면 다음과 같다.</p>

<p>우선 googleMap 개체에서 Projection을 가져와서 VisibleRegion을 통해 좌표를 받아온다. 당연히 googleMap은 따로 구성되어 있어야 한다. 함수를 고쳐서 인자로 넘겨주어도 당연히 상관없다.
getVisibleRegion()에서 latLngBounds를 받아오면 위경도 좌표의 bound를 알 수 있는데 사용할 수 있는 값은 두가지다. northeast(북동좌표)와 southwest(서남좌표)다. 이 두점은 bound의 최외곽 좌표이므로 전체 박스 영역을 얻은 것이다.</p>

<p>1차적으로는 이 값을 바로 사용해서 원하는 영역에 대한 검색을 수행할 수 있다.</p>

<p>하지만 정말로 원하는 것은 두번째 문제이다. 이 좌표에서 화면의 특정 영역을 제외한 부분의 위경도 bound를 구하고 싶은 것이다.</p>

<p>원하는 결과를 얻기 위해 toScreenLocation() 함수를 이용해서 북동,서남 좌표를 화면 상의 좌표(Point)로 변환한다. 여기에 원하는 pixel만큼씩을 증감하여 fromScreenLocation() 함수를 통해 다시 위경도 좌표(LatLng)로 변환하면 최종적인 결과를 얻을 수 있다.</p>

<p>사실 결과를 보면 아주 간단한 작업이다. 하지만 이 함수들의 역할을 모를때는 어떻게 그 값을 구할 수 있을지 막막했다. 처음엔 구글의 zoom 레벨을 가져와서 pixel 비율을 계산하여 적용하려고 했으나 만만치 않았다.</p>

<p>결론은 위의 함수를 바탕으로 원하는 목적을 달성할 수 있으니 필요에 맞게 사용하면 된다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AsyncTask의 생성을 UIThread에서 하지 않으면 발생하는 문제 해결]]></title>
    <link href="http://blog.asamaru.net/2015/09/09/asynctask-init-problem/"/>
    <updated>2015-09-09T21:36:59+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/09/asynctask-init-problem</id>
    <content type="html"><![CDATA[<p>최근에 안드로이드의 앱 성능 개선에 관련하여 여러가지 자료를 확인중이다. 대표적인 것들이 memory leak에 관련된 문제와 thread 사용에 대한 것들이 있다. 오늘 하고자 하는 얘기는 이 thread 관련된 정보를 조사하다가 알게된 부분을 공유하고자 한다.</p>

<p>이 내용의 출처는 <a href="" title="https://gist.github.com/benelog/5954649">여기</a>다.</p>

<p>AsyncTask가 UI 스레드가 아닌 곳에서 처음으로 호출된다면 아래와 같은 에러스택이 발생할 수 있다고 한다. 이건 또 무슨 말도 안되는 소린가? 정말 안드로이드는 말도 안되는 이상한 현상들이 너무나도 많다. 하지만 위에 안내한 출처에서 명확한 원인과 해결 방법을 제시하고 있다.</p>

<pre><code>android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
    at android.view.ViewRoot.checkThread(ViewRoot.java:3011)
    at android.view.ViewRoot.requestLayout(ViewRoot.java:634)
    at android.view.View.requestLayout(View.java:8284)
    at android.view.View.setFlags(View.java:4658)
    at android.view.View.setVisibility(View.java:3133)
    at android.app.Dialog.hide(Dialog.java:254)
</code></pre>

<pre><code> Handler{40797d88} sending message to a Handler on a dead thread
 java.lang.RuntimeException: Handler{40797d88} sending message to a Handler on a dead thread
     at android.os.MessageQueue.enqueueMessage(MessageQueue.java:196)
     at android.os.Handler.sendMessageAtTime(Handler.java:457)
     at android.os.Handler.sendMessageDelayed(Handler.java:430)
     at android.os.Handler.sendMessage(Handler.java:367)
     at android.os.Message.sendToTarget(Message.java:349)
     at android.os.AsyncTask$3.done(AsyncTask.java:214)
     at java.util.concurrent.FutureTask$Sync.innerSet(FutureTask.java:253)
     at java.util.concurrent.FutureTask.set(FutureTask.java:113)
     at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:311)
     at java.util.concurrent.FutureTask.run(FutureTask.java:138)
     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1088)
     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:581)
     at java.lang.Thread.run(Thread.java:1019)
</code></pre>

<h2>원인</h2>

<p>AsyncTask 내에는 sHandler라는 static 멤버 변수가 있다고 해서 실제로 확인해 봤다. 현재 출처에서 밝힌 소스와는 조금 다르게 변경되어 있었다. sHandler는 앱에서 AsyncTask를 최초 선언한 순간 객체가 할당되고, UI작업을 처리하는 onPostExecute()가 호출될 때 사용된다고 설명되어 있었으나 설명과 다르게 선언시에는 아래와 같이 초기화를 하지 않도록 변경되었다. 대신 내부에서 getHandler() 함수가 처음 실행될 때 초기화 된다.</p>

<pre><code>private static final InternalHandler sHandler;
...
private static Handler getHandler() {
    synchronized (AsyncTask.class) {
        if (sHandler == null) {
            sHandler = new InternalHandler();
        }
        return sHandler;
    }
}
...
private static class InternalHandler extends Handler {
     ...
}
</code></pre>

<blockquote><p>앱을 실행하고 최초로 AsyncTask를 선언한 부분이 메인쓰레드가 아니라면 InternalHandler는 메인쓰레드가 아닌 쓰레드의 Handler를 가지고 있고 이 Handler로는 UI 작업을 하지 못하기 때문에 &ldquo;android.view.ViewRoot$CalledFromWrongThreadException&rdquo; 오류를 냅니다.</p>

<p>이 문제는 API Level 16미만 에서만 발생합니다. API Level 16이상에서는 메인스레드를 관리하는 ActivityThread 클래스가 시작할 때 main 메소드에서 static 메소드인 AsyncTask.init()을 호출하여 AsyncTask 클래스를 로드하고 있습니다. 관련 Commit은 다음 링크에서 확인하실 수 있습니다.</p>

<p><a href="https://github.com/android/platform_frameworks_base/commit/5e9120d4adfb07aeeadb0e0de1de2eb9ebbd80e0">https://github.com/android/platform_frameworks_base/commit/5e9120d4adfb07aeeadb0e0de1de2eb9ebbd80e0</a></p></blockquote>

<p>이렇게 설명되어 있으나 위에 얘기한 것 처럼 현재는 다시 조금 변경되어 있었다. 정확히는 AsyncTask.init() 이 부분이 없다. init() 함수도 선언되어 있지 않다.</p>

<p>그렇다면 문제가 없는 것일까? 해서 다시 조금 찾아봤다. 이 부분에 대해서는 <a href="" title="http://sjava.net/?p=1570">여기</a>에서 설명하고 있었다.
내용을 보니 5.1이 나오면서 내부적 처리가 변경된 것으로 보인다. 그리고 설명대로라면 사용상의 변경은 크지 않으므로 역시 초기화 과정은 필요없다.</p>

<p>덤으로 위 사이트에서 안내된 내용 중에 아래의 내용도 있다.</p>

<h3>Threading rules</h3>

<blockquote><p>There are a few threading rules that must be followed for this class to work properly:</p></blockquote>

<ul>
<li>The AsyncTask class must be loaded on the UI thread. This is done automatically as of JELLY_BEAN.</li>
<li>The task instance must be created on the UI thread.</li>
<li>execute(Params&hellip;) must be invoked on the UI thread.</li>
<li>Do not call onPreExecute(), onPostExecute(Result), doInBackground(Params&hellip;), onProgressUpdate(Progress&hellip;) manually.</li>
<li>The task can be executed only once (an exception will be thrown if a second execution is attempted.)</li>
</ul>


<h2>해결</h2>

<p>주저리 주저리 얘기가 많았는데 그래서 결론은 무엇인가? 젤리빈(API 16) 이상은 UIThread 내부에서 생성해야 한다는 제약사항 없이 어디서나 사용해도 무방하다. 그럼 그 이하는 어떻게 하나?
아래의 코드를 actiity 또는 application 시작 지점에 추가 한다. 메인스레드에서 단순히 클래스 로딩을 한번만 해도 AsyncTask내의 static 멤버 변수가 정상적으로 초기화된다고 한다.
그래서 난 appication class의 onCreate 함수 내부에 아래의 코드를 추가해 두었다.</p>

<pre><code class="java">if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) {
    try {
        Class.forName("android.os.AsyncTask");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드에서 findViewById 사용시 Generics을 이용해 Type Casting 없애기]]></title>
    <link href="http://blog.asamaru.net/2015/09/08/cleaner-view-casting-with-generics/"/>
    <updated>2015-09-08T22:27:15+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/08/cleaner-view-casting-with-generics</id>
    <content type="html"><![CDATA[<p>안드로이드 작업을 하다보면 findViewById를 아주 빈번하게 사용하게 된다. 이 작업이 생각보다 귀찮다보니 <a href="" title="http://jakewharton.github.io/butterknife/">butterknife</a>나 <a href="" title="http://androidannotations.org/">androidannotations</a> 같은 라이브러리를 사용하게 된다.(당연히 그 함수를 사용이 귀찮다는 이유만은 아니지만)</p>

<p>아래의 방법은 저런 라이브러리를 사용할 때만큼 여러가지 일을 할 수는 없지만 findViewById를 사용함에 가장 귀찮은 작업인 View Type Casting을 하지 않아도 된다.</p>

<p>우린 일반적으로 아래와 같은 방식으로 함수를 사용한다.</p>

<pre><code class="java">TextView textView = (TextView) findViewById(R.id.textview);
</code></pre>

<p>이를 개선하기 위해 아래의 함수 하나를 추가한다. 어디든 상관 없이 사용하고자 하는 클래스의 내부에 넣는다. 사실 사용시마다 이 함수를 추가하는 작업이 더 귀찮을 수 있다. 그래서 난 기본 Activity와 Fragment 안에 넣어두고 사용한다. (난 여러가지 이유로 작업시 base activity, fragment를 만들어 두고 실제 작업시 상속받아 사용한다. 이렇게하면 이번 경우와 같이 유틸성 함수를 함께 쓰기도 좋고 제어하기도 좋기 때문이다.)</p>

<pre><code class="java">@SuppressWarnings("unchecked")
public final &lt;E extends View&gt; E findView (int id) {
    return (E) findViewById(id);
}
</code></pre>

<p>그리고 아래와 같이 사용할 수 있다.</p>

<pre><code class="java">TextView textView = findView(R.id.textview);
Button button = findView(R.id.button);
ImageView image = findView(R.id.imageview);
</code></pre>

<p>사실 별차이 아니다. 하지만 작업 해본 사람은 안다. Type Casting을 일일이 넣는게 얼마나 귀찮은지.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 스튜디오에서 WIFI로 Run/Install/Debug 하기]]></title>
    <link href="http://blog.asamaru.net/2015/09/07/android-run-slash-install-slash-debug-applications-over-wifi/"/>
    <updated>2015-09-07T20:43:33+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/07/android-run-slash-install-slash-debug-applications-over-wifi</id>
    <content type="html"><![CDATA[<p>이제 안드로이드 개발을 시작한지 6개월 가량 된 것 같다. 나이 주 개발 영역은 웹이다. 프론드/백엔드, 서버 등등 웹에 관련된 일을 주로하며 예전엔 아이폰 개발도 일부 했었다. 하지만 회사 업무로 인해 안드로이드를 시작하게 되었고 6개월이나 했음에도 아직 초보를 벗어나지 못한 것 같다. 불필요한 사설이 길었지만 6개월간 왜 불편함을 그냥 당연하게 생각하고 작업을 했는지 안타깝다.</p>

<p>어제는 불현듯 책생 위에 널브러져 케이블들을 보며 이걸 없앨 수 없나? 라는 생각이 들었다. 내 책상 위에는 아이폰이 3개, 안드로이드 폰이 2개, 충전선 등이 있다. 굳이 다 필요하진 않지만&hellip;
그래서 찾아봤다. 안드로이드 빌드 후 실행을 케이블 없이 할 수 있는가? 결과는 있다. 아 왜 진작 찾아보지 않았던가? 사실은 선 정리보다 더 중요한 문제가 있었다. 안드로이드 연결 케이블이 불안정한 것이다. adb에 붙었다 떨어졌다 하는 현상이 사용하는 케이블에 따라 상태가 천차만별이었다. 정말 안드로이드는 맘에 안든다.</p>

<p>이제 정말 각설하고 본론을&hellip;</p>

<p>일단 이 방법에서의 최대 단점은 최초 연결시에는 USB 케이블이 필요하다는 것이다. 그리고 같은 망으로 연결되어야 한다는 점.</p>

<h3>1. 일단 기존처럼 USB로 안드로이드폰을 연결한다.</h3>

<h3>2. Shell을 열어 기기가 연결된 것을 확인한다. (사실 이 단계는 확인단계로 그냥 건너뛰어도 된다.)</h3>

<pre><code class="bash">$ adb devices -l

List of devices attached
6a1d4134               device usb:4245815296X product:hltelgt model:SM_N900L device:hltelgt
</code></pre>

<h3>3. 연결된 기기의 IP를 확인한다. adb shell 실행 후 shell이 뜨면 netcfg 입력. exit로 종료.</h3>

<pre><code class="bash">$ adb shell

shell@hltelgt:/ $ netcfg

rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 2e:80:5c:86:19:5f
...
sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00
p2p0     UP                                     0.0.0.0/0   0x00001003 ca:14:79:ea:48:5f
lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00
wlan0    UP                             192.168.219.101/24  0x00001043 c8:14:79:ea:48:5f

shell@hltelgt:/ $ exit
</code></pre>

<h3>4. adb를 통해 포트 5555(원하는 포트)로 변경한다.</h3>

<pre><code class="bash">$ adb tcpip 5555
</code></pre>

<h3>5. 기기 IP를 통해서 연결</h3>

<pre><code class="bash">$ adb connect &lt;DEVICE_IP_ADDRESS&gt;:5555
</code></pre>

<p>끝이다. 이제는 USB에서 기기를 분리해도 된다.
이제부터는 안드로이드 스튜디오에서 빌드를 하고 실행하려고 하면 원격으로 연결된 기기가 뜬다.</p>

<p>아직 많이 써보진 않았지만 아무래도 직접 USB로 연결한 것 보다는 조금 느린 것 같긴하다. 하지만 계속 션으로 연결하지 않아도 된다는 것으로 만족.</p>

<p>마지막으로 리모트 연결을 다시 USB 연결로 바꾸는 방법</p>

<pre><code class="bash">adb -s &lt;DEVICE_IP_ADDRESS&gt;:5555 usb
</code></pre>
]]></content>
  </entry>
  
</feed>
