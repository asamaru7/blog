<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-12-17T22:09:50+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Charles를 이용한 안드로이드 SSL Proxy]]></title>
    <link href="http://blog.asamaru.net/2015/12/17/charles-android-ssl-proxy/"/>
    <updated>2015-12-17T08:36:04+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/17/charles-android-ssl-proxy</id>
    <content type="html"><![CDATA[<p>안드로이드 앱을 개발할 때 http/https 디버깅을 위해서 proxy를 사용한다. 나는 예전에 <a href="http://sourceforge.net/projects/paros/">Paros</a>를 주로 사용했었는데 기본적인 기능을 사용하는데 문제가 없지만 버전업이 중단되어 아쉬운 부분이 많았다. 그래서 최근엔 <a href="https://www.charlesproxy.com/">Charles</a>를 주로 사용한다. <a href="http://sourceforge.net/projects/paros/">Paros</a>와 달리 <a href="https://www.charlesproxy.com/">Charles</a>는 유료지만 사용이 편리하고 다양한 기능을 제공한다. 그래서 많은 사람들이 사용하고 있는 것 같다.</p>

<p>이번에는 이 <a href="https://www.charlesproxy.com/">Charles</a>를 이용해서 https(SSL)를 proxy하는 방법을 설명하고자 한다. 이 글의 주요 주제는 아니지만 <a href="https://www.charlesproxy.com/">Charles</a>를 이용해서 proxy로 연결하는 방법부터 간략히 보자.</p>

<p><a href="https://www.charlesproxy.com/">Charles</a> &gt; Proxy &gt; Proxy Settings 메뉴로 들어가면 port를 지정할 수 있는 란이 나온다. 여기에 원하는 port를 입력한다. 안드로이드 기기에서는 Wi-Fi 설정으로 들어가서 연결된 네트워크를 길게 누르면 <code>네트워크 구성 변경</code>이라는 메뉴가 나타난다. 해당 메뉴로 들어가서 <code>고급 옵션 표시</code>를 체크하면 프록시 설정을 할 수 있는 란들이 나타난다. 여기서 <code>프록시 호스트 이름</code>에는 <a href="https://www.charlesproxy.com/">Charles</a>가 켜져있는 컴퓨터의 IP를 넣고 <code>프록시 포트</code>에는 <a href="https://www.charlesproxy.com/">Charles</a>에서 지정했던 port를 넣는다. 아이폰도 안드로이드와 메뉴는 다르지만 동일한 형태로 프록시 설정을 해주면 된다. 더 자세한 내용이 필요하면 인터넷에 관련 자료가 아주 많으니 찾아보길 바란다.</p>

<p>이렇게 연결이 되고나면 <a href="https://www.charlesproxy.com/">Charles</a>에는 해당 기기에서 사용하는 http/https 기록이 모두 나타난다. http 정보는 암호화가 되어 있지 않기 때문에 모든 내용을 다 볼 수 있지만 https의 경우는 송수신 데이터가 모두 암호화되어 있어 내용을 알아볼 수 없다. 이 부분을 http처럼 볼 수 있도록 설정하는 방법을 설명하고자 하는 것이다.</p>

<hr>

<p>다시 <a href="https://www.charlesproxy.com/">Charles</a>로 가서 아래의 단계를 따라한다. <a href="https://www.charlesproxy.com/">Charles</a> 3.9.3 버전 기준이므로 참고 바란다(3.11.2 버전의 경우 확인해보니 메뉴 위치가 다르긴 하나 설정은 큰 차이가 없다).</p>

<ul>
<li>Proxy &gt; Proxy Settings &gt; SSL로 간다.</li>
<li>“Enable SSL Proxying”를 체크한다.</li>
<li>&quot;Locations&quot; 아래의 &quot;Add&quot; 버튼을 눌러 디버깅하고자 하는 도메인과 port를 입력한다.</li>
<li>&quot;OK&quot;를 눌러 완료한다.</li>
</ul>

<p>이제는 <a href="http://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/">Charles - LEGACY SSL PROXYING</a> 사이트로 가서 cert 파일을 다운 받는다. 다운받은 cert 파일을 안드로이드 기기에 넣는다. 이메일로 보내서 첨부파일을 열어도 되고 파일을 직접 넣어도 되고 어떻게든 기기에 파일을 넣기만 하면 된다. 그리고 cert(crt) 파일을 터치하여 실행한다. 이후의 과정은 다음과 같다.</p>

<ul>
<li>cert 이름을 넣으라고 나오는데 아무 이름이나 넣어도 상관없다.</li>
<li>기기에 보안 lock이 걸려있지 않다면 lock을 걸어야만 사용할 수 있다는 안내가 나온다. 따라서 lock을 설정해야 한다. 패턴이건 비밀번호건 상관은 없다.</li>
<li>설치가 완료되고나면 네트워크 모니터링 가능성(이 기기의 네트워크 정보를 다른 곳에서 볼 수 있다) 안내가 나오는데 무시하면 된다. 지금하고 있는 작업 자체가 그것이므로.</li>
</ul>

<p>정상적으로 설치가 완료되었다면 이제부터는 이전과는 다르게 지정했던 도메인의 https 정보는 http와 동일하게 모두 볼 수 있다.</p>

<hr>

<p>그런데 3.10 버전 이상을 사용할 경우는 방법이 다르다. <a href="https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/">Charles - SSL CERTIFICATES</a>에 설명되어 있다. 안드로이드의 경우는 사이트에서 다운 받는 대신 Charles에서 &quot;Help &gt; SSL Proxying &gt; Install Charles Root Certificate on Mobile Device or Remote Browser...&quot;를 선택하면 방법을 안내한다. 내용은 다음과 같다.</p>

<p>안드로이드 기기의 브라우저에서 <a href="http://www.charlesproxy.com/getssl%EB%A5%BC">http://www.charlesproxy.com/getssl를</a> 방문한다. 단, Proxy가 연결된 상태이어야 한다. 이 사이트에 접속하면 cert 파일을 자동으로 추가해 준다. 이후의 과정은 3.9.3과 동일하다.</p>

<hr>

<p>마지막으로 설치한 cert 파일을 제거하는 방법이다. 이 부분은 기기마다 차이가 날 수 있다. 갤노트3 / 롤리팝 기준으로 &quot;설정 &gt; 일반 &gt; 보안 &gt; 인증서 저장공간 &gt; 신뢰할 수 있는 인증서 &gt; 사용자&quot;를 찾아가면 추가한 인증서가 있다. 해당 인증서를 누르면 맨 하단에 &quot;제거&quot; 버튼이 있다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 앱 종료 방법]]></title>
    <link href="http://blog.asamaru.net/2015/12/15/android-app-finish/"/>
    <updated>2015-12-15T19:38:39+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/15/android-app-finish</id>
    <content type="html"><![CDATA[<p>안드로이드에서 앱의 종료는 보통 Root Activity에서 <a href="http://developer.android.com/reference/android/app/Activity.html#finish%28%29">finish()</a>를 사용한다. 그런데 앱의 종료는 이외에도 여러가지 방법이 있고 각각이 다른 상황을 만들어 낸다. 당연히 구글에서는 <a href="http://developer.android.com/reference/android/app/Activity.html#finish%28%29">finish()</a>를 권장한다고 한다. 하지만 상황적으로 프로세스를 완전히 종료해야 하는 경우가 있을 수 있다. 아래에 설명하고자 하는 것들은 안정적으로 사용할 수 있는 방법이라고 장담하지는 못한다. 충분히 테스트된 코드가 아니라 인터넷 상에서 소개되는 방법들을 정리한 것이다. 물론 기본적인 테스트는 했다.</p>

<p>우선 Activity만 종료하는 방법부터 알아보자.</p>

<h3 id="finishaffinity-를-사용하는-방법"><a href="http://developer.android.com/reference/android/app/Activity.html#finishAffinity%28%29">finishAffinity()</a>를 사용하는 방법</h3>

<p>Root Activity에서 <a href="http://developer.android.com/reference/android/app/Activity.html#finish%28%29">finish()</a>를 사용해서 종료하는 것은 굳이 설명하지 않아도 될 것으로 생각한다. 단, 이 방법은 현재 Activity가 Root Activity가 아니면 Root Activity를 찾아가는 과정이 필요하므로 복잡해질 수 있다. 예를들어 아래와 같이 처리한다(이 코드는 테스트하지 않았다. 그리고 호출하는 Activity와 Root Activity에서 각각 처리해야 한다).</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Root Activity를 호출</span>
<span class="n">Intent</span> <span class="n">intent</span>  <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">FirstActivity</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">intent</span><span class="o">.</span><span class="na">putExtra</span><span class="o">(</span><span class="n">EXTRA_FINISH</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="n">intent</span><span class="o">.</span><span class="na">setFlags</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">FLAG_ACTIVITY_CLEAR_TOP</span><span class="o">);</span>        
<span class="n">startActivity</span><span class="o">(</span><span class="n">intent</span><span class="o">);</span>
<span class="n">finish</span><span class="o">();</span>
</code></pre></div><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Root Activity에서 인자를 받아 종료</span>
<span class="k">if</span> <span class="o">(</span><span class="n">getExtras</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">getIntentExtra</span><span class="o">(</span><span class="n">EXTRA_FINISH</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span> <span class="o">{</span>
   <span class="n">finish</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>이런 번거로움을 해결해 줄 수 있는 것이 <a href="http://developer.android.com/reference/android/app/Activity.html#finishAffinity%28%29">finishAffinity()</a>다. 이 함수를 사용하면 어느 Activity에서든 모든 부모 Activity를 닫을 수 있다. 단, 이 함수는 API 16부터 사용 가능하다. 하지만 support library v4를 사용하면 이하 버전에서도 이 함수를 사용할 수 있다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// only API 16+</span>
<span class="n">activity</span><span class="o">.</span><span class="na">finishAffinity</span><span class="o">();</span>

<span class="c1">// support library v4</span>
<span class="n">ActivityCompat</span><span class="o">.</span><span class="na">finishAffinity</span><span class="o">(</span><span class="n">activity</span><span class="o">);</span>
</code></pre></div>
<h3 id="홈-화면-activity-띄우기">홈 화면 Activity 띄우기</h3>

<p>이 방법은 Activity의 종료라고 하기에는 조금 애매한 방법이다. 일단 아래의 소스를 보자.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Intent</span> <span class="n">homeIntent</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">ACTION_MAIN</span><span class="o">);</span>
<span class="n">homeIntent</span><span class="o">.</span><span class="na">addCategory</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">CATEGORY_HOME</span><span class="o">);</span>
<span class="n">homeIntent</span><span class="o">.</span><span class="na">setFlags</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">FLAG_ACTIVITY_CLEAR_TOP</span><span class="o">);</span>
<span class="n">startActivity</span><span class="o">(</span><span class="n">homeIntent</span><span class="o">);</span>
</code></pre></div>
<p>소스를 보면 알겠지만 말그대로 홈 화면 Activity를 띄우는 것이다. 어쨌든 사용자가 보기에는 앱이 종료된 것처럼 보인다. 뒤에 남겨진 프로세스가 계속 살아남는지 Activity finish와 동일한 생명주기를 갖는지는 테스트 해보지 않았다.</p>

<h3 id="finishandremovetask-를-사용하는-방법"><a href="http://developer.android.com/reference/android/app/Activity.html#finishAndRemoveTask%28%29">finishAndRemoveTask ()</a>를 사용하는 방법</h3>

<p><a href="http://developer.android.com/reference/android/app/Activity.html#finishAndRemoveTask%28%29">finishAndRemoveTask ()</a>는 Activity를 종료하고 Task Manager(최근 앱 사용 목록)에서도 해당 앱을 제거한다. <strong>단, Task를 종료하지만 Process까지 종료하지는 않는다.</strong> 앱을 <a href="http://developer.android.com/reference/android/app/Activity.html#finishAndRemoveTask%28%29">finishAndRemoveTask ()</a>로 종료하고 Task Manager를 보면 해당 앱이 없어 Process가 종료된 것처럼 보이지만 이 상태에서 다시 앱을 실행하면 Application Class의 onCreate()가 실행되지 않는다(Process가 종료되었다면 이 함수가 다시 실행되었을 것이다). 메뉴얼에는 아래와 같이 나와있다.</p>

<blockquote>
<p>Call this when your activity is done and should be closed and the task should be completely removed as a part of finishing the Activity.</p>
</blockquote>

<p>그리고 이 함수는 API 21에서 추가된 함수로 아직까지는 호환성 함수는 없는 것으로 보인다. 그나마 찾아본 바로는 chromium 소스 코드 중 <a href="https://chromium.googlesource.com/chromium/src/base/+/master/android/java/src/org/chromium/base/ApiCompatibilityUtils.java">ApiCompatibilityUtils.java</a>에 있는 아래의 코드가 있다. 하지만 사용에 큰 의미는 없어보이니 참고만 하자.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">finishAndRemoveTask</span><span class="o">(</span><span class="n">Activity</span> <span class="n">activity</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Build</span><span class="o">.</span><span class="na">VERSION</span><span class="o">.</span><span class="na">SDK_INT</span> <span class="o">&gt;</span> <span class="n">Build</span><span class="o">.</span><span class="na">VERSION_CODES</span><span class="o">.</span><span class="na">LOLLIPOP</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">activity</span><span class="o">.</span><span class="na">finishAndRemoveTask</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">Build</span><span class="o">.</span><span class="na">VERSION</span><span class="o">.</span><span class="na">SDK_INT</span> <span class="o">==</span> <span class="n">Build</span><span class="o">.</span><span class="na">VERSION_CODES</span><span class="o">.</span><span class="na">LOLLIPOP</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// crbug.com/395772 : Fallback for Activity.finishAndRemoveTask() failing.</span>
        <span class="k">new</span> <span class="nf">FinishAndRemoveTaskWithRetry</span><span class="o">(</span><span class="n">activity</span><span class="o">).</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">activity</span><span class="o">.</span><span class="na">finish</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">FinishAndRemoveTaskWithRetry</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">RETRY_DELAY_MS</span> <span class="o">=</span> <span class="mi">500</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">MAX_TRY_COUNT</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Activity</span> <span class="n">mActivity</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">mTryCount</span><span class="o">;</span>
    <span class="n">FinishAndRemoveTaskWithRetry</span><span class="o">(</span><span class="n">Activity</span> <span class="n">activity</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mActivity</span> <span class="o">=</span> <span class="n">activity</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mActivity</span><span class="o">.</span><span class="na">finishAndRemoveTask</span><span class="o">();</span>
        <span class="n">mTryCount</span><span class="o">++;</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">mActivity</span><span class="o">.</span><span class="na">isFinishing</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mTryCount</span> <span class="o">&lt;</span> <span class="n">MAX_TRY_COUNT</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ThreadUtils</span><span class="o">.</span><span class="na">postOnUiThreadDelayed</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">RETRY_DELAY_MS</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">mActivity</span><span class="o">.</span><span class="na">finish</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h3 id="process-종료하기">Process 종료하기</h3>

<p>이제부터는 앱을 종료하고 Process까지 완전히 종료시키는 방법들이다. 이 부분에 대해서는 의견이 다양한데 앱 종료시 처리되어야 할 프로세스들이 정상적으로 동작하지 못할 수 있다는 우려로 사용을 자제하라는 의견도 있고 알아서 처리하므로 상관없다는 의견도 있다. 테스트를 아직 해보지 못해 어떤 문제가 발생하는지에 대해서는 설명할 수 없으니 사용시 유의하자.</p>

<p><a href="http://stackoverflow.com/a/5036668">How to close Android application?</a>에 소개된  Class 소스의 일부를 보자.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">killApp</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">killSafely</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">killSafely</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*</span>
<span class="cm">         * Notify the system to finalize and collect all objects of the app</span>
<span class="cm">         * on exit so that the virtual machine running the app can be killed</span>
<span class="cm">         * by the system without causing issues. NOTE: If this is set to</span>
<span class="cm">         * true then the virtual machine will not be killed until all of its</span>
<span class="cm">         * threads have closed.</span>
<span class="cm">         */</span>
        <span class="n">System</span><span class="o">.</span><span class="na">runFinalizersOnExit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

        <span class="cm">/*</span>
<span class="cm">         * Force the system to close the app down completely instead of</span>
<span class="cm">         * retaining it in the background. The virtual machine that runs the</span>
<span class="cm">         * app will be killed. The app will be completely created as a new</span>
<span class="cm">         * app in a new virtual machine running in a new process if the user</span>
<span class="cm">         * starts the app again.</span>
<span class="cm">         */</span>
        <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="cm">/*</span>
<span class="cm">         * Alternatively the process that runs the virtual machine could be</span>
<span class="cm">         * abruptly killed. This is the quickest way to remove the app from</span>
<span class="cm">         * the device but it could cause problems since resources will not</span>
<span class="cm">         * be finalized first. For example, all threads running under the</span>
<span class="cm">         * process will be abruptly killed when the process is abruptly</span>
<span class="cm">         * killed. If one of those threads was making multiple related</span>
<span class="cm">         * changes to the database, then it may have committed some of those</span>
<span class="cm">         * changes but not all of those changes when it was abruptly killed.</span>
<span class="cm">         */</span>
        <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Process</span><span class="o">.</span><span class="na">killProcess</span><span class="o">(</span><span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Process</span><span class="o">.</span><span class="na">myPid</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>이 함수에서 Process를 종료하는 방법은 크게 두가지로 나뉜다. <code>System.exit()</code>를 사용하는 방법과 <code>android.os.Process.killProcess</code>를 사용하는 방법이다. 함수를 보면 알다시피 <code>System.exit()</code>를 사용하는 것이 더 안전한 방법으로 보인다. 그런데 이 부분에 대해서도 사람들의 의견이 차이가 있다. <code>System.runFinalizersOnExit(true)</code> 대신 <code>System.runFinalization()</code>를 호출하여 강제로 Finalization을 수행하는 방법을 설명하는 사람도 있고 이렇게하면 불안정하게 동작할 수 있으니 그냥 <code>System.exit()</code>만 호출하라는 사람도 있고... 어쨌든 개인적으로는 위 함수가 가장 적절하게 구성되어 있다고 생각한다. <strong>단, 주의사항 한가지. 이 부분은 직접 테스트 해본 것은 아니나 두개 이상의 Activity가 떠 있는 상황에서 Process를 종료시키면 Process가 살아난다는 이야기도 있다.</strong> 그런 이유가 아니더라도 Activity의 종료 프로세스를 제대로 동작시키는 것이 좋다는 생각으로 나는 아래와 같이 처리하고 있다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ActivityCompat</span><span class="o">.</span><span class="na">finishAffinity</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">runFinalizersOnExit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</code></pre></div>
<p>현재까지는 이 방법으로 이상없이 사용하고 있으나 서두에서 언급한 것처럼 충분한 테스트를 거친 내용들이 아니므로 사용시에는 유의하기 바란다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 Realm 0.82.2 -> 0.86.0 버전업]]></title>
    <link href="http://blog.asamaru.net/2015/12/10/realm/"/>
    <updated>2015-12-10T20:43:17+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/10/realm</id>
    <content type="html"><![CDATA[<p>모바일 앱 개발시에 DB는 주로 Sqlite 또는 Core Data를 많이 사용한다. 그런데 Sqlite 등을 사용하는 것이 조금 불편한 부분들이 많아서 지난 앱 개발시 <a href="https://realm.io/kr/">Realm</a>을 사용했다. <a href="https://realm.io/kr/">Realm</a>을 사용하면 개발이 용이해지기는 한데 간혹 다루기가 까다로워지는 경우가 있다. 사실 그런 문제 상황은 내가 사용시 뭔가를 잘못했을 확률이 높지만 개인적으로 다소 예민한 라이브러리라고 생각한다. 어찌보면 당연할 수도 있는 것이 아직 1.0 버전이 되지도 못한 라이브러리니 그럴만도 하다. 실제로 아직은 버전업이 자주 발생하고 버전업시에 변경 사항이 다소 있는 편이다. 중요 변경이 있을 때 마이그레이션을 잘못하거나 하면 앱 크래시의 원인이 되기도 하니 버전업시에는 유의해야 한다.
<strong>그렇지만 다행인 것은 <a href="https://realm.io/kr/docs/java/latest/">문서화</a>가 잘되어 있고 한글본도 번역도 빠르게 올라온다.</strong></p>

<hr>

<p>얼마전 기존 프로젝트의 Realm의 0.82.2에서 0.86.0으로 버전업을 했다(버전을 확인한지 그리 오래되지 않았는데 그 사이 많이도 버전업되었다). 그랬더니 아래와 같은 오류가 발생했다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Field &#39;date&#39; is required. Either set @Required to field &#39;date&#39; or migrate using io.realm.internal.Table.convertColumnToNullable(). : io.realm.exceptions.RealmMigrationNeededException: Field &#39;date&#39; is required. Either set @Required to field &#39;date&#39; or migrate using io.realm.internal.Table.convertColumnToNullable().
</code></pre></div>
<p>사용하는 테이블의 <code>date</code> 필드가 <code>required</code>이니 <code>@Required</code> 어노테이션을 붙이거나 테이블을 마이그레이션하라는 안내다. 이미 Realm에서 해결 방법을 친절히도 안내해주고 있다. <code>@Required</code>는 기존에 사용하지 않던 것이라 찾아봤다. <a href="https://realm.io/kr/news/realm-java-0.83.0/">Realm 자바 0.83 — Null 지원!</a>를 보니 0.83 버전에서 데이터값으로 null을 사용할 수 있게 됨에 따라 추가된 어노테이션이다. 그러니 기존 0.82.2의 데이터는 null이 될 수 없었으므로 required 타입으로 인식하는 것이다. 그외에도 다른 변경 사항을 보고 싶다면 <a href="https://github.com/realm/realm-java/blob/master/changelog.txt">changelog</a>를 참고하자.</p>

<p>기존에도 null이 들어올 수 없는 구조로 프로그램되어 있었으니 <code>@Required</code>를 해당 핃르(변수)에 붙이는 것으로 해결하는 것이 맞겠다. 나는 여기서 다른 문제를 겪었었는데 <code>@Required</code>만 붙이면 될 것을 스키마 버전 정보까지 올리는 바람에 엉망이 되었었다. 어쨌든 결론은 이 문제에 대해서는 <code>@Required</code>를 붙이는 방법으로 간단히 해결된다.</p>

<hr>

<p>그런데 문제는 여기서 끝나지 않았다. <a href="https://realm.io/docs/java/latest/api/io/realm/RealmMigration.html">RealmMigration</a> 클래스도 방식이 변경되어 맞춰줬다.</p>

<p>그리고 또 하나. 기존에는 아래와 같이 인스턴스를 생성해서 사용했다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">RealmConfiguration</span><span class="o">.</span><span class="na">Builder</span> <span class="n">realmBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RealmConfiguration</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">name</span><span class="o">(</span><span class="n">realmName</span><span class="o">)</span> <span class="o">.</span><span class="na">schemaVersion</span><span class="o">(</span><span class="n">SCHEME_VERSION</span><span class="o">);</span>
<span class="n">RealmConfiguration</span> <span class="n">config</span> <span class="o">=</span> <span class="n">realmBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="n">Realm</span> <span class="n">realm</span> <span class="o">=</span> <span class="n">Realm</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
</code></pre></div>
<p>그런데 여기서 문제가 발생하기 시작했다. 이 부분은 realm 접속을 생성하는 과정으로 사용하는 시점에 처리하고 있었다. 기존에 사용처 자체가 워낙에 간단한 부분이라서 그랬는지는 몰라도 문제가 없었다. 그런데 버전업 이후 이상하게 앱 크래시가 발생했다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">E/AndroidRuntime: FATAL EXCEPTION: main
                  Process: ~~~, PID: 21532
                  java.lang.RuntimeException: Unable to start activity ComponentInfo{~~~/~~~}: java.lang.IllegalArgumentException: Configurations cannot be different if used to open the same file.
...
</code></pre></div>
<p>오류 내용은 이렇다. 동일 table 파일을 다른 Configurations으로 열 수 없다. 이 오류는 처음에 앱이 열릴 때는 발생하지 않다가 종료 후 다시 들어오면 발생했다. 이상했다. 분명이 앱을 종료 했음에도 불구하고 왜 다른 Configurations을 넣고 있다는 것인지.</p>

<p>이번에 알게 되었는데 root activity에서의 finish()는 앱의 종료를 의미하는 것이 아니었다. 마지막 activity가 finish()되면 화면에서는 즉시 종료된 것으로 보이나 프로세스는 살아 남는다. 아마도 시스템 자원이 부족해지면 프로세스가 OS에 의해 죽을 수는 있다. 이와 관련해서 앱을 완전히 종료하는 방법에 대해서는 <del>조만간 별도로 글을 남기려고 한다.</del> <a href="/2015/12/15/android-app-finish/">안드로이드 앱 종료 방법</a>에서 설명하고 있다.</p>

<p>어쨌든 이러한 상황이 발생하는 것으로 보아 기존 버전과 최신 버전의 Realm 생명 주기를 관리하는 방법이 변경된 것으로 보인다. 메뉴얼에 보면 <a href="https://realm.io/kr/docs/java/0.86.0/#section-52">모범 사용예 - Realm 인스턴스들의 생명주기 관리하기</a>라는 부분이 있다. &quot;모범 사용예&quot;라는 항목 자체가 0.85.0 버전부터 있는 것으로 보아 그 시점에 변경이 된 것으로 생각한다. 그런데 여기서 사용하는 함수는 <a href="https://realm.io/news/realm-java-0.81.1/">Realm Java 0.81.1</a>에서 추가된 것으로 소개하고 있다. 기존에 내가 사용하던 것이 0.82.2 였지만 위 문제가 발생하지 않았던 것으로 보아 앞선 예상대로 그 후에 관리 방법이 변경된 것 같기는 하다. 어쨌든 이 부분에 관련된 정보가 있어 발췌한다.</p>

<blockquote>
<p><strong>Realm 인스턴스들의 생명주기 관리하기</strong></p>

<p>RealmObjects과 RealmResults는 데이터 전체를 느긋하게 가져옵니다. 이런 이유로 Realm 오브젝트나 질의 결과를 접근할 때 가능한 오래 Realm 인스턴스를 유지하는 것이 중요합니다. Realm 데이터 커넥션을 열고 닫는 추가 비용을 줄이기 위해 레퍼런스 카운트화된 캐시를 가집니다. 이는 Realm.getDefaultInstance()를 같은 스레드에서 여러번 호출하는 것은 비용이 들지 않고 내부의 리소스는 자체적으로 모든 인스턴스가 닫히면 해제됨을 의미합니다.</p>

<p>모든 액티비티와 프래그먼트의 UI 스레드에서 Realm 인스턴스를 열고 Activity나 Fragment가 파괴될 때 닫는 것은 쉽고 안전한 접근 법입니다.</p>
</blockquote>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 애플리케이션에서 Realm 설정하기</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyApplication</span> <span class="kd">extends</span> <span class="n">Application</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">();</span>
        <span class="n">RealmConfiguration</span> <span class="n">realmConfiguration</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RealmConfiguration</span><span class="o">.</span><span class="na">Builder</span><span class="o">(</span><span class="k">this</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
        <span class="n">Realm</span><span class="o">.</span><span class="na">setDefaultConfiguration</span><span class="o">(</span><span class="n">realmConfiguration</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 액티비티들을 전환하며 onCreate()/onDestroy()가 중첩되면 Activity 2의 onCreate가</span>
<span class="c1">// Activity 1의 onDestroy()보다 먼저 호출 됩니다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Realm</span> <span class="n">realm</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">realm</span> <span class="o">=</span> <span class="n">Realm</span><span class="o">.</span><span class="na">getDefaultInstance</span><span class="o">();</span>
    <span class="o">}</span>    

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
        <span class="n">realm</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 프래그먼트에서 onStart()/onStop()를 사용합니다.</span>
<span class="c1">// 프래그먼트의 onDestroy()는 호출되지 않을 수 있습니다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Realm</span> <span class="n">realm</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onStart</span><span class="o">();</span>
        <span class="n">realm</span> <span class="o">=</span> <span class="n">Realm</span><span class="o">.</span><span class="na">getDefaultInstance</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStop</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onStop</span><span class="o">();</span>
        <span class="n">realm</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>그렇다. 이제는 앱 생성시 <code>Realm.setDefaultConfiguration()</code>를 이용해서 Configuration을 지정하고 필요한 곳에서 <code>Realm.getDefaultInstance()</code>으로 인스턴스를 받아 사용하는 것을 권장한다. 위에 이야기한 문제도 이 방식을 사용하면 발생하지 않는다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 Crash Report 도구 : ACRA에서 Fabric(Crashlytics)으로의 전환]]></title>
    <link href="http://blog.asamaru.net/2015/11/11/from-acra-to-fabric/"/>
    <updated>2015-11-11T20:33:16+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/11/from-acra-to-fabric</id>
    <content type="html"><![CDATA[<p>지난 글 <a href="/2015/10/01/android-acra-please-configure-buildconfigclass-in-your-acra-config/">ACRA : Please configure &#39;buildConfigClass&#39; in your ACRA config 오류</a>와 <a href="/2015/09/25/android-6-apache-http-client-removal/">Android 6(API 23 : marshmallow) : Apache HTTP 클라이언트 제거</a>에서 언급했던 것처럼 안드로이드 Crash Report 도구로 ACRA를 사용중이었다.
ACRA 사용중에 만난 오류를 해결하기 위해 시간을 들여서 원인을 찾고 개발자에게 전달해서 개선을 요청할 정도로 나름 애용하려던 도구였는데 오늘 <a href="https://fabric.io">Fabric(Crashlytics)</a>으로 바꿔버렸다.</p>

<p>사실 처음부터 대체할 목적이 있었던 것은 아니었다. 안드로이드용으로 제작된 앱을 iOS용으로도 제작할 일이 있어 개발을 진행하던 중 안드로이드의 ACRA 같은 도구가 iOS에도 있을 것이라는 생각에 몇가지를 찾아보고 있었다. 그때 눈에 띄는 것이 <a href="https://try.crashlytics.com/">Crashlytics</a> 였다(<a href="https://gist.github.com/rino0601/018c7f22aeb23cf2e2a0">Crashlytics 소개 + Android Studio에서 적용하는 방법</a>).</p>

<p>그런데 이 Crashlytics라는 서비스를 운영하는 회사가 트위터에 인수가 되었다(<a href="http://besuccess.com/2013/01/28496/">앱 충돌 리포트 서비스 Crashlytics, 트위터에 인수되다</a>). 그래서 조금 더 알아보니 트위터에서 <a href="https://fabric.io">Fabric</a>이라는 것을 새로 내놓았다.</p>

<p><a href="https://fabric.io">Fabric</a>이 무엇인지에 대해서는 트위터 한글 블로그의 &quot;<a href="https://blog.twitter.com/ko/2014/introducing-fabric-kr">패브릭(Fabric)을 소개합니다.</a>&quot;를 보면 잘 설명되어 있다.</p>

<blockquote>
<p>패브릭(Fabric)은 앱 개발자들이 흔히 직면하는 안정성, 사용자 확보, 수익성, 사용자 인증의 이슈들&gt;을 해결해 줄 세 가지의 모듈형 키트들로 이루어져 있습니다. 패브릭은 크래시리틱스(Crashlytics), 모펍(MoPub), 트위터 등의 서비스를 통합해 개발자들이 더 안정적인 앱을 만들도록 돕습니다. 패브릭은 앱 개발자들이 세계 최고의 모바일 애드 익스체인지(ad exchange)를 통해 수익을 확보할 수 있게 하며, 트위터 로그인 기능과 실시간 콘텐츠 스트림 기능을 통해 더 많은 사용자에 콘텐츠를 전달할 수 있게 하거나 더욱 간단히 사용자를 인증할 수 있도록 해줍니다.</p>
</blockquote>

<p>나는 우선 최초 목적이었던 iOS를 위한 Crash Report 도구의 설치를 위해 xcode 프로젝트에 <a href="https://fabric.io">Fabric</a>을 추가했다. 설치 과정은 복잡하지는 않으나 몇가지 설정할 부분들이 있어서 자칫 까다로워질 수 있지만 <a href="https://fabric.io">Fabric</a>에서 관련 도구를 워낙에 잘 제공 해줘서 시키는대로 따라만 하면 큰 무리없이 적용할 수 있다. &quot;기회가 되면 설치 과정을 글로 남길까?&quot; 생각했었지만 설치 도구가 워낙 잘되어 있어 &quot;굳이 내가 다시 설명할 필요가 있을까?&quot;라는 생각이다. 그 정도로 잘 되어있다. 다만 기본 설치 후 Debug 모드에서는 로그 수집을 하지 않도록 설정하는 등의 몇가지 안내가 필요한 부분들이 있는데 이건 시간이되면 따로 글을 남기려고 한다. 사실 이 부분도 메뉴얼로 모두 제공되고 있으나 막상 찾으려니 귀찮은 것들이다.</p>

<p>결론적으로는 아주 만족스러웠다. Crash Report가 잘되는 것은 물론이고 Hook을 걸 수 있도록 하는 기능도 제공되고 있어서 기존에 ACRA에서 연결해 두었던 자체 로그 수집기로도 기존처럼 정보를 전달하는 것이 가능했다(정확히 이야기 하자면 기존과 동일한 내용을 전달하는 것은 아니고 오류 발생 이벤트만 전달된다). 그리고 <a href="https://fabric.io">Fabric</a>에는 <a href="https://try.crashlytics.com/">Crashlytics</a> 외에도 <a href="https://answers.io/">Answers</a>라는 모듈도 함께 제공된다(사실 더 많은 것들이 있다). 이 모듈은 구글 어날리틱스 처럼 앱에 대한 이벤트를 수집하여 보고서를 제공해 준다. 결정적으로 이 모든 것이 무료.</p>

<p>그래서 안드로이드용 앱에서도 ACRA를 걷어내고 Fabric을 적용했다. 역시 아주 만족스럽다. ACRA에서 보내주는 무지막지한 Crash 로그 대신 잘 정리된 로그를 확인할 수 있게 되었다.</p>

<p>앞선 설명처럼 <a href="https://fabric.io">Fabric</a>에는 여러가지 모듈들이 있는데 이들 중 일부는 각각 독립적인 서비스를 가지고 있다(<a href="https://try.crashlytics.com/">Crashlytics</a>와 <a href="https://answers.io/">Answers</a> 처럼). 이 부분에 관련해서는 트위터 한글 블로그의 &quot;<a href="https://blog.twitter.com/ko/2014/introducing-fabric-kr">패브릭(Fabric)을 소개합니다.</a>&quot;의 내용 마지막에 아래와 같이 안내 되어있다.</p>

<blockquote>
<p>패브릭(Fabric)은 트위터만의 작품이 아닙니다. 패브릭(Fabric)이 가능하도록 키트(Kits)들의 관리, 설치, 업데이트에 관여하는 모든 SDK 벤더들이 만들어낸 것이라고 생각합니다. 당신이 SDK를 관리하는 사람이고, 트위터와 함께 일하고 싶다면 패브릭 파트너십 담당(<a href="mailto:partners@fabric.io">partners@fabric.io</a>)에 메일을 보내 주시길 바랍니다. 개발자 여러분들의 연락을 기다리고 있겠습니다.</p>
</blockquote>

<p>따라서 각각의 서비스를 사용해도 무방할 것으로 보인다. 하지만 <a href="https://fabric.io">Fabric</a>을 사용함으로써 통합 관리를 할 수 있으며 설치 과정이 아주 단순해진다.</p>

<p><strong>결론 : Crash Report 도구가 필요하다면, iOS와 Android 모두 한 곳에서 관리하고 싶다면, 사용자 이벤트 로깅도 하고 싶다면, <a href="https://fabric.io">Fabric</a>을 적극 추천하고 싶다.</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android : is not translated in ... Lint Error 해결]]></title>
    <link href="http://blog.asamaru.net/2015/11/05/android-is-not-translated-in-dot-dot-dot-lint-error/"/>
    <updated>2015-11-05T14:27:23+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/05/android-is-not-translated-in-dot-dot-dot-lint-error</id>
    <content type="html"><![CDATA[<p>안드로이드에서 배포를 위한 빌드시에 아래와 같은 오류가 발생하는 경우가 있다. 상황에 따라 언어의 종류(en)는 다를 수 있다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Error:(65) Error: &quot;...&quot; is not translated in &quot;en&quot; (English) [MissingTranslation]
</code></pre></div>
<p>이 오류는 말그대로 다국어 지원에 대한 처리가 제대로 되어 있지 않다는 오류이다. 일반적으로 다국어 지원을 위한 별도의 처리를 한적이 없다면 이 오류는 발생하지 않는 것이 당연하다.
하지만 이번에 이 오류를 만나고 찾아보니 많은 개발자들이 이 문제를 겪는 것 같다. 사실 나는 다국어 지원에 관련된 별도의 처리를 한 상황이었으므로 이 오류를 만나는 것이 당연한 상황이었다.
어쨌든 인터넷에 찾아보면 대부분 다음과 같이 해결법을 제시하고 있다.</p>

<ul>
<li>Lint 관련 설정은 이클립스 메뉴의 Window - Preference - Android - Lint 에서 변경할 수 있는데요..  여기서 MissingTranslation 항목을 찾아 Severity를 warning으로 변경하면 됩니다.</li>
<li><a href="http://mytalkhome.tistory.com/816">Android Studio &quot;is not translated in &quot;en&quot; (English) [MissingTranslation]&quot; 오류 해결하기</a></li>
</ul>

<p>이 방법은 말그대로 제대로 처리되지 않은 부분을 오류에서 경고로 변경하여 빌드를 수행하는 것으로 좋지 못한 방법이다. 게다가 나의 경우는 OSX라서 그런지 안드로이드 스튜디오의 버전 때문인지 위치와 명칭이 많이 달랐다.</p>

<p>유사하지만 다른 방법도 있다. build.gradle에서 lint를 제외하는 것이다. <a href="http://stackoverflow.com/questions/20699147/gradle-build-fails-on-lint-task">gradle build fails on lint task</a></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">android {
  lintOptions {
      checkReleaseBuilds false
  }
}
</code></pre></div>
<p>그리고 또 다른 방법 한가지. <a href="http://stackoverflow.com/questions/28106875/missingtranslation-for-default-language-is-not-translated-in-en">MissingTranslation for default language ( “…” is not translated in “en”)</a>
이 방법은 Strings.xml에서 locale을 아예 미리 입력해 버리는 것이다. 위 오류에 맞추어 en이라고 했지만 자신의 상황에 맞게 입력해야 한다.</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;resources</span>
    <span class="na">xmlns:tools=</span><span class="s">&quot;http://schemas.android.com/tools&quot;</span>
    <span class="na">tools:locale=</span><span class="s">&quot;en&quot;</span><span class="nt">&gt;</span>
</code></pre></div>
<p>당연히 문제의 원인을 정확히 파악하여 해결하는 것이 가장 좋은 방법이다.
당장 급하고 원인을 찾지 못하겠다면 위의 방법들을 쓸 수도 있겠지만 계속 저렇게 사용하는 것은 권장하고 싶지는 않다.</p>

<p>이제부터는 내가 문제를 만난 상황이다. 사실 나 또한 다국어를 지원할 필요가 있었던 것은 아니다. 다만 사용한 라이브러리 중 하나가 다국어를 지원하고 있었다.
따라서 한국어 부분은 <code>values-ko/strings.xml</code>파일로 분리되어서 처리되고 있었다. 이 상황에서 내가 필요한 것은 설정된 문장의 일부를 변경하는 것이었다.
그래서 내 프로젝트의 <code>values/strings.xml</code>에 필요한 문장들을 재정의 했다. 오류는 나지 않지만 적용되지 않는다. 다시 내 프로젝트에도 <code>values-ko/strings.xml</code> 파일을 만들고 필요한 부분을 재정의 했다.
여기서부터 문제의 시작이다. 아래의 오류가 발생한다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Error:(65) Error: &quot;...&quot; is not translated in &quot;ko&quot;
</code></pre></div>
<p><code>values-ko/strings.xml</code> 파일에 모든 내용을 넣지 않고 필요한 부분만 넣었으므로 나머지 부분이 번역되지 않았다고 오류가 나는 것이다. 간단한 해결 방법은 <code>values-ko/strings.xml</code> 파일에 <code>values/strings.xml</code>의 내용을 모두 복사해 넣어준다. 그런데 이 방법은 싫다. 둘다 한국어인데 굳이 두군데를 관리하고 싶지 않다. 이런 경우라면 아래와 같이 <code>tools:ignore=&quot;MissingTranslation&quot;</code>를 사용해서 문제를 해결할 수 있다.</p>

<p><strong>Strings.xml</strong>
<code>xml
&lt;resources
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    tools:ignore=&quot;MissingTranslation&quot;&gt;
</code></p>

<p>명확히 이 영역은 다국어 지원이 필요하지 않은 이므로 명시적으로 번역 누락을 무시하도록 하는 것이다. 어떻게 보면 상기 설명했던 오류를 무시하는 것과 같아 보일 수 있으나 이 방법은 무시할 범위를 명확히 인지하고 해당 영역만 필요에 의해 무시하도록 했다는 것이다.
단, 한가지 추가 작업이 필요하다. <code>values-ko/strings.xml</code> 파일에서 재정의 했던 항목들을 <code>values/strings.xml</code>에도 넣어주어야 한다는 것이다. 안그러면 아래와 같은 오류가 난다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Error:(3) Error: &quot;XXX&quot; is translated here but not found in default locale [ExtraTranslation]
</code></pre></div>
<p>사실 불편함이 생기는 부분이지만 앞서 설명처럼 반대로 모두를 두군데서 관리하는 것보다 필요한 몇줄만 별도 관리하는 것을 선택했다.</p>

<p><strong>결론적으로 선택은 자유다. 위 방법들 중 필요에 맞게 선택해서 사용하면 되겠다.</strong></p>
]]></content>
  </entry>
  
</feed>
