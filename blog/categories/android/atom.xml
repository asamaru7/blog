<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-09-05T19:50:49+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[안드로이드에서 Dialog 사용시 WindowManager$BadTokenException 발생]]></title>
    <link href="http://blog.asamaru.net/2015/09/04/android-dialog-windowmanager-badtokenexception/"/>
    <updated>2015-09-04T20:49:21+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/04/android-dialog-windowmanager-badtokenexception</id>
    <content type="html"><![CDATA[<p>안드로이드에서는 거의 모든 작업에 context를 사용한다. 그런데 이 context는 크게 application contet와 activity context가 있다. 문제는 사용시에 구분해서 사용하지 않는다는 것이다. 명시적으로 특정 context를 요구하지 않는다. 이로 인해 많은 혼란이 있고 crash도 많이 발생한다.</p>

<p>사실 오류를 줄이려면 가능한한 activity context를 사용하는 것이 좋다.(경험상&hellip;) 하지만 안드로이드에서는 가급적 application context를 사용하기를 권장한다.</p>

<p>가장 대표적인 이유는 메모리릭 때문이다. 메모리릭에 대한 문제는 context의 종류에 직접적인 관련이 있는 것은 아니나 activity 내부에서 객체를 생성하면서 자신을 context로 넘겨줄 경우 순환참조 등의 이유로 객체가 소멸하지 못할 수 있다. 메모리릭 문제는 상상보다 더 다양한 경우에 발생하는데 여기서 논하고자하는 범위를 벋어나니 일단 넘어가자. 사실 검색해 보면 많은 자료가 있다.
어쨌든 생성된 객체가 죽지 못한다면 activity도 소멸하지 못하므로 대량의 메모리 점유를 경험하게 될 수 있다. 당연히 앱이 크지 않다면 OOM(Out Of Memory)을 쉽게 만나지는 않을 것이다.
사설이 길었는데 어쨌든 이러한 이유로 나는 가급적 application context를 사용하려고 한다.
문제는 여기서 시작되었다.</p>

<p>기존에 WebView를 생성할 때는 activity를 넘겨주었었다. 이 코드를 얼마전 확인하고 application context로 변경했다. 그리고 빌드, 실행. 문제가 없었다. 잘 나왔다. 안심했다.</p>

<p>그런데 오늘 동료 직원이 이상한 부분이 있다고 확인을 요청했다.</p>

<blockquote><p>WebView 내부에 있는 select box를 터치하면 앱이 죽는다.</p></blockquote>

<p>처음엔 뭔가 했다. 그런데 오류를 확인하니 다음과 같았다.</p>

<pre><code>W/System.err﹕ android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an application
W/System.err﹕ at android.view.ViewRootImpl.setView(ViewRootImpl.java:691)
W/System.err﹕ at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:288)
W/System.err﹕ at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)
W/System.err﹕ at android.app.Dialog.show(Dialog.java:312)
W/System.err﹕ at org.chromium.content.browser.input.SelectPopupDialog.show(SelectPopupDialog.java:133)
W/System.err﹕ at org.chromium.content.browser.ContentViewCore.showSelectPopup(ContentViewCore.java:2437)
W/System.err﹕ at org.chromium.base.SystemMessageHandler.nativeDoRunLoopOnce(Native Method)
W/System.err﹕ at org.chromium.base.SystemMessageHandler.handleMessage(SystemMessageHandler.java:53)
W/System.err﹕ at android.os.Handler.dispatchMessage(Handler.java:102)
W/System.err﹕ at android.os.Looper.loop(Looper.java:145)
W/System.err﹕ at android.app.ActivityThread.main(ActivityThread.java:5942)
W/System.err﹕ at java.lang.reflect.Method.invoke(Native Method)
W/System.err﹕ at java.lang.reflect.Method.invoke(Method.java:372)
W/System.err﹕ at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1399)
</code></pre>

<p>이런 Dialog를 생성하려는 시점에서 context가 적절하지 못하다. 그렇다. WebView에서 select box를 선택하면 앱의 경우는 선택 dialog가 자동으로 뜬다. 이때 이 dialog를 생성할 때 WebView 생성시 넣어 줬던 context를 사용하는 것이다.</p>

<p>아&hellip; 그럼 처음부터 application context를 넣지 못하도록 하던지&hellip; 정말 안드로이드는 누가 설계 했는지 너무 엉망이다. UIThread 문제, Network Main Thread 문제.. 등등 상식적으로 해결 방법이 있을 법한데 모두 개발자가 알아서 하란다. 이런&hellip;</p>

<p>어쨌든 Dialog 생성시에는 activity context를 사용해야 한다. 일반 dialog는 테스트시에 바로 표시가 나니 금방 고칠 수 있지만 이런 경우는 참 난해하다.</p>

<p>결론은 WebView 생성시에는 activity context를 넣자.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 View.isLaidOut / View.post]]></title>
    <link href="http://blog.asamaru.net/2015/09/04/android-view-dot-islaidout-and-view-dot-post/"/>
    <updated>2015-09-04T10:12:29+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/04/android-view-dot-islaidout-and-view-dot-post</id>
    <content type="html"><![CDATA[<p>안드로이드 View는 isLaidOut이라는 함수를 가지고 있다. 단, API 19(KITKAT)부터 사용가능하다. 사실 그 이하의 기기에서도 다른 방법을 통해서 사용가능하다. 아주 간단히. 이 부분은 나중에 다시 설명하겠다.</p>

<p>우선 isLaidOut 함수에 대해 안드로이드 메뉴얼에는 다음과 같이 나와있다.</p>

<blockquote><p>public boolean isLaidOut ()</p>

<p>Added in API level 19</p>

<p>Returns true if this view has been through at least one layout since it was last attached to or detached from a window.</p></blockquote>

<p>쉽게 말해서 &ldquo;해당 View가 layout이 그려졌는가?"를 반환하는 함수다.</p>

<p>다음은 post 함수에 대한 안드로이드 메뉴얼이다.</p>

<blockquote><p>public boolean post (Runnable action)</p>

<p>Added in API level 1</p>

<p>Causes the Runnable to be added to the message queue. The runnable will be run on the user interface thread.</p></blockquote>

<p>Runnalbe을 넘겨 받아 UIThread에서 실행시켜준다고 한다.</p>

<p>그래서 어디에 써먹을 수 있나?
한가지 예를들어 보자면 TextView의 getLineCount()의 반환값 문제를 해결할 수 있다.</p>

<p>구글에서 &ldquo;<a href="https://www.google.co.kr/search?q=isLaidOut&amp;gws_rd=ssl#newwindow=1&amp;safe=off&amp;q=textview+getlinecount">textview getlinecount</a>"로 검색하면 많이 나오는 것 중 하나가 "textview.getLineCount always 0 in android"라는 질문이다.</p>

<p>textview의 getLineCount()를 요청하면 항상 0이 나오는 문제가 있다는 얘기인데, 이런 문제의 원인은 getLineCount() 함수가 TextView가 그려진 후 그 상황에 맞는 라인수를 반환한다는 것이다. 따라서 그려지기 전에는 항상 0을 반환한다.</p>

<p>그럼 이 문제를 isLaidOut을 써서 해결해보자.</p>

<pre><code class="java">TextView textView = new TextView(context);

...

textView.setText("test message");
if (textView.isLaidOut()) {
    Log.d("TEXTVIEW", "line count : " + textView.getLineCount());
} else {
    final TextView postTextView = textView;
    textView.post(new Runnable() {
        @Override
        public void run() {
            Log.d("TEXTVIEW", "line count : " + postTextView.getLineCount());
        }
    });
}
</code></pre>

<p>여러가지 상황이 있을 수 있다. 위의 예시와 다르게 layout xml에서 TextView가 정의될 수도 있고.
중요한 것은 TextView가 그려지기 전에 getLineCount() 함수를 사용하려는 것이다.</p>

<p>그런데 여기서도 한계는 있다. 값을 가져오는 부분이 비동기 방식이 된다는 것이다. 이를 해결하기 위해서는 다른 방법이 필요하다. 하지만 여기서는 isLaidOut에 대한 설명을 하고자 하는 것이므로 다음으로 넘긴다. 사실 찾아보면 여러가지 방법들이 제시되어 있는데 아주 깔끔한 방법은 현재로써는 찾기 힘들다.</p>

<p>위의 TextView 사례는 말그대로 예시일뿐 isLaidOut에 대한 활용 범위는 아주 다양할 수 있다.</p>

<p>마지막으로 isLaidOut을 API 19 이하에서 사용할 수 있는 방법은 다음의 예시를 참고하자.</p>

<pre><code class="java">TextView textView = new TextView(context);

...

textView.setText("test message");
if (ViewCompat.isLaidOut(textView)) {
    Log.d("TEXTVIEW", "line count : " + textView.getLineCount());
} else {
    final TextView postTextView = textView;
    textView.post(new Runnable() {
        @Override
        public void run() {
            Log.d("TEXTVIEW", "line count : " + postTextView.getLineCount());
        }
    });
}
</code></pre>

<p>중요한 부분은 ViewCompat을 사용한다는 부분이다. 아주 간단한 방법으로 사용할 수 있으므로 하위 버전을 지원해야 한다하더라도 사용할 수 있다.</p>

<pre><code class="java">ViewCompat.isLaidOut(textView)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드에서 android.os.NetworkOnMainThreadException을 발생시키지 않고 HTTP Ping 보내기]]></title>
    <link href="http://blog.asamaru.net/2015/09/03/android-http-ping/"/>
    <updated>2015-09-03T18:48:08+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/03/android-http-ping</id>
    <content type="html"><![CDATA[<p>오늘은 작업을 하던 중간에 서버로 ping을 보내야 하는 작업이 생겼다. 정확하게는 서버에 간단한 값을 전송해서 로그로 쌓기 위한 작업이다.
우선 안드로이드는 main thread에서 network 작업을 할 수 없도록 되어있다. 억지로 하려고하면 android.os.NetworkOnMainThreadException이 발생한다.</p>

<p>간단히 생각해서 handler를 사용하는 방법도 있으나 메인 handler를 사용하면 마찬가지다.
그래서 가장 간단한 방법은 AsyncTask를 사용하는 것이다.</p>

<p>아래는 url을 인자로 받아 http로 접속한 후 response가 200이 나왔는지를 반환한다.</p>

<pre><code class="java">static class HttpPingAsyncTask extends AsyncTask&lt;String, Void, Boolean&gt; {
    @Override
    protected Boolean doInBackground(String... urls) {
        try {
            HttpURLConnection.setFollowRedirects(false);
            HttpURLConnection con = (HttpURLConnection) new URL(urls[0]).openConnection();
            con.setRequestMethod("HEAD");
            return (con.getResponseCode() == HttpURLConnection.HTTP_OK);
        } catch (Exception e) {
            return false;
        }
    }
}
</code></pre>

<p>사용법은 다음과 같다.</p>

<pre><code class="java">(new HttpPingAsyncTask()).execute(url);
</code></pre>

<p>이는 가장 간단한 형태로 구현된 코드로 할 수 있는 일이 url을 호출하고 응답을 확인하는 것 밖에 없다. 하지만 조금만 응용하면 여러가지로 활용할 수 있다.
url에 GET 인자로 전달하고자 하는 값을 넘기고 서버에서는 해당 값을 로그로 남기거나 필요한 처리를 한다. 그리고 정상처리가 되었다면 200을 반환하고 실패하면 500을 반환함으로써 처리 결과를 알 수 있다. 이러한 형태를 이용하면 간단한 구현으로 여러가지 일을 할 수 있다.</p>

<p>또한 위의 코드에 필요한 기능을 조금씩 덧붙이면 보다 다양한 일을 할 수 있는 코드를 만들수도 있을 것이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 6(API 23)의 getColor() Deprecated 대응 + getDrawable() Deprecated]]></title>
    <link href="http://blog.asamaru.net/2015/08/28/android-getcolor-getdrawable-deprecated/"/>
    <updated>2015-08-28T06:27:49+09:00</updated>
    <id>http://blog.asamaru.net/2015/08/28/android-getcolor-getdrawable-deprecated</id>
    <content type="html"><![CDATA[<p>얼마전 Android API 23 버전이 공개되었다. 이와함께 support library, design support library도 함께 23 버전으로 버전업 되었다.</p>

<p>이에따라 여러가지 UI들이 추가되어 필요한 부분을 적용해 보고자 gradle을 수정하고 build 하니 getColor 함수가 deprecated 되었다는 warning을 보게되었다.</p>

<p>아&hellip; 최근에 안드로이드는 기본 함수들을 너무 많이 바꾼다. 사실 이번 버전업으로 이것뿐아니라 http 관련된  api가 제거 되었다. 이미 이전부터 deprecated 되었었긴하지만 너무 갑작스럽기도 하다.
현재시점에서 ACRA, android-async-http 등의 오픈소스들도 대응이 되지 않았다. 이에 따른 대응방법도 구글에 안내되어 있긴하다.</p>

<p><a href="https://developer.android.com/intl/ko/preview/behavior-changes.html#behavior-apache-http-client">Apache HTTP 클라이언트 제거</a></p>

<p>하지만 임시방편일 뿐 계속 사용하기엔 석연치 않다. 조금더 자세한 내용은 다음에 다시 글을 쓰도록 하겠다.</p>

<p>다시 본론으로 돌아와서 이 부분을 해결하기 위해서는 ContextCompat(android.support.v4.content.ContextCompat)을 사용하면 된다.
단, support library 23 이상이 필요할 수 있다. 이하에서는 확인을 못했다.</p>

<p>함수는 아래와 같이 구성되어 있다.</p>

<pre><code class="java">public static final int getColor(Context context, int id) {
    final int version = Build.VERSION.SDK_INT;
    if (version &gt;= 23) {
        return ContextCompatApi23.getColor(context, id);
    } else {
        return context.getResources().getColor(id);
    }
}
</code></pre>

<p>실제사용은</p>

<pre><code class="java">ContextCompat.getColor(context, resourceId);
</code></pre>

<p>이렇게 하면된다. 어떻게보면 기존보다 더 편하다. 하지만 기존에 getColor를 사용하던 부분을 고치는 것은 우리가 해야한다.</p>

<p>추가로 보다 더 이전에 deprecated된 함수 getDrawable()가 있다. 이건 정확하지 않지만 API 21부터 deprecated 된 것 같다.
이 문제도 동일한 class를 통해 해결 가능하다.</p>

<pre><code class="java">public static final Drawable getDrawable(Context context, int id) {
    final int version = Build.VERSION.SDK_INT;
    if (version &gt;= 21) {
        return ContextCompatApi21.getDrawable(context, id);
    } else {
        return context.getResources().getDrawable(id);
    }
}
</code></pre>

<p>요즘 분위기를 보면 이런식으로 deprecated 되는 함수가 많다. 사실 개인적으로 많은 것은 기존 안드로이드가 워낙 엉망이라고 보기 때문에 문제가 되지 않는다고 생각하지만 처리하는 과정은 맘에 들이 않는다.
한번에 싹 정리하지 않고 눈에 띄면 추가하듯 띄엄띄엄 deprecated 함수를 늘리고 실제 제거까지 오래 기다리지 않는다. 이건 꼭 새로운 버전을 사용하지 말라고 권장하는 것도 아니고 쓰라는 것도 아니고&hellip;</p>

<p>마지막으로 PhoneNumberUtils.formatNumber 함수 예기만 하나더 하자면</p>

<pre><code class="java">public static String formatNumber(String source);
</code></pre>

<p>이 함수도 deprecated 되었다. 이제는 두번째 인자로 포멧팅할 국가 코드를 넣어야 한다.</p>

<pre><code class="java">PhoneNumberUtils.formatNumber(number, "KR");
</code></pre>

<p>그게 대응이 어려운 문제는 아니다. 하지만 위의 문제들과 더불어 굳이 deprecated 했어야 하는가? 하는 부분이다.
개인적인 생각으로 두번째 인자를 생략하면 기존처럼 국가코드를 자동으로 넣으면 되지 않는가? 일부 다국어 지원 앱에서 조금더 명확한 사용을 하기 위해 대다수의 단일국가 지원 앱들이 불편을 감수해야하는가?
다음이 기존함수이다.</p>

<pre><code class="java">@Deprecated
public static String formatNumber(String source) {
    SpannableStringBuilder text = new SpannableStringBuilder(source);
    formatNumber(text, getFormatTypeForLocale(Locale.getDefault()));
    return text.toString();
}
</code></pre>

<p>보다시피 <code>Locale.getDefault()</code> 부분을 넣어주고 있었다. 어쨌든 나는 아래와 같은 호환 함수를 만들어서 사용하고 있다.</p>

<pre><code class="java">static public String getFormattedPhoneNumber(String number) {
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
        return PhoneNumberUtils.formatNumber(number, "KR");
    } else {
        // noinspection deprecation
        return PhoneNumberUtils.formatNumber(number);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ViewPager를 직접 생성시 android.content.res.Resources$NotFoundException: Unable to Find Resource ID #0xffffffff 오류 발생]]></title>
    <link href="http://blog.asamaru.net/2015/08/27/android-viewpager-setid/"/>
    <updated>2015-08-27T10:56:56+09:00</updated>
    <id>http://blog.asamaru.net/2015/08/27/android-viewpager-setid</id>
    <content type="html"><![CDATA[<p>일반적으로 ViewPager 사용시 layout xml에서 정의해서 사용한다.
하지만 간혹 필요에 따라 ViewPager을 프로그램으로 생성해서 사용하는 경우 있다.</p>

<pre><code class="java">ViewPager viewPager = new ViewPager(this);
viewPager.setId(Helper.generateViewId());
</code></pre>

<p>그런데 이렇게 사용할 경우 아래와 같은 오류를 만나게 된다.</p>

<pre><code class="java">android.content.res.Resources$NotFoundException: Unable to find resource ID #0xffffffff
            at android.content.res.Resources.getResourceName(Resources.java:3216)
            at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1008)
            at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1197)
            at android.support.v4.app.BackStackRecord.run(BackStackRecord.java:738)
            at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:1562)
            at android.support.v4.app.FragmentManagerImpl.executePendingTransactions(FragmentManager.java:535)
            at android.support.v4.app.FragmentPagerAdapter.finishUpdate(FragmentPagerAdapter.java:141)
            at android.support.v4.view.ViewPager.populate(ViewPager.java:1106)
            at android.support.v4.view.ViewPager.populate(ViewPager.java:952)
            at android.support.v4.view.ViewPager.onMeasure(ViewPager.java:1474)
            at android.view.View.measure(View.java:18573)
...
</code></pre>

<p>처음엔 웬 리소스를 못 찾는다는 에러가 나오는지 한참을 헤맸다.
결국 알아낸 문제는 사실 개인적으로 조금 어이가 없었다. xml에서 정의된 ViewPager는 인스턴스화되면서 임시 id가 알아서 지정되는 것으로 보이나 프로그램에서 생성한 ViewPager는 그 과정이 누락되는 것이다.
어이없는 상황. 그러나 해결법은 간단하다. id를 지정해 주면 된다.</p>

<p>그래서 아래처럼 해봤다.</p>

<pre><code class="java">ViewPager viewPager = new ViewPager(this);
viewPager.setId(1);
</code></pre>

<p>하지만 그렇게 간단히 해결되면 안드로이드가 아니지&hellip;
그래서 다음과 같은 방법으로 id를 생성해 주어야 한다.</p>

<pre><code class="java">public class IdGen {
    final static private AtomicInteger sNextGeneratedId = new AtomicInteger(1);

    static private int _generateViewId() {
        for (; ; ) {
            final int result = sNextGeneratedId.get();
            // aapt-generated IDs have the high byte nonzero; clamp to the range under that.
            int newValue = result + 1;
            if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0.
            if (sNextGeneratedId.compareAndSet(result, newValue)) {
                return result;
            }
        }
    }

    static public int generateViewId() {
        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR1) {
            return _generateViewId();
        } else {
            return View.generateViewId();
        }
    }
}
</code></pre>

<pre><code class="java">ViewPager viewPager = new ViewPager(this);
viewPager.setId(IdGen.generateViewId());
</code></pre>

<p>드디어 이상없이 동작한다.</p>
]]></content>
  </entry>
  
</feed>
