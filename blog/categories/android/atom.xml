<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-10-05T21:12:57+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Google Play services and DEX method limits]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/google-play-services-and-dex-method-limits/"/>
    <updated>2015-10-05T20:49:03+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/google-play-services-and-dex-method-limits</id>
    <content type="html"><![CDATA[<p><a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>에서 잠시 언급했던 multidex와 <a href="https://developers.google.com/android/guides/overview">Google Play services</a>와의 관계에 대해서 잠시 이야기 하고자 한다. 그 당시에도 설명했던 것과 같이 multidex를 사용해야 하는 상황은 가급적 피하는 것이 좋다. 하지만 오래된 버전의 Google Play services를 사용하면 65K이상의 method를 사용하게될 확률이 높다. 이 라이브러리에서 사용하고 있는 method의 수가 상당하기 때문에 proguard를 통해 사용하지 않는 함수를 제거하지 않는 이상 65K개를 넘어설 확률이 높은 것이다(대부분 여러가지 라이브러리를 사용해서 앱을 개발하므로). 문제는 proguard를 적용하게되면 빌드 시간이 증가하기 때문에 작업시 불편하다. <a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>에서 언급 했던 내용들을 적용한다면 상당한 속도 향상을 가져올 수 있지만 그래도 1초라도 시간을 줄이는 것이 좋지 않은가? 하루에 한번만 빌드할 것도 아닌데.</p>

<p>이와 관련해서는 <a href="http://android-developers.blogspot.kr/2014/12/google-play-services-and-dex-method.html">Google Play services and DEX method limits</a>라는 글에 잘 설명하고 있다.</p>

<p>Google Play services의 버전을 6.5(2015.10.05. 기준 8.1이 최신) 이상 사용한다면 아래와 같이 필요한 부분만 적용함으로써 이 문제를 어느 정도 해결할 수 있다(6.5 미만에서는 무조건 통째로 불러서 사용할 수 밖에 없다).</p>

<pre><code>// 기존
compile 'com.google.android.gms:play-services:6.5.87'

// 6.5 이후
compile 'com.google.android.gms:play-services-maps:6.5.87'
compile 'com.google.android.gms:play-services-base:6.5.87'
</code></pre>

<p><a href="https://developers.google.com/android/guides/setup">Setting Up Google Play Services</a> 문서를 참고하면 사용할 수 있는 전체 목록을 확인할 수 있다. 아래는 현재 기준 목록이다.</p>

<table>
<thead>
<tr>
<th> Google Play services API   </th>
<th>     Description in build.gradle </th>
</tr>
</thead>
<tbody>
<tr>
<td> Google+ </td>
<td> com.google.android.gms:play-services-plus:8.1.0 </td>
</tr>
<tr>
<td> Google Account Login </td>
<td> com.google.android.gms:play-services-identity:8.1.0 </td>
</tr>
<tr>
<td> Google Actions, Base Client Library </td>
<td> com.google.android.gms:play-services-base:8.1.0 </td>
</tr>
<tr>
<td> Google App Indexing </td>
<td> com.google.android.gms:play-services-appindexing:8.1.0 </td>
</tr>
<tr>
<td> Google App Invites </td>
<td> com.google.android.gms:play-services-appinvite:8.1.0 </td>
</tr>
<tr>
<td> Google Analytics </td>
<td> com.google.android.gms:play-services-analytics:8.1.0 </td>
</tr>
<tr>
<td> Google Cast </td>
<td> com.google.android.gms:play-services-cast:8.1.0 </td>
</tr>
<tr>
<td> Google Cloud Messaging </td>
<td> com.google.android.gms:play-services-gcm:8.1.0 </td>
</tr>
<tr>
<td> Google Drive </td>
<td> com.google.android.gms:play-services-drive:8.1.0 </td>
</tr>
<tr>
<td> Google Fit </td>
<td> com.google.android.gms:play-services-fitness:8.1.0 </td>
</tr>
<tr>
<td> Google Location, Activity Recognition, and Places </td>
<td> com.google.android.gms:play-services-location:8.1.0 </td>
</tr>
<tr>
<td> Google Maps </td>
<td> com.google.android.gms:play-services-maps:8.1.0 </td>
</tr>
<tr>
<td> Google Mobile Ads </td>
<td> com.google.android.gms:play-services-ads:8.1.0 </td>
</tr>
<tr>
<td> Mobile Vision </td>
<td> com.google.android.gms:play-services-vision:8.1.0 </td>
</tr>
<tr>
<td> Google Nearby </td>
<td> com.google.android.gms:play-services-nearby:8.1.0 </td>
</tr>
<tr>
<td> Google Panorama Viewer </td>
<td> com.google.android.gms:play-services-panorama:8.1.0 </td>
</tr>
<tr>
<td> Google Play Game services </td>
<td> com.google.android.gms:play-services-games:8.1.0 </td>
</tr>
<tr>
<td> SafetyNet </td>
<td> c m.google.android.gms:play-services-safetynet:8.1.0 </td>
</tr>
<tr>
<td> Google Wallet </td>
<td> com.google.android.gms:play-services-wallet:8.1.0 </td>
</tr>
<tr>
<td> Android Wear </td>
<td> com.google.android.gms:play-services-wearable:8.1.0 </td>
</tr>
</tbody>
</table>


<p>어쨌든 java라는 언어의 특성상 method의 수가 많을 수 밖에 없는데 65K limit은 최초의 설계부터 잘못된 것이 아닌가? 하는 생각이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle applicationIdSuffix 사용시 AndroidAnnotations 설정]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/using-applicationidsuffix-with-androidannotations/"/>
    <updated>2015-10-05T10:05:11+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/using-applicationidsuffix-with-androidannotations</id>
    <content type="html"><![CDATA[<p><a href="/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix/">Gradle DSL method not found: &lsquo;packageNameSuffix()&rsquo; 오류 해결</a>에서 오류 해결 방법을 안내하면서 언급했던 applicationIdSuffix를 사용시 유의사항이 있다. <strong>applicationId가 debug 모드에서 변경됨에 따라 관련된 부분에서 문제가 일어날 수 있다는 것이다.</strong></p>

<p>나의 경우는 AndroidAnnotations을 함께 사용하는 부분에서 오류를 만났다. AndroidAnnotations에서 applicationId를 기준으로 resource에 접근해서 자동 생성된 class들을 찾지 못하는 문제이다.</p>

<p>이런 경우에 대비해서 AndroidAnnotations에는 resourcePackageName라는 속성을 제공한다.</p>

<p><a href="https://github.com/excilys/androidannotations/wiki/CustomizeAnnotationProcessing">CustomizeAnnotationProcessing</a>에 보면 아래와 같이 안내되어 있다.</p>

<blockquote><p><strong>resourcePackageName</strong></p>

<p>Type: string
By default, AndroidAnnotations try to find the R class by extracting application package from AndroidManifest.xml file. But in some cases you may want to specify a custom package to look for the R class. This is why we added resourcePackageName option.</p></blockquote>

<p>결론은 아래처럼 resourcePackageName에 기존 packageName을 넣어줌으로써 해결이 가능하다.</p>

<pre><code>apt {
    arguments {
        resourcePackageName "net.yourdomain"
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle DSL method not found: 'packageNameSuffix()' 오류 해결]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix/"/>
    <updated>2015-10-05T08:13:08+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/gradle-dsl-method-not-found-packagenamesuffix</id>
    <content type="html"><![CDATA[<p>안드로이드에서 빌드시 packageName을 동적으로 변경하기 위해 packageNameSuffix를 사용하는 경우가 있다. 예를들어 배포된 앱과 개발중인 앱을 동시에 사용하기 위해 packageNameSuffix를 사용할 수 있다.</p>

<p>아래의 예시를 보자.</p>

<pre><code>android {
    buildTypes {
        debug {
            packageNameSuffix '.debug'
            versionNameSuffix '-debug'
        }
    }
}
</code></pre>

<p>debug 모드에서 빌드할 경우에는 packageName 뒤에 <code>.debug</code>를 붙이도록 설정한 것이다. 이렇게 함으로써 release와 debug가 packageName이 달라져서 두개의 앱으로 인식되므로 모두를 설치할 수 있다.
이 방법을 모를때는 매번 앱을 지우고 새로 깔고&hellip; 귀찮은 작업을 반복하며 작업을 했었다.</p>

<p>그런데 이렇게 사용하면 아래의 경우를 만날 수 있다.</p>

<pre><code> Gradle sync failed: Gradle DSL method not found: 'packageNameSuffix()'
            Consult IDE log for more details (Help | Show Log)
</code></pre>

<p>이유는 packageNameSuffix라는 속성이 applicationIdSuffix로 변경되었기 때문이다. 관련 메뉴얼은 <a href="http://tools.android.com/tech-docs/new-build-system/applicationid-vs-packagename">ApplicationId versus PackageName</a>에서 볼 수 있다.</p>

<p>그래서 아래와 같이 수정하면 정상적으로 사용이 가능하다.</p>

<pre><code>android {
    buildTypes {
        debug {
            applicationIdSuffix '.debug'
            versionNameSuffix '-debug'
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACRA : Please configure 'buildConfigClass' in your ACRA config 오류]]></title>
    <link href="http://blog.asamaru.net/2015/10/01/android-acra-please-configure-buildconfigclass-in-your-acra-config/"/>
    <updated>2015-10-01T19:48:09+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/01/android-acra-please-configure-buildconfigclass-in-your-acra-config</id>
    <content type="html"><![CDATA[<p><a href="/2015/09/25/android-6-apache-http-client-removal/">Android 6(API 23 : marshmallow) : Apache HTTP 클라이언트 제거</a> 포스트에서 언급했던 것처럼 개발 중인 앱에서 Crash Report를 위해 <a href="https://github.com/ACRA/acra">ACRA</a>를 사용중이다. 아직 4.7.0으로 정식 버전업이 되지는 않았지만 4.7.0 RC1 버전이 maven에 올려져 있어서 적용해 보았다.
사실은 미리 적용할 예정은 없었으나 <a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>와 관련하여 Gradle을 2.4로 버전업 하면서 release 빌드 시에 다른 오류(setLatestEventInfo 함수가 제거됨)가 나타나서 어쩔 수 없이 버전업을 해야했다.</p>

<p>그런데 버전업을하고 나서 Crash 테스트를 하는 도중 또 다른 오류를 만났다. 기존에도 오류가 나고 있었는지 버전업 후의 문제인지는 확실치는 않다. 안드로이드 작업은 끝없는 오류 해결의 연속인 듯하다. 오류는 아래와 같다.</p>

<pre><code class="java">E/ACRA: Not adding buildConfig to log. Class Not found : net.yourdomain.BuildConfig. Please configure 'buildConfigClass' in your ACRA config
</code></pre>

<p>우선 ACRA를 초기화하는 코드를 살펴보자. 당연하지만 실제 적용코드가 아닌 부분적으로 정리된 코드다.</p>

<pre><code>ACRAConfiguration config = ACRA.getNewDefaultConfig(this);
config.setFormUri("http://dev.yourdomain.net/AppCrash");
ACRA.init(this, config); // The following line triggers the initialization of ACRA
</code></pre>

<p>@ReportsCrashes 어노테이션을 사용하지 않고 동적으로 초기화시켜주는 코드다. 실제로 Crash를 발생시키면 위에서 보여준 오류가 난다. 사실 이 문제는 원인을 확인한 결과 Proguard가 적용되었을 때만 오류가 발생한다. 아래의 ACRA 소스 코드의 일부를 보자.</p>

<p><strong><a href="https://github.com/ACRA/acra/blob/master/src/main/java/org/acra/collector/CrashReportDataFactory.java">CrashReportDataFactory.java</a></strong></p>

<pre><code class="java">private Class&lt;?&gt; getBuildConfigClass() throws ClassNotFoundException {
    final Class configuredBuildConfig = ACRA.getConfig().buildConfigClass();
    if ((configuredBuildConfig != null) &amp;&amp; !configuredBuildConfig.equals(Object.class)) {
        // If set via annotations or programatically then it will have a real value,
        // otherwise it will be Object.class (annotation default) or null (explicit programmatic).
        return configuredBuildConfig;
    }

    final String className = context.getClass().getPackage().getName() + ".BuildConfig";
    try {
        return Class.forName(className);
    } catch (ClassNotFoundException e) {
        ACRA.log.e(LOG_TAG, "Not adding buildConfig to log. Class Not found : " + className + ". Please configure 'buildConfigClass' in your ACRA config");
        throw e;
    }
}
</code></pre>

<p><code>final String className = context.getClass().getPackage().getName() + ".BuildConfig";</code> 이 부분을 보면 패키지명에 BuildConfig를 더해 Class를 찾고 있다. 이 부분이 문제다. Proguard에서 BuildConfig를 난독화해버려서 리플렉션으로 찾을 수 없는 것이다.
해결을 위한 아래의 코드를 보자.</p>

<pre><code class="java">ACRAConfiguration config = ACRA.getNewDefaultConfig(this);
config.setBuildConfigClass(BuildConfig.class);
config.setFormUri("http://dev.yourdomain.net/AppCrash");
ACRA.init(this, config); // The following line triggers the initialization of ACRA
</code></pre>

<p><code>config.setBuildConfigClass(BuildConfig.class);</code> 이 부분을 추가했다. ACRA 코드에서 보듯이 setBuildConfigClass로 직접 BuildConfig를 넘겨주면 패키지명으로 찾지 않는다. 따라서 Proguard가 적용되어도 문제가 없다.</p>

<hr />

<p>이 오류는 이것으로 해결이 가능하다. 하지만 나는 지금 다른 문제로 다시 고군분투 중이다.
오류 발생시 HTTP/POST를 통해 오류 관련 정보를 전송하도록 사용중이었다. 그런데 앞서 이야기 한것과 같이 이번에 버전업이 되면서 HTTP 접속 관련 부분이 변경되었다. 여기에 문제가 있다.</p>

<pre><code class="java">...
urlConnection.setChunkedStreamingMode(0);
...
</code></pre>

<p>위 부분은 ACRA에서 HTTP 전송시 사용하는 HttpRequest.java 의 일부분이다. <code>setChunkedStreamingMode</code>에 대해서는 여기서 설명하기엔 너무 길고 간단히 요약하자면 chunked 상태로 데이터가 전송된다.
그런데 이 상태로 전송되면 현재 내가 사용하고 있는 서버에서 POST 값이 모두 비어 있다. request의 body가 수신되지 못하는 것이다. 이 부분은 나의 환경인 php-fpm가 proxy로 연결되어 있는 것과 관련이 있는 것으로 보인다. 이 부분에 대해서는 여러가지로 시도해 보았으나 해결이 되지 않았고 일단은 몇개의 클래스를 재정의해서 문제를 막아 놓았다. 그리고 관련해서는 ACRA에 Issue로 등록해 두었다. 개선이 될런지는 미지수인데 안된다면 앞으로 사용상에 걸림돌이 될 것 같다. 이 부분에 관련된 해결책이 나온다면 다시 포스팅을 하도록 하겠다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 Geocoder 사용시 Service not Available 오류]]></title>
    <link href="http://blog.asamaru.net/2015/09/30/service-not-available-geocoder-android/"/>
    <updated>2015-09-30T16:15:20+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/30/service-not-available-geocoder-android</id>
    <content type="html"><![CDATA[<p>안드로이드에서 특정 지점의 좌표를 주소로 변환하는 것이 필요해서 Geocoder 사용했다. 대략적인 코드는 아래와 같다.</p>

<pre><code class="java">static abstract public class GeoCoderTask extends AsyncTask&lt;LatLng, Void, Address[]&gt; {
    @Override
    protected Address[] doInBackground(LatLng... arg0) {
        List&lt;Address&gt; res = new ArrayList&lt;&gt;();
        if (arg0.length &gt; 0) {
            try {
                Geocoder geocoder = new Geocoder(Helper.getAppContext(), Locale.KOREA);
                List&lt;android.location.Address&gt; addresses = geocoder.getFromLocation(arg0[0].latitude, arg0[0].longitude, 1);
                if ((addresses != null) &amp;&amp; (addresses.size() &gt; 0)) {
                    android.location.Address result = addresses.get(0);
                    Address resultAddress = new Address();
                    resultAddress.address = result.getAddressLine(0);
                    resultAddress.lat = result.getLatitude();
                    resultAddress.lng = result.getLongitude();
                    resultAddress.premise = result.getPremises();
                    resultAddress.administrative_area_level_1 = result.getAdminArea();
                    resultAddress.sublocality_level_1 = result.getSubLocality();
                    resultAddress.country = result.getCountryName();
                    resultAddress.postal_code = result.getPostalCode();
                    res.add(resultAddress);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        Address[] array = new Address[res.size()];
        res.toArray(array);
        return array;
    }
}
</code></pre>

<p>위 코드는 데이터를 다른 클래스로 넘겨서 반환하는 형태로 그대로 사용할 수는 없다. 그냥 이렇게 사용했다는 것을 보여주고자 넣은 코드니 참고만하기 바란다.</p>

<p>어쨌든 중요한 것은 잘 동작하던 코드가 테스트 기기에서 Service not Available 오류가 난다는 것이다. 테스트 기기는 nexus s에 4.0.4로 오래된 기기다. 처음엔 OS 버전 문제로 생각했다. 그래서 일단 검색해 봤다. 결론은 아래의 링크를 보고 해결했다.</p>

<p><a href="http://stackoverflow.com/a/13856839">Service not Available - Geocoder Android</a></p>

<p>해결 방법은 <strong>기기 재부팅</strong>. 어의없다. 정말 안드로이드는 정이 안간다.</p>

<p>사실 동일한 오류를 만났을 때 위의 방법으로 해결되지 않을 수 있다. 원인은 다양할 수 있으니&hellip; 그래서 조금 더 찾아보니 여러가지 이슈가 있는 것을 확인 했다. 해결되지 않는다면 구글에서 검색해 보면 여러가지 정보를 얻을 수 있다.</p>

<p>이러한 정보 중에서 한가지는 Geocoder를 사용하지 않고 웹으로 호출해서 결과를 받는 것이다. 사실 나의 경우는 오류 때문이 아니라 api 사용량 때문에 사용하던 코드(API 키를 전달하지 않는 코드로 사용량에 제한을 받지 않는 것으로 보임)였는데 참고할 사람이 있을까하고 남겨본다. 그리고 한가지. 조금 전에 API key를 전달하지 않는다고 했는데 기존에는 이 방법으로 정상 동작했다. 그런데 최근 WIFI에서는 이상이 없는데 LTE 상태에서는 api 한계량 초과라는 메시지를 반환하고 있어서 사용하고 있지 않다. 이 부분은 이유를 정확히 확인해보지 못했다.</p>

<pre><code class="java">static abstract public class WebGeoCoderTask extends AsyncTask&lt;LatLng, Void, Address[]&gt; {
    @Override
    final protected Address[] doInBackground(LatLng... arg0) {
        List&lt;Address&gt; res = new ArrayList&lt;&gt;();
        if (arg0.length &gt; 0) {
            String address = String.format(Locale.getDefault(), "https://maps.googleapis.com/maps/api/geocode/json?latlng=%1$f,%2$f&amp;sensor=false&amp;language=" + Locale.getDefault(), arg0[0].latitude, arg0[0].longitude);
            try {
                URL url = new URL(address);
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                InputStreamReader in = new InputStreamReader(conn.getInputStream());
                StringBuilder jsonResults = new StringBuilder();

                int read;
                char[] buff = new char[1024];
                while ((read = in.read(buff)) != -1) {
                    jsonResults.append(buff, 0, read);
                }
                String json = jsonResults.toString();
                JSONObject jsonObject = new JSONObject(json);
                AFLog.d(json);

                if ("OK".equalsIgnoreCase(jsonObject.getString("status"))) {
                    JSONArray results = jsonObject.getJSONArray("results");
                    if (results.length() &gt; 0) {
                        for (int i = 0, iCnt = results.length(); i &lt; iCnt; i++) {
                            try {
                                JSONObject result = results.getJSONObject(i);

                                Address resultAddress = new Address();
                                resultAddress.address = result.getString("formatted_address");
                                resultAddress.placeId = result.optString("place_id");
                                JSONObject geometry = result.optJSONObject("geometry");
                                if (geometry != null) {
                                    geometry = geometry.optJSONObject("location");
                                    if (geometry != null) {
                                        resultAddress.lat = geometry.getDouble("lat");
                                        resultAddress.lng = geometry.getDouble("lng");
                                    }
                                }

                                JSONArray components = result.getJSONArray("address_components");
                                for (int a = 0; a &lt; components.length(); a++) {
                                    JSONObject component = components.getJSONObject(a);
                                    JSONArray types = component.getJSONArray("types");
                                    for (int j = 0; j &lt; types.length(); j++) {
                                        String type = types.getString(j);
                                        switch (type) {
                                            case "premise":
                                                resultAddress.premise = component.optString("long_name");
                                                break;
                                            case "administrative_area_level_1":
                                                resultAddress.administrative_area_level_1 = component.optString("long_name");
                                                break;
                                            case "sublocality_level_1":
                                                resultAddress.sublocality_level_1 = component.optString("long_name");
                                                break;
                                            case "sublocality_level_2":
                                                resultAddress.sublocality_level_2 = component.optString("long_name");
                                                break;
                                            case "sublocality_level_3":
                                                resultAddress.sublocality_level_3 = component.optString("long_name");
                                                break;
                                            case "sublocality_level_4":
                                                resultAddress.sublocality_level_4 = component.optString("long_name");
                                                break;
                                            case "country":
                                                resultAddress.country = component.optString("long_name");
                                                break;
                                            case "postal_code":
                                                resultAddress.postal_code = component.optString("long_name");
                                                break;
                                            case "political":
                                            case "sublocality":
                                                break;
                                            default:
//                                                  AFLog.d("Not catched : " + type);
                                                break;
                                        }
                                    }
                                }
                                res.add(resultAddress);
                            } catch (JSONException e) {
                                AFLog.e(e);
                            }
                        }
                    }
                }
            } catch (Exception e) {
                AFLog.e(e);
            }
        }
        Address[] array = new Address[res.size()];
        res.toArray(array);
        return array;
    }
}
</code></pre>

<p>이 코드도 마찬가지로 참고만 하기 바란다. 내부적으로 사용중인 클래스들이 있어서 그대로 넣으면 동작하지 않는다. 하지만 코드를 보면 반환 클래스에 관련된 부분이므로 어디를 수정해야 할지 바로 알 수 있을 것으로 보인다.</p>
]]></content>
  </entry>
  
</feed>
