<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: db | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/db/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-12-05T21:42:54+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MySql에서 숫자로 시작하는 문자열의 정렬 문제]]></title>
    <link href="http://blog.asamaru.net/2015/09/17/sort-of-strings-that-start-with-numbers-in-mysql/"/>
    <updated>2015-09-17T07:29:04+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/17/sort-of-strings-that-start-with-numbers-in-mysql</id>
    <content type="html"><![CDATA[<p>[100A, 9B, 10C] 와 같은 문자열의 배열을 정렬한다고 가정하자. 인간이 생각할 때 바른 정렬 결과는 [9B, 10C, 100A]일 것이다.(사람에 따라 다를 수는 있지만 나는 이렇게 되길 원한다.)
그런데 이 문제를 프로그램에서 처리하려고 그냥 정렬을 수행한다면 어떤 결과가 나올까?</p>

<p>결과는 [100A, 10C, 9B] 이다. 간단히 결과를 확인하기 위해 php에서 돌려본 결과이다.</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;100A&#39;</span><span class="p">,</span> <span class="s1">&#39;9B&#39;</span><span class="p">,</span> <span class="s1">&#39;10C&#39;</span><span class="p">];</span>
<span class="nb">sort</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
<span class="nb">print_r</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>

<span class="c1">// 실행 결과</span>
<span class="k">Array</span>
<span class="p">(</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="nx">A</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="nx">C</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="mi">9</span><span class="nx">B</span>
<span class="p">)</span>
</code></pre></div>
<p>왜 이런 정렬 결과가 나올까? 어떻게보면 당연할 결과이다. 프로그램에서는 숫자든 문자든 문자열 내부에서는 숫자 코드로 처리된다. 그러므로 맨 첫자리 문자부터 비교를 시작하여 차례로 정렬하므로 1로 시작하는 문자열이 처음으로 들어온다. 100A, 10C 두 문자열을 비교하자면 셋째자리에서 0과 C가 비교되어 0을 가진 100A가 먼저 들어가게 된다.</p>

<p>그럼 인간이 생각하는 것처럼 정렬되게 하려면 어떻게 할까? 복잡하게 생각하자면 한도 끝도 없이 복잡할 수 있지만 간단하게 생각하자면 비교되어야 할 문자의 위치를 맞추어주면 원하는 결과를 얻을 수 있다.</p>

<p>다른 언어나 상황에서도 마찬가지 방법으로 적용할 수 있지만 이번엔 MySql에서 정렬시 이 부분이 필요했기 때문에 MySql에서 사용한 방법을 아래에 적는다.</p>
<div class="highlight"><pre><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span><span class="p">,</span> <span class="nf">LPAD</span><span class="p">(</span><span class="n">strField</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">strFieldOrder</span> <span class="k">FROM</span> <span class="n">table1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">strFieldOrder</span><span class="p">;</span>
</code></pre></div>
<p>여기서 주의할 것은 7이라는 부분을 데이터의 길이가 모두 포함될 수 있는 적절한 값으로 지정해야 한다는 것이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySql에서 float 필드 동일값 비교]]></title>
    <link href="http://blog.asamaru.net/2015/09/16/check-for-equality-on-a-mysql-float-field/"/>
    <updated>2015-09-16T18:09:56+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/16/check-for-equality-on-a-mysql-float-field</id>
    <content type="html"><![CDATA[<p>이번에 작업하면서 mysql의 float 필드를 사용할 일이 있었다. 사실 오랜기간동안 mysql을 사용해 오면서 float 필드를 사용해 본 적이 많지 않았고 float 필드를 범위 검사가 아닌 동일값 검사를 할일이 없었다.</p>

<p>이번 작업에서는 float 필드의 동일값 검사를 하면서 당연히 아래와 같이 query를 만들면 될 줄 알았다.</p>
<div class="highlight"><pre><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">TABLE1</span> <span class="k">WHERE</span> <span class="n">FloatField</span> <span class="o">=</span> <span class="mi">10</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>그런데 분명 동일한 값이 있음에도 불구하고 검색된 결과가 없었다. 처음엔 어의가 없었다. 당연히 동일한 값이 있는데 왜 검색이 되지 않을까?
그래서 구글에서 검색을 해보니 float 필드는 &quot;=&quot;을 이용한 동일값 검사를 할 수 없었다. 아래는 float 필드의 동일값 검사를 하는 예시다.</p>
<div class="highlight"><pre><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">TABLE1</span> <span class="k">WHERE</span> <span class="nf">ABS</span><span class="p">(</span><span class="n">FloatField</span> <span class="o">-</span> <span class="mi">10</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">;</span>
</code></pre></div>
<p>아.. 이런 웬 해괴망측한 방법이란 말인가? 사실 여러글에서 보면 문자열로 Casting(변환)해서 검사하는 방법 등도 있었다. 그리고 주의할 사항은 <code>1e-6</code>값을 정하는 부분이다. 소숫점의 길이에 따라 값을 어느 정도 조정해야 하는 듯 하다. 소숫점 2자리 기준에서 <code>1e-6</code> 적용시 같은 값으로 인식하지 않았다. 그래서 <code>1e-4</code>를 적용했었다. 어짜피 2자리까지 값이니 충분한 오차 한계긴하다.</p>

<p>MySql 사이트에서 보면 <a href="https://dev.mysql.com/doc/refman/5.0/en/problems-with-float.html">B.5.5.8 Problems with Floating-Point Values</a> 이라는 글이 있다.</p>

<p>첫줄에 설명된 것과 같이 mysql에서는 부동 소수점을 정확한 값으로 저장하지 않기 때문에 내부적으로 나타내는 값이 동일하지 않을 수 있다고 되어 있다.</p>

<p><a href="http://www.mysqlkorea.com/sub.html?mcode=manual&amp;scode=01&amp;m_no=21645&amp;cat1=11&amp;cat2=331&amp;cat3=339&amp;lang=k">한글매뉴얼 5.0 - 11.1.1. 숫자 타입 개요</a>에는 아래와 같이 설명되어 있다.</p>

<blockquote>
<p>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]
작은(단일 정밀도 - single-precision) 부동 소수점 수. 사용 가능한 값은 -3.402823466E+38 에서 -1.175494351E-38, 0 이고, 그리고 1.175494351E-38 에서3.402823466E+38 까지다. 이 범위는 이론적인 한계이고, IEEE 표준에 근거를 하고 있다. 실제로는 여러분이 사용하는 H/W 또는 OS에 근거하여 약간 작게 된다.
M은 전체 자릿 수이고 D는 소수점 뒷자리를 가리킨다. 만일 M 과 D가 생략되면, H/W가 허용하는 범위로 값을 저장한다. 단일 정밀도 부동 소수점 숫자는 대략 7개의 십진 자리수를 갖는다.
UNSIGNED를 지정 하면, 음수 값을 허용하지 않는다.
FLOAT를 사용하면 예상하지 못한 결과가 나올 수도 있는데, 그 이유는 MySQL에서의 모든 계산은 이중 정밀도(double-precision)로 실행되기 때문이다. Section A.5.7, “Solving Problems with No Matching Rows”를 참조.</p>
</blockquote>

<p>원인은 설명되어 있지만 사실 왜 이래야만 하는 것인지 이해는 잘되지 않는다. 원래 부동 소수점에 대한 문제는 여러 프로그램에서 있는 문제이긴하나 mysql에서도 이 문제가 있을 줄은 생각하지 못했다.</p>

<p>어쨌든 보다 다양한 예시와 설명은 위에 링크한 mysql 메뉴얼을 참고하면 된다. 아니면 부동소숫점이 아닌 고정소숫점 타입을 사용해도 된다. <a href="http://www.mysqlkorea.com/sub.html?mcode=manual&amp;scode=01&amp;m_no=21681&amp;cat1=11&amp;cat2=332&amp;cat3=0&amp;lang=k">숫자 타입</a> 메뉴얼에서 DECIMAL 관련된 내용을 참고하자.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[두지점(WGS84 좌표)간 km 거리 계산 함수(php, mysql, javascript)]]></title>
    <link href="http://blog.asamaru.net/2015/09/14/calculate-distance-between-two-wgs84-points/"/>
    <updated>2015-09-14T14:52:05+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/14/calculate-distance-between-two-wgs84-points</id>
    <content type="html"><![CDATA[<p>WGS84 좌표계는 <a href="https://ko.wikipedia.org/wiki/%EC%84%B8%EA%B3%84_%EC%A7%80%EA%B5%AC_%EC%A2%8C%ED%91%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C">위키피디아</a>에 따르면 다음과 같다.</p>

<blockquote>
<p>World Geodetic System (WGS) 1984년에 제정된 범 지구적 측위 시스템으로 지도학, 측지학, 항법에 많이 사용된다.</p>

<p>통칭 및 약칭은 WGS 84 (aka WGS 1984, EPSG:4326, WGS84)라고 부르며, 2004년에 마지막으로 개정되었다. 이전에 쓰던 초안으로 WGS 72, WGS 66, 그리고 WGS 60이 있다.</p>
</blockquote>

<p>기존에는 네이버 지도 등에서 KTM 좌표를 사용하기도 했지만 요즘엔 WGS84 좌표를 주로 사용한다.</p>

<p>이번에 작업을 하면서 WGS84 좌표 두개의 거리를 계산해야하는 일이 생겼다. 관련된 내용을 찾아보니 여러자료가 있긴하지만 바로 사용할만한 정보를 찾기가 어려웠다. 사실 계산방법이 조금씩 다르다(따라서 아래의 내용이 아주 정확한 값은 아닐 수 있다). 그래서 조사한김에 내용을 정리해둔다.</p>

<p>아래는 몇가지 언어로 구현된 함수들이다. 반환값은 모두 km 단위로 반환된다. 필요한 단위로의 변환은 당연히 산술계산을 하면된다.</p>

<h2 id="php">php</h2>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">function getDistance($lat1, $lon1, $lat2, $lon2)</span>
<span class="x">{</span>
<span class="x">    $earth_radius = 6371;</span>
<span class="x">    $dLat = deg2rad($lat2 - $lat1);</span>
<span class="x">    $dLon = deg2rad($lng2 - $lng1);</span>
<span class="x">    $a = sin($dLat/2) * sin($dLat/2) + cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * sin($dLon/2) * sin($dLon/2);</span>
<span class="x">    $c = 2 * asin(sqrt($a));</span>
<span class="x">    $d = $earth_radius * $c;</span>
<span class="x">    return $d;</span>
<span class="x">}</span>
</code></pre></div>
<h2 id="mysql">MySql</h2>

<p>함수로 구현된 예시이지만 당연히 query에서 return 부분을 직접 사용해도 된다.</p>
<div class="highlight"><pre><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="n">FUNCTION</span> <span class="nf">distance_between</span> <span class="p">(</span><span class="n">from_lat</span> <span class="kt">DECIMAL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">from_lng</span> <span class="kt">DECIMAL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">to_lat</span> <span class="kt">DECIMAL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">to_lng</span> <span class="kt">DECIMAL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="n">RETURNS</span> <span class="kt">DECIMAL</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">RETURN</span> <span class="mi">6371</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="nf">ATAN2</span><span class="p">(</span><span class="nf">SQRT</span><span class="p">(</span><span class="nf">POW</span><span class="p">(</span><span class="nf">SIN</span><span class="p">(</span><span class="nf">RADIANS</span><span class="p">(</span><span class="n">to_lat</span> <span class="o">-</span> <span class="n">from_lat</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">POW</span><span class="p">(</span><span class="nf">SIN</span><span class="p">(</span><span class="nf">RADIANS</span><span class="p">(</span><span class="n">to_lng</span> <span class="o">-</span> <span class="n">from_lng</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nf">COS</span><span class="p">(</span><span class="nf">RADIANS</span><span class="p">(</span><span class="n">from_lat</span><span class="p">))</span> <span class="o">*</span> <span class="nf">COS</span><span class="p">(</span><span class="nf">RADIANS</span><span class="p">(</span><span class="n">to_lat</span><span class="p">))),</span> <span class="nf">SQRT</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nf">POW</span><span class="p">(</span><span class="nf">SIN</span><span class="p">(</span><span class="nf">RADIANS</span><span class="p">(</span><span class="n">to_lat</span> <span class="o">-</span> <span class="n">from_lat</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">POW</span><span class="p">(</span><span class="nf">SIN</span><span class="p">(</span><span class="nf">RADIANS</span><span class="p">(</span><span class="n">to_lng</span> <span class="o">-</span> <span class="n">from_lng</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nf">COS</span><span class="p">(</span><span class="nf">RADIANS</span><span class="p">(</span><span class="n">from_lat</span><span class="p">))</span> <span class="o">*</span> <span class="nf">COS</span><span class="p">(</span><span class="nf">RADIANS</span><span class="p">(</span><span class="n">to_lat</span><span class="p">))));</span>
</code></pre></div>
<h2 id="javascript">javascript</h2>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">getDistanceFromLatLonInKm</span><span class="p">(</span><span class="nx">lat1</span><span class="p">,</span><span class="nx">lng1</span><span class="p">,</span><span class="nx">lat2</span><span class="p">,</span><span class="nx">lng2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">deg2rad</span><span class="p">(</span><span class="nx">deg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">deg</span> <span class="o">*</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">R</span> <span class="o">=</span> <span class="mi">6371</span><span class="p">;</span> <span class="c1">// Radius of the earth in km</span>
    <span class="kd">var</span> <span class="nx">dLat</span> <span class="o">=</span> <span class="nx">deg2rad</span><span class="p">(</span><span class="nx">lat2</span><span class="o">-</span><span class="nx">lat1</span><span class="p">);</span>  <span class="c1">// deg2rad below</span>
    <span class="kd">var</span> <span class="nx">dLon</span> <span class="o">=</span> <span class="nx">deg2rad</span><span class="p">(</span><span class="nx">lng2</span><span class="o">-</span><span class="nx">lng1</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">dLat</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">dLat</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">deg2rad</span><span class="p">(</span><span class="nx">lat1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">deg2rad</span><span class="p">(</span><span class="nx">lat2</span><span class="p">))</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">dLon</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">dLon</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">atan2</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">a</span><span class="p">));</span>
    <span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">R</span> <span class="o">*</span> <span class="nx">c</span><span class="p">;</span> <span class="c1">// Distance in km</span>
    <span class="k">return</span> <span class="nx">d</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="http://www.mapanet.eu/EN/Resources/Script-Distance.htm">http://www.mapanet.eu/EN/Resources/Script-Distance.htm</a> 이 사이트에서는 여러가지 언어로 사용하는 방법이 나와 있으나 위에 나열된 함수와는 계산이 조금 다르다. 특히 &quot;Earth radius in km (WGS84)&quot;라고 설명된 값이 6378.137를 사용하고 있다.
<a href="https://en.wikipedia.org/wiki/Earth_radius">위키피디아</a>에서 셜명된 Earth radius 값이 6371이기 때문이다.(지구가 둥글기 때문에 지역마다 값의 차이가 있는 것으로 보인다.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySql의 SQL_CALC_FOUND_ROWS와 FOUND_ROWS()]]></title>
    <link href="http://blog.asamaru.net/2015/09/11/using-sql-calc-found-rows-and-found-rows-with-mysql/"/>
    <updated>2015-09-11T19:05:37+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/11/using-sql-calc-found-rows-and-found-rows-with-mysql</id>
    <content type="html"><![CDATA[<p>MySql에는 SQL_CALC_FOUND_ROWS과 FOUND_ROWS() 라는 기능이 있다.일반적인 쿼리를 작성하는 상황에서는 크게 사용할 일이 없는 기능들이지만 알아두면 정말 유용하게 사용할 수 있다.</p>

<p>어디다 활용을 할지에 대해 보기 전에 각 기능이 무슨 역할을 하지는지부터 알아보자.</p>

<p>기본적인 동작은 <a href="http://www.mysqlkorea.com/sub.html?mcode=develop&amp;scode=01&amp;lang=k&amp;m_no=21838&amp;cat1=12&amp;cat2=359&amp;cat3=374">mysqlkorea</a>에 설명되어 있으니 참고하면 된다.</p>

<h2 id="sql_calc_found_rows">SQL_CALC_FOUND_ROWS</h2>

<p>SQL_CALC_FOUND_ROWS는 SELECT 쿼리에 사용할 수 있는 MySQL 힌트로 쿼리 결과의 전체 row 수를 임시로 저장하게 합니다. 여기서 중요한 점은 row 수가 반환되는 row 수가 아니라 조건에 해당하는 전체 row 수를 가진다는 것이다. 따라서 LIMIT 0, 10을 지정하여 10개의 row만 가져온다고 하더라도 LIMIT이 없을 때의 쿼리 결과와 같은 row 수를 계산한다.
이 부분이 상당히 중요한 부분이다. 나중에 다시 설명하겠지만 LIMIT에 영향을 받지 않으므로 쿼리 성능을 떨어뜨릴 수 있다.</p>

<h2 id="found_rows">FOUND_ROWS()</h2>

<p>FOUND_ROWS는 직전 쿼리에서 검색된 결과 row 수를 반환한다. 이해를 돕기위해 간단한 쿼리의 결과를 아래에 추가했으니 참고하면 바로 이해가 되리라 생각한다.</p>
<div class="highlight"><pre><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">article</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">...</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="nf">FOUND_ROWS</span><span class="p">();</span>
<span class="o">+--------------+</span>
<span class="o">|</span> <span class="nf">FOUND_ROWS</span><span class="p">()</span> <span class="o">|</span>
<span class="o">+--------------+</span>
<span class="o">|</span>          <span class="mi">120</span> <span class="o">|</span>
<span class="o">+--------------+</span>
<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">article</span> <span class="k">limit</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">...</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="nf">FOUND_ROWS</span><span class="p">();</span>
<span class="o">+--------------+</span>
<span class="o">|</span> <span class="nf">FOUND_ROWS</span><span class="p">()</span> <span class="o">|</span>
<span class="o">+--------------+</span>
<span class="o">|</span>           <span class="mi">10</span> <span class="o">|</span>
<span class="o">+--------------+</span>
<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="nf">FOUND_ROWS</span><span class="p">();</span>
<span class="o">+--------------+</span>
<span class="o">|</span> <span class="nf">FOUND_ROWS</span><span class="p">()</span> <span class="o">|</span>
<span class="o">+--------------+</span>
<span class="o">|</span>            <span class="mi">1</span> <span class="o">|</span>
<span class="o">+--------------+</span>
<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div>
<p>단, 여기서 주의할 것은 맨 마지막 결과다. &quot;왜 10이 아닐까?&quot; 하는 생각을 할 수 있으나 맨처음 적었듯이 &quot;직전&quot; 쿼리의 결과 row 수를 반환하기 때문에 1이 나오는 것이다.(이전 <code>select FOUND_ROWS();</code>의 결과 row 수 반환)</p>

<h2 id="sql_calc_found_rows와-found_rows-의-결합">SQL_CALC_FOUND_ROWS와 FOUND_ROWS()의 결합</h2>

<p>각각의 기능을 확인했으니 둘이 만나면 어떻게 되는지 알아보자. 일단 아래의 쿼리 결과를 보자.</p>
<div class="highlight"><pre><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="k">SQL_CALC_FOUND_ROWS</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">article</span> <span class="k">limit</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">...</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="nf">FOUND_ROWS</span><span class="p">();</span>
<span class="o">+--------------+</span>
<span class="o">|</span> <span class="nf">FOUND_ROWS</span><span class="p">()</span> <span class="o">|</span>
<span class="o">+--------------+</span>
<span class="o">|</span>          <span class="mi">120</span> <span class="o">|</span>
<span class="o">+--------------+</span>
<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div>
<p>이해가 되는가? 앞선 예시와 결과가 다르다. SQL_CALC_FOUND_ROWS가 없었다면 FOUND_ROWS()의 결과는 10이었을 것이다. 하지만 SQL_CALC_FOUND_ROWS에서 설명했던 것과 같이 SQL_CALC_FOUND_ROWS 힌트가 추가되면 limit은 무시되고 검색 조건에 해당하는 모든 row 수를 계산하기 때문에 FOUND_ROWS()의 결과가 120이 나오는 것이다.</p>

<h2 id="활용">활용</h2>

<h3 id="페이징">페이징</h3>

<p>게시판 같은 서비스를 만들다보면 필수적으로 들어가는 기능이 페이징 기능이다. 일반적으로 페이징 처리를 위해서는 total row수가 필요한데 이를 처리하기 위해 동일 조건의 쿼리를 두번 사용하여 한번은 count(1), 한번은 필요한 필드를 넣어 쿼리한다. 보통은 대게 이렇게 개발해서 사용하고 크게 문제가 없다.
하지만 데이터의 양이 많거나 쿼리가 복잡해서 성능이 떨어지는 상황을 생각해보자.
예를들어 성능이 떨어지는 쿼리가 처리되는데 0.5초가 걸린다고 가정할 때 페이징을 위해 두번의 쿼리를 해야 한다면 쿼리에 소요되는 시간은 1초가 걸린다. 이 부분을 개선하기 위해 FOUND_ROWS()를 사용할 수 있다.</p>

<p>다시 일반적인 처리로 돌아가서 보면 count 쿼리를 해서 total row 수를 이용해 페이징을 한 후 limit을 지정해 데이터 쿼리를 질의하여 값을 돌려 받는다.</p>

<p>그럼 FOUND_ROWS()를 사용할 때는 어떻게 하는가? 데이터 쿼리를 먼저하되 SQL_CALC_FOUND_ROWS 힌트를 추가하여 질의한다. 그 다음 FOUND_ROWS()를 사용하여 total row 수를 가져와서 페이징 처리를 한다. 간단히 얘기해서 두 쿼리의 순서가 바뀐다.</p>

<p>당연한 얘기지만 빈번히 사용되는 쿼리라면 이렇게까지 성능이 떨어지기 전에 쿼리를 튜닝하고 설계를 변경하는 것이 옳다. 하지만 다양한 쿼리를 필요로 하는 프로그램을 만들다보면 모든 쿼리에 맞는 최적화를 하기는 어려우므로 이런 방법들을 적용하는 것이 필요할 수 있다.</p>

<h4 id="주의">주의</h4>

<p>앞선 설명에서는 원리를 설명하기 위해 간단히 설명했지만 여기에서 중요한 부분이 빠져 있다. FOUND_ROWS가 모든 상황에 최적화되는 것은 아니라는 것이다. DB의 쿼리 성능에 관련해서는 변수와 고려해야할 사항이 워낙 많기 때문에 여기서 다 설명하기는 어렵고 중요한 부분만 설명하겠다.</p>

<p>서두에 SQL_CALC_FOUND_ROWS를 설명하면서 limit과 무관하게 동작함에 따라 성능이 떨어질 수 있다는 점을 적었다. 여기서 하고자하는 이야기의 중요한 부분이 이 부분이다.</p>

<p>쿼리가 index를 탈 수 있다면 limit 범위만 탐색하여 결과를 찾게되므로 쿼리 성능이 떨어지지 않는다. 그렇다면 &quot;index를 타지 않는다면?&quot; 어떤가? row들을 차례로 스캔하면서 조건을 검사해 limit 범위가 채워지면 스캔을 멈춘다. limit 0, 10을 지정했을 때를 가정하고 운이 좋아서 조건에 해당하는 데이터가 상위 10개에 속해 있다면 성능은 index를 타는 것과 거의 동일할 것이다. 반대로 데이터가 맨 마지막 10개라면 전체를 스캔하게 되므로 성능은 떨어질 것이다. 최선과 최악의 경우만 있는 것은 아니니 평균을 내자면 50% 정도를 스캔하면 결과를 얻을 수 있다는 결론을 얻는다.(실제론 맞지 않을 수 있다. 그냥 이론상 그렇다는 것이다.)</p>

<p>자 다시 SQL_CALC_FOUND_ROWS로 돌아가보면 SQL_CALC_FOUND_ROWS가 없다면 평균 50%만 스캔하면 끝날 쿼리를 SQL_CALC_FOUND_ROWS를 넣음으로 인해서 100%를 스캔하게 된다(전체 row수를 세어야 하므로). 따라서 성능이 떨어질 수 있다는 것이다.</p>

<p>그렇다면 &quot;이걸 쓰지말아야 한다는 것인가?&quot;라고 생각될 수 있다. 하지만 다음의 경우를 생각해보자.
앞서 설명에서 데이터를 스캔하는 과정에서는 정렬에 대한 문제를 제시하지 않았다. 그럼 정렬을 포함해보자.
정렬된 결과에서 10개를 가져와야 한다면, 게대가 정렬이 index에 의해 정렬이되지 않는다면... 결국은 정렬을 위해서 전체 스캔이 일어나고 heap 테이블이 만들어지고 정렬을 해야한다.</p>

<h4 id="결론">결론</h4>

<p>결론은 위의 경우는 어짜피 100% 스캔이 일어난다는 것이다. 따라서 어짜피 100% 스캔을 두번 해야 할 상황이라면 SQL_CALC_FOUND_ROWS를 사용하여 1번으로 줄임으로써 쿼리 질의 시간을 절반으로 줄일 수 있다.</p>

<p>사실 쿼리라는 것이 검색 조건, 정렬, index 등등 여러가지 변수에 의해 성능이 천차만별로 달라질 수 있기 때문에 여기서 여러가지 경우를 예를들어 설명하기는 힘들다. 이런 내용으로만 정리해도 책이 몇권이다.(유명한 책중에 대용량 데이터베이스 솔루션이란 책이 있다. 이와 관련된 내용도 포함되어 있다.)</p>

<p>일부 사람들은 index를 타지 목하면 SQL_CALC_FOUND_ROWS를 사용하는게 낫다라고 하기도 한다. 위에 설명을 했듯이 index를 타지 못하더라도 전체 스캔을 하는 것보다 더 나은 상황이 만들어질 수 있는 경우는 많기 때문에 index를 타지 못하는 것만으로 SQL_CALC_FOUND_ROWS를 선택하는 것은 맞지 않다.</p>

<p>최종 결론은 어짜피 전체 스캔을 피할 수 없다면 이왕 스캔한 김에 row수를 세어두어서 count 쿼리를 위해 다시 성능을 죽이지는 말자는 것이다.</p>

<h3 id="group-by-결과-row-수">Group By 결과 row 수</h3>

<p>앞의 페이징에서 너무 긴 이야기를 했으므로 여기는 조금 간단히 하겠다. 어짜피 비슷한 얘기가 되므로.
Group By 결과 row 수를 얻으려면 어떻게 해야할까? 간단할 듯 하지만 그리 간단하지는 않다.(내가 모르는 방법이 있다면 할 수 없고...)</p>

<p>가장 쉽게 접근하는 방법은 서브 쿼리를 사용하는 방법일 것이다. Group By 쿼리를 서브 쿼리로 넣어 count를 사용하는 방법. 대략 아래와 같다.</p>
<div class="highlight"><pre><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">cnt</span> <span class="k">from</span> <span class="n">article</span> <span class="k">group</span> <span class="k">by</span> <span class="n">apartmentIdx</span><span class="p">)</span> <span class="n">APT</span><span class="p">;</span>
<span class="o">+----------+</span>
<span class="o">|</span> <span class="nf">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+----------+</span>
<span class="o">|</span>        <span class="mi">4</span> <span class="o">|</span>
<span class="o">+----------+</span>
<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div>
<p>다음은 distinct를 사용하는 방법이다. distinct에 대해서는 주제를 벗어나니 여기서는 생략.</p>
<div class="highlight"><pre><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="nf">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">apartmentIdx</span><span class="p">)</span> <span class="k">as</span> <span class="n">cnt</span> <span class="k">from</span> <span class="n">article</span><span class="p">;</span>
<span class="o">+-----+</span>
<span class="o">|</span> <span class="n">cnt</span> <span class="o">|</span>
<span class="o">+-----+</span>
<span class="o">|</span>   <span class="mi">4</span> <span class="o">|</span>
<span class="o">+-----+</span>
<span class="mi">1</span> <span class="n">row</span> <span class="k">in</span> <span class="kt">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div>
<p>그외에도 오라클이나 다른 DB에서는 또 다른 방법들도 있다.</p>

<p>그렇다 하더라도 group by를 한다는 것은 어짜피 전체를 스캔해서 결과를 얻는 과정(다른 조건에 의해 아닌 경우도 있을 수는 있다)을 거치므로 SQL_CALC_FOUND_ROWS를 사용하여 결과 row를 세어두는 것이 성능에 많은 도움을 줄 수 있다.</p>

<h2 id="정리">정리</h2>

<p>그 외에도 여러가지 활용 방법이 있을 수 있으나 대표적인 사례만 나열했다. 다시 한번 강조하지만 이 방법은 만능이 아니다. 전체 스캔(Full Scan)을 피할 수 없는 상황에서 이왕 전체 스캔한거 count를 위해 다시 하지 않도록 활용하는 전략이 가장 적합하다.</p>

<p>또한 index를 타지 않는다고 무조건 full scan이 일어나지는 않는다. 이 부분에서 가장 중요한 것은 검색조건 보다 정렬이다. order by를 사용하지 않고 원하는 정렬이 되도록 설계한다면 full scan을 충분히 배제할 수 있다.(이 부분은 주제에서도 많이 벗어나고 설명하자면 얘기가 다시 무지하게 길어지므로 일단 패스.)</p>
]]></content>
  </entry>
  
</feed>
