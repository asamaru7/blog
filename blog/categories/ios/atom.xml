<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-11-16T21:42:28+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XCode에서 storyboard 선택시 Crash가 발생할 경우]]></title>
    <link href="http://blog.asamaru.net/2015/11/16/xcode-crashes-when-selecting-the-main-storyboard/"/>
    <updated>2015-11-16T20:55:08+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/16/xcode-crashes-when-selecting-the-main-storyboard</id>
    <content type="html"><![CDATA[<p>최근엔 XCode로 작업하는 일이 많아졌다. 안드로이드 개발과 웹 개발도 함께하지만 iOS 작업이 급하다 보니 주로 이 일을 하고 있다.
XCode는 사용하면 할수록 잘 만들었다는 생각이 든다. 단, 코드 포멧팅 기능이 없다거나 소스 선택이 조금 부자연스럽다거나(이건 적응의 문제일 수 있다) 하는 것처럼 안드로이드 스튜디오에 비해 불편한 부분들이 있긴하다. 하지만 인터페이스 빌더 등의 도구들은 아주 잘 만들어져 있으며 결정적으로 빌드 속도가 무척 빨라서 좋다. 안드로이드 스튜디오도 지난 번에 적었던 <a href="/2015/09/29/android-gradle-builds-speed-up/">Android Gradle 빌드 속도 높이기</a>에서 설명했던 것처럼 빌드 속도가 다소 개선되었지만 XCode에 비교도 되지 않는다.</p>

<p>인터페이스 빌더의 사용에 대해서는 개발자들 사이에서도 논란이 많다. 개발시 인터페이스 빌더를 사용할 것인가 하드 코딩으로 UI를 개발할 것인가? 둘 다 장단점이 있는 것은 명확하지만 개인적으로는 최대한 인터페이스 빌더를 사용하는 것이 옳다고 생각한다. 스토리보드와 같은 기능을 사용해서 앱 전체의 흐름을 파악하기 쉽도록 개발할 수 있으며 보여질 화면을 바로 보면서 작업하므로 개발 및 유지보수도 용이하다. 다만 인터페이스 빌더의 설정이 코드상에서 보여지지 못하므로 코드를 볼 때 혼란스럽게 보일 수는 있다. 그래서 나는 코드 흐름 상에서 중요한 요소는 인터페이스와 별개로 소스에서도 설정을 해주는 편이다(아주 중요할 경우만).</p>

<p>서론이 길어졌는데 오늘 이야기는 지금 부터다. 나름 선호하는 이 인터페이스 빌더에는 치명적인 약점이 있다. 이건 내가 XCode를 처음 접한 3버전대에서부터 현재의 7버전까지도 완전히 해결되지 않는 문제다. 그 약점은 바로 Crash가 잘 발생한다는 점과 설정이 엉키면 정말 난해한 상황을 만나게 된다는 것이다.</p>

<p>현재까지의 나의 해결법은 해당 부분을 통째로 지우고 새로 설정하는 것이다. 정말 최악의 방법이지만 항상 오랜 시간을 해결해 보려고 애써봐도 결론은 대부분 새로 작성하는 것이었다. 사실 이런 문제가 아주 빈번한 것은 아니지만 한번씩 발생하면 치명적이다(환장한다).</p>

<p>최근에는 작업을 하면서 <a href="https://www.jetbrains.com/objc/">AppCode</a>를 함께 사용하는 편인데 아무래도 jetbrains에서 만들다보니 단축키도 익숙하고 결정적인 코드 포멧팅 기능 때문에...
어쨌든 AppCode에서도 storyboard를 수정하려고하면 결국 XCode를 띄워준다.</p>

<p>이렇게 개발 도구를 섞어써서 그런건지 내가 뭔가를 잘못했는지는 몰라도 이번에 제대로 일이 벌어졌다. 옛날 같으면 nib파일이 따로 있어서 문제가 발생해도 그 파일만 새로 작업하면 되는데 이번엔 스토리보드로 작업되어 있었는데 그 파일을 선택만 해도 XCode가 죽는 것이다. 도저히 새로 작성한다는 것은 불가능 했다. 아직 개발 초기라 화면이 엄청 많은 것은 아니었지만 그래도 주요 화면들을 다 작성해 둔 상태라 다시 작성하기엔 무리였다.</p>

<p>그래서 인터넷에서 또 다시 해결 방법들을 찾아봤다. 사실 결론을 미리 이야기하자면 나는 아래의 방법들을 모두 시도해 보았으나 성공하지 못했다.  하지만 이 방법들로 효과를 봤다는 사람들이 있어서 기록성으로 한번 남겨두려고 한다.</p>

<p><strong>1. XML로 열기</strong></p>

<ul>
<li>스토리보드 파일을 오른쪽 클릭해서 &quot;Open As&quot; &gt; &quot;Source Code&quot; 메뉴를 이용해 XML 코드를 편집기에서 연다.</li>
<li>의미없는 글자를 넣었다가 빼고 저장한다.</li>
<li>다시 스토리보드 파일을 오른쪽 클릭해서 &quot;Open As&quot; &gt; &quot;Interface Builder - Storyboard&quot;로 다시 연다.</li>
</ul>

<p><strong>2. Autolayout 기능 끄기</strong></p>

<p>이 Autolayout에 대한 사람들의 이야기가 많았다. Autolayout이 새로 나오면서 많은 문제들이 있었던 것으로 보인다. 이제는 문제가 많이 줄어든 것으로 보이나 혹시나 도움이 될지도 모르겠다.</p>

<ul>
<li>스토리보드 파일을 오른쪽 클릭해서 &quot;Open As&quot; &gt; &quot;Source Code&quot; 메뉴를 이용해 XML 코드를 편집기에서 연다.<br></li>
<li><code>useAutolayout=&quot;YES&quot;</code> 부분을 찾아 <code>useAutolayout=&quot;NO&quot;</code>로 변경한다.</li>
<li>다시 스토리보드 파일을 오른쪽 클릭해서 &quot;Open As&quot; &gt; &quot;Interface Builder - Storyboard&quot;로 다시 연다.</li>
</ul>

<p><strong>3. xcuserdata 삭제</strong></p>

<ul>
<li>Xcode를 닫는다.</li>
<li>.xcodeproj, .xcworkspace 파일을 우클릭하여 &quot;패키지 내용보기&quot;를 선택한다.</li>
<li>xcuserdata 폴더를 삭제한다.</li>
</ul>

<p><strong>4. XCode 초기화</strong></p>

<p>이 방법은 XCode 설정을 초기화하는 것으로 권장하지는 않는다. 터미널에서 아래의 명령을 입력한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>defaults delete com.apple.dt.Xcode
</code></pre></div>
<p><strong>5. 오류 발생 부분 찾아 제거하기</strong></p>

<p>이 방법은 최후의 방법으로 내가 사용한 방법이다. storyboard 파일을 소스 상태(XML)로 열어 scene 단위로 삭제 해본다. 단, 삭제하기 전 원본 백업은 필수. 이렇게 하나씩 제거하면서 XCode에서 파일을 열어 시도해보면서 원인이 되는 scene을 찾는다. 원인이 되는 scene을 찾았다면 부분적으로 코드들을 제거해가면서 정확한 오류 지점을 찾는다. 운이 좋아 부분적 오류였다면 이 방법으로 최소한의 손실로 문제를 해결할 수 있다. 단, 찾을 수 없다면 해당 scene을 통째로 버려야 한다.</p>

<p>결론적으로 명쾌한 답을 주지 못해 미안하지만 나도 아직은 답을 찾지 못했다. 오류가 발생할 때마다 열심히 애플에 오류 보고를 보내고 있지만 당연히 신속한 해결은 없다. 어쨌든 이런 문제를 만나지 않기를 바라며 혹시라도 문제가 발생한다면 위 방법들을 시도해보길 바란다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[안드로이드 Crash Report 도구 : ACRA에서 Fabric(Crashlytics)으로의 전환]]></title>
    <link href="http://blog.asamaru.net/2015/11/11/from-acra-to-fabric/"/>
    <updated>2015-11-11T20:33:16+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/11/from-acra-to-fabric</id>
    <content type="html"><![CDATA[<p>지난 글 <a href="/2015/10/01/android-acra-please-configure-buildconfigclass-in-your-acra-config/">ACRA : Please configure &#39;buildConfigClass&#39; in your ACRA config 오류</a>와 <a href="/2015/09/25/android-6-apache-http-client-removal/">Android 6(API 23 : marshmallow) : Apache HTTP 클라이언트 제거</a>에서 언급했던 것처럼 안드로이드 Crash Report 도구로 ACRA를 사용중이었다.
ACRA 사용중에 만난 오류를 해결하기 위해 시간을 들여서 원인을 찾고 개발자에게 전달해서 개선을 요청할 정도로 나름 애용하려던 도구였는데 오늘 <a href="https://fabric.io">Fabric(Crashlytics)</a>으로 바꿔버렸다.</p>

<p>사실 처음부터 대체할 목적이 있었던 것은 아니었다. 안드로이드용으로 제작된 앱을 iOS용으로도 제작할 일이 있어 개발을 진행하던 중 안드로이드의 ACRA 같은 도구가 iOS에도 있을 것이라는 생각에 몇가지를 찾아보고 있었다. 그때 눈에 띄는 것이 <a href="https://try.crashlytics.com/">Crashlytics</a> 였다(<a href="https://gist.github.com/rino0601/018c7f22aeb23cf2e2a0">Crashlytics 소개 + Android Studio에서 적용하는 방법</a>).</p>

<p>그런데 이 Crashlytics라는 서비스를 운영하는 회사가 트위터에 인수가 되었다(<a href="http://besuccess.com/2013/01/28496/">앱 충돌 리포트 서비스 Crashlytics, 트위터에 인수되다</a>). 그래서 조금 더 알아보니 트위터에서 <a href="https://fabric.io">Fabric</a>이라는 것을 새로 내놓았다.</p>

<p><a href="https://fabric.io">Fabric</a>이 무엇인지에 대해서는 트위터 한글 블로그의 &quot;<a href="https://blog.twitter.com/ko/2014/introducing-fabric-kr">패브릭(Fabric)을 소개합니다.</a>&quot;를 보면 잘 설명되어 있다.</p>

<blockquote>
<p>패브릭(Fabric)은 앱 개발자들이 흔히 직면하는 안정성, 사용자 확보, 수익성, 사용자 인증의 이슈들&gt;을 해결해 줄 세 가지의 모듈형 키트들로 이루어져 있습니다. 패브릭은 크래시리틱스(Crashlytics), 모펍(MoPub), 트위터 등의 서비스를 통합해 개발자들이 더 안정적인 앱을 만들도록 돕습니다. 패브릭은 앱 개발자들이 세계 최고의 모바일 애드 익스체인지(ad exchange)를 통해 수익을 확보할 수 있게 하며, 트위터 로그인 기능과 실시간 콘텐츠 스트림 기능을 통해 더 많은 사용자에 콘텐츠를 전달할 수 있게 하거나 더욱 간단히 사용자를 인증할 수 있도록 해줍니다.</p>
</blockquote>

<p>나는 우선 최초 목적이었던 iOS를 위한 Crash Report 도구의 설치를 위해 xcode 프로젝트에 <a href="https://fabric.io">Fabric</a>을 추가했다. 설치 과정은 복잡하지는 않으나 몇가지 설정할 부분들이 있어서 자칫 까다로워질 수 있지만 <a href="https://fabric.io">Fabric</a>에서 관련 도구를 워낙에 잘 제공 해줘서 시키는대로 따라만 하면 큰 무리없이 적용할 수 있다. &quot;기회가 되면 설치 과정을 글로 남길까?&quot; 생각했었지만 설치 도구가 워낙 잘되어 있어 &quot;굳이 내가 다시 설명할 필요가 있을까?&quot;라는 생각이다. 그 정도로 잘 되어있다. 다만 기본 설치 후 Debug 모드에서는 로그 수집을 하지 않도록 설정하는 등의 몇가지 안내가 필요한 부분들이 있는데 이건 시간이되면 따로 글을 남기려고 한다. 사실 이 부분도 메뉴얼로 모두 제공되고 있으나 막상 찾으려니 귀찮은 것들이다.</p>

<p>결론적으로는 아주 만족스러웠다. Crash Report가 잘되는 것은 물론이고 Hook을 걸 수 있도록 하는 기능도 제공되고 있어서 기존에 ACRA에서 연결해 두었던 자체 로그 수집기로도 기존처럼 정보를 전달하는 것이 가능했다(정확히 이야기 하자면 기존과 동일한 내용을 전달하는 것은 아니고 오류 발생 이벤트만 전달된다). 그리고 <a href="https://fabric.io">Fabric</a>에는 <a href="https://try.crashlytics.com/">Crashlytics</a> 외에도 <a href="https://answers.io/">Answers</a>라는 모듈도 함께 제공된다(사실 더 많은 것들이 있다). 이 모듈은 구글 어날리틱스 처럼 앱에 대한 이벤트를 수집하여 보고서를 제공해 준다. 결정적으로 이 모든 것이 무료.</p>

<p>그래서 안드로이드용 앱에서도 ACRA를 걷어내고 Fabric을 적용했다. 역시 아주 만족스럽다. ACRA에서 보내주는 무지막지한 Crash 로그 대신 잘 정리된 로그를 확인할 수 있게 되었다.</p>

<p>앞선 설명처럼 <a href="https://fabric.io">Fabric</a>에는 여러가지 모듈들이 있는데 이들 중 일부는 각각 독립적인 서비스를 가지고 있다(<a href="https://try.crashlytics.com/">Crashlytics</a>와 <a href="https://answers.io/">Answers</a> 처럼). 이 부분에 관련해서는 트위터 한글 블로그의 &quot;<a href="https://blog.twitter.com/ko/2014/introducing-fabric-kr">패브릭(Fabric)을 소개합니다.</a>&quot;의 내용 마지막에 아래와 같이 안내 되어있다.</p>

<blockquote>
<p>패브릭(Fabric)은 트위터만의 작품이 아닙니다. 패브릭(Fabric)이 가능하도록 키트(Kits)들의 관리, 설치, 업데이트에 관여하는 모든 SDK 벤더들이 만들어낸 것이라고 생각합니다. 당신이 SDK를 관리하는 사람이고, 트위터와 함께 일하고 싶다면 패브릭 파트너십 담당(<a href="mailto:partners@fabric.io">partners@fabric.io</a>)에 메일을 보내 주시길 바랍니다. 개발자 여러분들의 연락을 기다리고 있겠습니다.</p>
</blockquote>

<p>따라서 각각의 서비스를 사용해도 무방할 것으로 보인다. 하지만 <a href="https://fabric.io">Fabric</a>을 사용함으로써 통합 관리를 할 수 있으며 설치 과정이 아주 단순해진다.</p>

<p><strong>결론 : Crash Report 도구가 필요하다면, iOS와 Android 모두 한 곳에서 관리하고 싶다면, 사용자 이벤트 로깅도 하고 싶다면, <a href="https://fabric.io">Fabric</a>을 적극 추천하고 싶다.</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 7.1의 StoryBoard에서 UIViewController(using Generics)를 Custom Class로 연결할 때 발생하는 오류]]></title>
    <link href="http://blog.asamaru.net/2015/11/04/xcode-storyboard-with-uiviewcontroller-using-generics/"/>
    <updated>2015-11-04T20:46:51+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/04/xcode-storyboard-with-uiviewcontroller-using-generics</id>
    <content type="html"><![CDATA[<p>현재 xcode의 최신 버전은 7.1이다. 이 버전에서(이하 버전은 확인하지 못했다) 스토리보드와 <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html">Generics</a>를 사용한 UIViewController를 연결하는 부분에서 버그가 있다. 버그는 인터페이스 빌더에서 찾지 못하는 문제와 강제 추가시 <code>Unknown class &lt;MyClass&gt; in Interface Builder file</code> 오류를 발생시키는 것이다. 자세한 내용은 아래에 설명하겠다.</p>

<p>일단 <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html">Generics</a>가 어떤 것인지 정보를 더 얻고 싶다면 <a href="http://minsone.github.io/mac/ios/swift-generics-summary/">Swift - Generics 정리</a>를 참고하자.</p>

<p>항상 이런 글을 쓰려고하면 상황을 설명하기가 어렵다. 그렇다고 설명없이 코드만 적어놓으면 어떻게 사용되는지를 알 수 없으니 일단 최선을 다해 보겠다.</p>

<p>UIPageViewController를 사용하고자 하는 상황을 가정하고 설명한다.</p>

<ol>
<li>스토리보드에서 &quot;Page View Controller&quot;를 추가했다.</li>
<li>그 다음에 해야할 작업은 UIPageViewController class를 하나 추가한다.</li>
<li>추가한 class를 인터페이스 빌더에서 Custom Class로 연결한다.</li>
</ol>

<p>위 상황의 결과가 아래의 이미지다. UIPageViewController class로 PageViewController라는 class를 추가한 것이다.</p>

<p><img src="/img/2015-11/04-xcode-storyboard-with-uiviewcontroller-using-generics-1.png" alt="xcode"></p>

<p>비교를 위해 소스도 추가 한다. 사실 볼 것도 없다. 내부 기능은 설명에 필요하지 않아 모두 제거 했다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">import</span> <span class="n">UIKit</span>

<span class="k">class</span> <span class="nl">PageViewController</span><span class="p">:</span> <span class="bp">UIPageViewController</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>이 상황에서 빌드하고 실행하면 아무런 문제가 없다. 당연하다. 가장 일반적인 상황이니까.</p>

<p>이제부터가 내가 버그라고 주장하는 부분의 시작이다. 아래의 코드를 보자.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">import</span> <span class="n">UIKit</span>

<span class="k">class</span> <span class="nl">PageViewController</span><span class="p">:</span> <span class="bp">UIPageViewController</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nl">PageViewControllerChild</span><span class="p">:</span> <span class="n">PageViewController</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">class</span> <span class="n">PageViewControllerT</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;:</span> <span class="bp">UIPageViewController</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nl">PageViewControllerTChild</span><span class="p">:</span> <span class="n">PageViewControllerT</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div>
<p>3개의 class를 추가했다. 하지만 여전히 아무런 기능은 없다. 이 상황에서 위의 이미지와 동일한 상황을 캡춰한 것이 아래 이미지다.</p>

<p><img src="/img/2015-11/04-xcode-storyboard-with-uiviewcontroller-using-generics-2.png" alt="xcode"></p>

<p>비교가 되는가? 달라진 점은 우측의 Custom Class 영역의 Class에서 선택할 수 있는 대상 Class 목록이다.
그런데 위의 소스를 자세히 보고 이 이미지를 봤다면 뭔가 이상함을 느낄 것이다.</p>

<p><strong>바로 <code>PageViewControllerTChild</code>가 목록에 없다는 것이다.</strong> 내가 캡춰를 잘못한 것이 아니다. 실제로 나타나지 않는다.</p>

<p>그렇다면 이게 내가 말하고자 하는 버그인가? 아니다. 그냥 목록에만 나오지 않는 것이라면 조금 귀찮을 뿐 문제되지는 않는다.
자 이제 다시 테스트 해보자. 목록에는 없지만 실제로 class는 존재하므로 강제로 타이핑해서 <code>PageViewControllerTChild</code>를 집어 넣자.
다시 빌드하고 실행. 그런데 기존과 다르게 오류가 난다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">2015-11-04 21:08:24.886 Test[32048:90982] Unknown class _TtC4Test24PageViewControllerTChild in Interface Builder file.
</code></pre></div>
<p>앱을 죽이지는 않으나 해당 View가 아무것도 나오지 않는다.
오류의 내용은 인터페이스 빌더에서 알 수 없는 <code>_TtC4Test24PageViewControllerTChild</code> class에 접근 한다는 것.
이상한 일이다. 분명 해당 class는 존재한다. 오류에 나온 <code>_TtC4Test24PageViewControllerTChild</code>과 이름은 다르지만 분명 같은 class에 접근하려는 것이다.
이 문제가 바로 내가 버그라고 이야기하는 부분이다.</p>

<p>요약하자면 다음과 같다. <strong>Generics를 사용하는 UIViewController는 인터페이스 빌더에 연결되지 않는다.</strong></p>

<p>이 문제 하나로 인해 인터페이스 빌더와 스토리보드를 다 걷어내거나 이것만 따로 처리하기는 싫다.
자.. 이제부터 그럼 해결을 해보자. 해결을 위해서는 원인을 알아야 한다.</p>

<p>중요한 내용은 <a href="http://stackoverflow.com/a/1725893">“Unknown class <MyClass> in Interface Builder file” error at runtime</a>에 설명되어 있다.
이 글은 내가 말하는 Generics와 관련된 상황이 아닌 조금 더 일반적인 상황에 대한 것으로 약간의 차이가 있다. 하지만 거의 유사하므로 해결에 도움을 얻을 수 있었다.
게다가 기본적인 설명은 Objective-C 기준으로 되어있고 swift의 경우는 <code>init(coder aDecoder: NSCoder)</code>를 추가하는 것으로 설명하고 있지만 이 것은 위 문제를 해결하는 것에는 도움이 되지 않는다.
어쨌든 이 글의 결론을 이야기 하자면 이렇다. 인터페이스 빌더에서 해당 class를 제대로 찾지 못하고 있기 때문에 linking이 제대로 되지 못하고 있다는 것이다.
따라서 해당 class에 직접 접근하는 코드를 넣어주어야 한다는 것이다. 그래서 이 글에서는 불필요한 함수 하나를 추가하고 사용 전에 강제로 호출함으로써 문제를 해결할 수 있다고 되어 있다.</p>

<p>위 글에서 설명한 것을 기초로 해결을 위한 코드는 다음과 같다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="p">@</span><span class="n">UIApplicationMain</span>
<span class="k">class</span> <span class="nl">AppDelegate</span><span class="p">:</span> <span class="bp">UIResponder</span><span class="p">,</span> <span class="bp">UIApplicationDelegate</span> <span class="p">{</span>

    <span class="k">var</span> <span class="nl">window</span><span class="p">:</span> <span class="bp">UIWindow</span><span class="o">?</span>
<span class="c1">//  let x = PageViewControllerTChild.description()</span>

    <span class="kr">override</span> <span class="k">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">()</span>

        <span class="n">PageViewControllerTChild</span><span class="p">.</span><span class="n">description</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">func</span> <span class="n">application</span><span class="p">(</span><span class="nl">application</span><span class="p">:</span> <span class="bp">UIApplication</span><span class="p">,</span> <span class="n">didFinishLaunchingWithOptions</span> <span class="nl">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="nl">NSObject</span><span class="p">:</span> <span class="n">AnyObject</span><span class="p">]</span><span class="o">?</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
        <span class="c1">// Override point for customization after application launch.</span>

<span class="c1">//      PageViewControllerTChild.description()</span>

        <span class="k">return</span> <span class="nb">true</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>해결 방법은 AppDelegate의 <code>init()</code> 내부에서 <code>PageViewControllerTChild</code>의 함수를 하나 호출한다.</strong></p>

<p>호출하는 함수는 어떠한 것이라도 상관없다. 하지만 호출 시점은 아주 중요하다. 호출 시점은 해당 화면이 보여지기 전(초기화 전) 이어야 한다.
위 코드는 시작 화면으로 사용한 화면을 대상으로 하고 있기 때문에 <code>init()</code>에 추가 했다. 하지만 시작 화면이 아니라면 <code>func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool</code>에 추가되어도 상관없다. 하지만 어짜피 특별한 기능을 수행할 것이 아니므로 <code>init()</code>에 넣어주는게 속 편할 것이다. 앞서 설명과 같이 어떻게 넣을 수 있는지를 설명하기 위해서 비슷한 코드가 여러군데 있다(대신 주석으로 제외시켜 둔 것이다).</p>

<p>사실 나는 이 해결 방법을 고심해서 찾았지만 실제로는 적용하지 않았다. 설계 구조를 변경해서 Generics를 제거하는 쪽으로 결정했다. 필히 Generics이 필요한 상황이 아니었기 때문에 굳이 이렇게까지 할 필요는 없다고 생각했기 때문이다.</p>

<p>어쨌든 비슷한 문제를 겪고 있다면 위의 설명을 참고로 해결 방법을 찾길 바란다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift UIPageViewController에서 UIPageControl 오버랩하기]]></title>
    <link href="http://blog.asamaru.net/2015/11/03/swift-uipagecontrol-overlap/"/>
    <updated>2015-11-03T17:12:21+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/03/swift-uipagecontrol-overlap</id>
    <content type="html"><![CDATA[<p>UIPageViewController 사용시에 하단에 현재 페이지의 위치를 알려주는 UIPageControl가 별도의 공간을 차지하고 표시된다.</p>

<p><img src="/img/2015-11-03-swift-uipagecontrol-overlap-1.png" alt="UIPageControl"></p>

<p>이 부분의 공간을 제거하고 내용 페이지의 위에 오버랩하려면 아래와 같이 <code>viewDidLayoutSubviews</code>에 필요한 소스를 추가하면 된다. 기본적으로 UIPageControl는 투명이라 자연스럽게 덮힌다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">class</span> <span class="nl">PageViewController</span><span class="p">:</span> <span class="bp">UIPageViewController</span> <span class="p">{</span>
  <span class="kr">override</span> <span class="k">func</span> <span class="n">viewDidLayoutSubviews</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// UIPageControl overlap</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span>
        <span class="k">let</span> <span class="n">subviews</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">subviews</span>
        <span class="k">var</span> <span class="nl">sv</span><span class="p">:</span> <span class="bp">UIView</span><span class="o">?</span> <span class="o">=</span> <span class="nb">nil</span>
        <span class="k">var</span> <span class="nl">pc</span><span class="p">:</span> <span class="bp">UIView</span><span class="o">?</span> <span class="o">=</span> <span class="nb">nil</span>
        <span class="k">for</span> <span class="nl">t</span><span class="p">:</span> <span class="bp">UIView</span> <span class="k">in</span> <span class="n">subviews</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">isKindOfClass</span><span class="p">(</span><span class="bp">UIScrollView</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">sv</span> <span class="o">=</span> <span class="n">t</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">isKindOfClass</span><span class="p">(</span><span class="bp">UIPageControl</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">t</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">sv</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pc</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">sv</span><span class="o">!</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">bounds</span>
            <span class="n">v</span><span class="p">.</span><span class="n">bringSubviewToFront</span><span class="p">(</span><span class="n">pc</span><span class="o">!</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nb">super</span><span class="p">.</span><span class="n">viewDidLayoutSubviews</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Objective-c에서의 처리 방법은 <a href="http://stackoverflow.com/a/24851985">How do I make the bottom bar with dots of a UIPageViewController translucent?</a>를 참고.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 7.1에서 Google Maps SDK 사용시 빌드가 되지 않는 결함]]></title>
    <link href="http://blog.asamaru.net/2015/11/02/google-maps-sdk-with-xcode-7-dot-1-bug/"/>
    <updated>2015-11-02T16:57:18+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/02/google-maps-sdk-with-xcode-7-dot-1-bug</id>
    <content type="html"><![CDATA[<p>얼마전 iOS 앱 개발에 사용하던 xcode를 7.1로 업데이트 했다. 그런데 앱에서 사용중이던 Google Maps SDK가 빌드되지 못해 앱을 실행할 수가 없었다. 문제는 header 생성 부분인데 해결 방법을 찾지 못해 다시 7.0을 재설치해서 사용하고 있었다. 그렇게 지내던 중 오늘 갑자기 생각이 나서 다시 확인해 봤다. 다행히 그 사이에 Google에서 update를 내 놓았다. 이 문제가 수정된 버전은 1.10.5 버전이다. 그리고 관련된 issue는 <a href="https://code.google.com/p/gmaps-api-issues/issues/detail?id=8524&amp;can=1&amp;q=Could%20not%20build%20Objective-C%20module&amp;colspec=ID%20Type%20Status%20Introduced%20Fixed%20Summary%20Stars%20ApiType%20Internal">Issue 8524: Bug: Running under Xcode 7 beta 6 with Google Maps SDK results in broken debugging.</a>이다.</p>

<p>오류 메시지는 <code>Include of non-modular header inside framework module &#39;GoogleMaps&#39;</code>이다.</p>

<p>대략 아래의 이미지처럼 오류가 난다(이미지는 캡춰하기 귀찮아 인터넷에 있는 이미지를 가져왔다).</p>

<p><img src="/img/2015-11-02-google-maps-sdk-with-xcode-7-dot-1-bug-1.png" alt="오류"></p>

<p>혹 xcode 7.1 사용시 이런 오류가 나온다면 Google Maps SDK를 1.10.5 이상으로 업데이트 후 빌드 해보기 바란다.</p>

<p>이 문제에 대한 원인은 처음 오류를 만났을 때 다른 사람들이 이야기하는 것을 봤었는데 정확한 내용이 기억이 나지 않는다. 대충 기억이 나는 것은 xcode가 7.1로 버전업 되면서 swift 모듈에 header 처리하는 부분이 변경되었다고 했던 것 같은데... 나중에라도 원인을 알게되면 다시 남기도록 하겠다.</p>

<p>Apple Developer Forums에서 나온 <a href="https://forums.developer.apple.com/thread/23554">Include of non-modular header inside framework module</a> issue도 있다. 혹시 GoogleMaps가 아닌 모듈에서 동일한 오류가 난다면 참고.</p>
]]></content>
  </entry>
  
</feed>
