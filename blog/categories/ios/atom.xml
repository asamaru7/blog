<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-10-12T16:56:18+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[xcode 프로젝트 앱 이름 변경]]></title>
    <link href="http://blog.asamaru.net/2015/10/08/change-xcode-project-app-name/"/>
    <updated>2015-10-08T11:41:12+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/08/change-xcode-project-app-name</id>
    <content type="html"><![CDATA[<p>앱 이름 변경</p>

<ol>
<li>xxx-Info.plist 선택</li>
<li>Bundle display name 선택</li>
<li>새로운 이름으로 변경</li>
<li>끝</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 2.1에서의 오류 처리(do try catch)]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/swift-2-dot-1-try-catch/"/>
    <updated>2015-10-05T21:19:47+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/swift-2-dot-1-try-catch</id>
    <content type="html"><![CDATA[<p>애플이 2015.06.08.에 <a href="https://developer.apple.com/swift/blog/?id=29">&lsquo;세계개발자회의(WWDC) 2015'에서 스위프트 2.0을 공개</a> 했지만 최근 다시 iOS 작업을 시작하면서 이제서야 swift 2.0을 사용하게 되었다. 그런데 이제 2.0 보려고 하는데 벌써 Xcode 7.1 beta 2가 나오면서 swift 2.1이 공개되었다.</p>

<p>오늘은 swift의 내용 중에서 오류 처리에 관련된 내용을 살펴보고자 한다. 아래의 내용은 <a href="http://qiita.com/koher/items/0c60b13ff0fe93220210">Swift 2.0 の try, catch ファーストインプレッション</a>와 공식 메뉴얼(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html">Error Handling</a>)의 내용을 참고하여 정리한 것이다.</p>

<p>공식 메뉴얼(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html">Error Handling</a>)에서는 swift 2.0이 아닌 swift 2.1로 안내하고 있으니 그냥 2.1을 기준으로 살펴보고자 한다(확실하지는 않지만 대충 알아본 결과 2.1에서의 변화에 Error Handling 부분은 포함되지 않는 것 같다).</p>

<p>메뉴얼의 내용을 빌어 Error Handling의 필요성에 대해 설명하자면 다음과 같다.</p>

<blockquote><p>일부 작업은 항상 완전한 실행을 보증하거나 유용한 출력을 생성하지 않는다. Optionals를 사용하여 값의 유무를 전달함으로써 작업의 성공/실패 유무를 판단할 수 있지만 작업이 실패 할 때 코드가 적절히 응답 할 수 있도록 함으로써 오류의 원인을 이해하는 데 도움을 줄 수 있다. 예를들어 디스크상의 파일을 읽어서 처리하는 작업에서 발생할 수 있는 오류는 &lsquo;존재하지 않는 파일&rsquo;, &lsquo;읽기 권한 없음&rsquo;, &lsquo;호환되는 형식이 아님&rsquo; 등의 여러가지가 존재할 수 있다. 이러한 경우처럼 오류의 원인에 따라 다양한 대응이 필요한 경우라면 오류의 정보를 정확히 전달함으로써 오류를 복구하는데 도움을 줄 수 있다.</p></blockquote>

<p><strong>Swift 2.0 이후부터는 Error Handling(런타임 상에서 오류를 발견하여 응답하고 복구하는 과정)을 위해 throwing, catching, propagating(전파), 런타임에서 복구할 수 있는 오류를 조작(manipulating recoverable errors at runtime) 할 수 있도록 지원한다.</strong></p>

<h2>오류의 사용자 정의</h2>

<p>Swift에서는 ErrorType protocol라는 빈 protocol을 사용하여 오류를 표시한다.</p>

<pre><code class="swift">enum VendingMachineError: ErrorType {
    case InvalidSelection
    case InsufficientFunds(coinsNeeded: Int)
    case OutOfStock
}
</code></pre>

<p>이렇게 생성된 Error는 아래와 같이 발생시킬 수 있다.</p>

<pre><code class="swift">throw VendingMachineError.InsufficientFunds(coinsNeeded: 5)
</code></pre>

<p>조금더 자세히 보자면 ErrorType은 enum으로 정의될 수 있다. Swift에서 try, catch는 항상 ErrorType를 throw 한다. Java에서는 오류 유형을 클래스로 취급하므로 종류마다 클래스를 정의하므로 개수가 많아지고 오류를 처리에 따라 묶어서 관리하기 어렵다. 하지만 Swift의 ErrorType는 관련 오류를 enum으로 정리할 수 있기 때문에 정리가 쉽다.</p>

<p>예들들어 String을 Int로 변환하는 함수를 가정할 경우 발생할 수 있는 오류는 String이 nil이거나 숫자로 변환될 수 없는 문자열일 수 있다. 이를 ErrorType 로 구현하면 다음과 같이 정의할 수 있다.
<code>swift
enum ParseError : ErrorType {
    case Nil // nil 인 경우
    case IllegalFormat // Int로 해석 할 수 없었던 경우
}
</code></p>

<p>ErrorType는 오류의 종류를 나타낼뿐만 아니라 오류 정보를 함께 가질 수 있다.
위의 예시에서 IllegalFormat 오류일 때 해당 String이 무엇이었는지를 함께 넘겨주고 싶을 수 있다.</p>

<pre><code class="swift">enum ParseError : ErrorType {
    case Nil
    case IllegalFormat (String)
}
</code></pre>

<p>이 방식의 좋은 점은 오류의 종류에 따라 다른 유형의 인자를 가질 수 있어 Type Safe하게 값을 얻어낼 수 있다는 것이다.</p>

<pre><code class="swift">switch error {
    case. Nil :
        print ( "The text is nil.")
    case. IllegalFormat (let string) :
        print ( "Illegal format : \ (string)")
}
</code></pre>

<p>Objective-C의 NSError에서도 오류 정보를 가질 수 있지만, Type 정보가 사라져 버리기 때문에 Type Safe 하지 않다.</p>

<h2>오류 제어</h2>

<p>오류가 발생하면 문제를 보정하는 방법을 시도하거나 사용자에게 알림으로써 오류를 처리해야 한다. Swift에서는 오류를 처리 할 수있는 네 가지 방법이 있다.</p>

<ul>
<li>Throwing Functions을 이용한 오류 전파(Propagating Errors Using Throwing Functions)</li>
<li>Do-Catch를 이용한 오류 처리(Handling Errors Using Do-Catch)</li>
<li>Error를 Optional Values로 변환(Converting Errors to Optional Values)</li>
<li>오류 전파 비활성화(Disabling Error Propagation)</li>
</ul>


<p>각각의 처리 방법을 하나씩 알아보자.</p>

<h3>Throwing Functions을 이용한 오류 전파(Propagating Errors Using Throwing Functions)</h3>

<p>함수, 메소드, 초기화시에 오류가 throw될 수 있음을 표시하려면 함수 선언시 인자 뒤에 throws 키워드를 추가할 수 있다. 아래의 예시를 보면 이해가 편할 것이다.</p>

<pre><code class="swift">func canThrowErrors() throws -&gt; String

func cannotThrowErrors() -&gt; String
</code></pre>

<p><code>canThrowErrors</code> 함수 내부에서 오류가 발생하면 이 오류는 자신을 호출한 함수로 전파된다.</p>

<h3>Do-Catch를 이용한 오류 처리(Handling Errors Using Do-Catch)</h3>

<p>오류를 제어 하고자하는 코드의 블록이 있을 경우는 do-catch를 사용할 수 있다. 문법 상의 차이는 있지만 다른 언어에서의 try-catch와 유사하므로 코드를 보는 것이 이해가 더 빠를 것으로 생각된다.</p>

<pre><code class="swift">var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8
do {
    try buyFavoriteSnack("Alice", vendingMachine: vendingMachine)
} catch VendingMachineError.InvalidSelection {
    print("Invalid Selection.")
} catch VendingMachineError.OutOfStock {
    print("Out of Stock.")
} catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
    print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
}
</code></pre>

<p><code>buyFavoriteSnack</code> 함수는 try에 의해 호출되며 오류가 발생하면 오류의 타입에 해당하는 catch에 의해 제어된다. 다른 예시를 하나 살펴보자.</p>

<pre><code class="swift">do {
    let number = try toInt (label. text)
    // number를 사용한 처리
} catch ParseError. Nil {
    print ( "The text is nil.")
} catch ParseError. IllegalFormat (let string) {
    print ( "Illegal format : \ (string)")
}
</code></pre>

<h3>Error를 Optional Values로 변환(Converting Errors to Optional Values)</h3>

<p><code>try?</code> 구문을 이용해서 오류를 optional value로 변환할 수 있다. 예를들어 어떤 값을 반환하는 함수가 있을 때 내부에서 오류가 발생하면 오류를 무시하고 nil이 반환된 것과 동일하게 처리할 수 있다. 역시 아래의 예시를 보자.</p>

<pre><code class="swift">func someThrowingFunction() throws -&gt; Int {
    // ...
}

let x = try? someThrowingFunction()
let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre>

<p>아래와 같이 사용하는 것도 가능하다.</p>

<pre><code class="swift">func fetchData() -&gt; Data? {
    if let data = try? fetchDataFromDisk() { return data }
    if let data = try? fetchDataFromServer() { return data }
    return nil
}
</code></pre>

<h3>오류 전파 비활성화(Disabling Error Propagation)</h3>

<p>실질적으로는 런타임시 오류를 발생시키지 않는 throwing 함수나 메서드를 사용할 경우가 있다. 이 경우 <code>try!</code>(forced-try)를 사용하여 throwing 함수나 메서드를 호출할 수 있다. <code>try!</code>를 사용하여 throwing 함수나 메서드를 호출하면 error 전파가 비활성화 되고 에러를 던지지 않는 런타임
assertion 안에서의 호출로 랩핑된다. 따라서 만일 실제로 에러가 thrown 되면, 런타임 에러를 만나게 된다. 아래의 예시를 보자.</p>

<pre><code class="swift">let photo = try! loadImage("./Resources/John Appleseed.jpg")
</code></pre>

<p><code>loadImage(_:)</code> 함수의 경우 Resources에서 이미지를 호출하고 있으므로 런타임 상에서 오류가 발생하지 않는다(빌드시 이미지가 포함되므로). 이런 경우 <code>try!</code>를 사용하여 오류 제어를 줄일 수 있다.</p>

<h2>Clearn-Up Actions 지정 (Specifying Clearn-Up Actions)</h2>

<p><code>defer</code>를 사용하면 코드의 실행이 코드 블럭을 벗어나기 전에 일련의 작업을 수행하게 할 수 있다. 다시말해 오류의 발생과 무관하게 반드시 실행되어야할 작업을 지정할 수 있다. 다른 언어의 finally와 유사하다고 볼 수 있다. 예를들면 열려진 파일을 닫거나, 수동으로 할당된 메모리를 해제하는 작업이 될 수 있다.</p>

<p>defer 내부의 구문은 제어흐픔을 벗어나게 할 수 있는 break, return, throw 등을 포함해서는 안된다. 또한 defer는 기술된 순서의 역순으로 실행된다. 다시말해 마지막에 있는 defer부터 실행되어 올라온다.</p>

<p>아래의 예시는 파일을 열어서 내용을 읽어서 처리하며 defer를 사용하여 오류 발생과 무관하게 파일을 닫아주도록 하고 있다.</p>

<pre><code class="swift">func processFile(filename:String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }

        while let = try file.readline() {
            // work with the file
        }
        // close(file) is called here, at the end of the scope.
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 2 : 'lastPathComponent' is unavailable: Use lastPathComponent on NSURL instead. 오류 해결]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/no-more-stringbyappendingpathcomponent-in-xcode-7/"/>
    <updated>2015-10-05T13:14:55+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/no-more-stringbyappendingpathcomponent-in-xcode-7</id>
    <content type="html"><![CDATA[<p><a href="/2015/10/05/binary-operator-cannot-be-applied-to-two-uiviewautoresizing-operands/">Swift 2 : Binary operator &lsquo;|&rsquo; cannot be applied to two &lsquo;UIViewAutoresizing&rsquo; operands 오류 해결</a>에 이어 Swift 2로 넘어가면서 만난 또 다른 오류.</p>

<pre><code>'lastPathComponent' is unavailable: Use lastPathComponent on NSURL instead.
</code></pre>

<p>관련해서 찾아보니 <a href="https://forums.developer.apple.com/thread/13580">No more stringByAppendingPathComponent in Xcode 7 beta 5?</a>라는 글이 있었다. 내용을 보니 해당 함수가 없어져서 다른 방법으로 수정해야 한다는 것. 내용중 <a href="https://forums.developer.apple.com/people/tieferbegabt">tieferbegabt</a>라는 사람이 간단히 해결할 수 있는 코드를 올려 놓았다.</p>

<pre><code class="swift">extension String {
    var lastPathComponent: String {
        get {
            return (self as NSString).lastPathComponent
        }
    }
    var pathExtension: String {
        get {
            return (self as NSString).pathExtension
        }
    }
    var stringByDeletingLastPathComponent: String {
        get {
            return (self as NSString).stringByDeletingLastPathComponent
        }
    }
    var stringByDeletingPathExtension: String {
        get {
            return (self as NSString).stringByDeletingPathExtension
        }
    }
    var pathComponents: [String] {
        get {
            return (self as NSString).pathComponents
        }
    }
    func stringByAppendingPathComponent(path: String) -&gt; String {
        let nsSt = self as NSString
        return nsSt.stringByAppendingPathComponent(path)
    }

    func stringByAppendingPathExtension(ext: String) -&gt; String? {
        let nsSt = self as NSString
        return nsSt.stringByAppendingPathExtension(ext)
    }
}
</code></pre>

<p>Objective-C의 category나 swift의 extension은 개인적으로 정말 좋은 기능이라고 생각한다. 하지만 위의 코드는 임시로 사용하고 가급적 위 코드의 내용을 참고해서 오류가 나는 부분을 직접 변경하는 것을 권장하고 싶다. 어짜피 나중에는 애플에서 권장하는대로 코딩을 해야할테니 정확한 방법을 익히도록 처리하는 것이 좋다는 얘기다.</p>

<p>아래는 내가 사용한 코드의 일부를 예시로 남긴다.</p>

<pre><code class="swift">// before
let filename = file.lastPathComponent.stringByDeletingPathExtension
// after
let filename = ((file as NSString).lastPathComponent as NSString).stringByDeletingPathExtension
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 2 : Binary operator '|' cannot be applied to two 'UIViewAutoresizing' operands 오류 해결]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/binary-operator-cannot-be-applied-to-two-uiviewautoresizing-operands/"/>
    <updated>2015-10-05T12:44:59+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/binary-operator-cannot-be-applied-to-two-uiviewautoresizing-operands</id>
    <content type="html"><![CDATA[<p>이번에 iOS 작업중 Swift 2로 변경을 하면서 아래와 같은 오류를 만났다.</p>

<pre><code>Binary operator '|' cannot be applied to two 'UIViewAutoresizing' operands
</code></pre>

<p>사실 이 부분말고도 여러가지 오류가 나왔지만 기본적으로 swift 버전업을 도와주는 헬프 기능 등을 통해 어느 정도는 쉽게 고칠 수 있었다.</p>

<p>어쨌든 이 오류는 아래의 코드를 보면 해결 방법을 바로 알 수 있다.</p>

<pre><code class="swift">let view = UIView(frame: CGRect(x: 0, y: 0, width: 100, height: 100))
addSubview(view)
// Swift 2.0 미만
view.autoresizingMask = UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight
// Swift 2.0 이상
view.autoresizingMask = [.FlexibleWidth, .FlexibleHeight]
</code></pre>

<p>이와 유사하게 UIUserNotificationType의 경우도 아래와 같이 수정이 필요하다.</p>

<pre><code class="swift">// Swift 2.0 미만
let settings = UIUserNotificationSettings(forTypes: UIUserNotificationType.Alert | UIUserNotificationType.Badge, categories: nil)
// Swift 2.0 이상
let settings = UIUserNotificationSettings(forTypes: [.Alert, .Badge], categories: nil)
UIApplication.sharedApplication().registerUserNotificationSettings(settings)
if settings.types.contains(.Badge) {
    // whatever
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods 사용법]]></title>
    <link href="http://blog.asamaru.net/2015/08/28/cocoapods-usage/"/>
    <updated>2015-08-28T06:34:30+09:00</updated>
    <id>http://blog.asamaru.net/2015/08/28/cocoapods-usage</id>
    <content type="html"><![CDATA[<h2>설치</h2>

<pre><code class="bash">[sudo] gem install cocoapods
pod setup
</code></pre>

<h2>사용법</h2>

<h3>패키지 검색</h3>

<blockquote><p><a href="http://cocoapods.org/">http://cocoapods.org/</a></p></blockquote>

<h3>Podfile 설정</h3>

<pre><code class="bash">cd 프로젝트 폴더
vi Podfile
</code></pre>

<p>아래의 내용입력.</p>

<pre><code>platform :ios, '7.0'
pod 'HZWebViewController', '~&gt; 0.0.2'
</code></pre>

<h3>Pod 설치</h3>

<pre><code class="bash">pod install
</code></pre>

<h3>Pod 업데이트</h3>

<pre><code class="bash">pod update
</code></pre>

<h2>실행</h2>

<pre><code>프로젝트명.xcworkspace
</code></pre>

<p>프로젝트명.xcodeproj가 아닌 프로젝트명.xcworkspace로 프로젝트를 열어야 정상적으로 빌드 및 실행이 된다.</p>

<blockquote><p>참고 : <a href="http://www.shako.net/blog/archives/224">http://www.shako.net/blog/archives/224</a></p></blockquote>
]]></content>
  </entry>
  
</feed>
