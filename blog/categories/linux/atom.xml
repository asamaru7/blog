<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-11-17T14:39:07+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ANSI text를 HTML로 변환하기]]></title>
    <link href="http://blog.asamaru.net/2015/10/26/ansi-to-html/"/>
    <updated>2015-10-26T14:38:36+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/26/ansi-to-html</id>
    <content type="html"><![CDATA[<p>지난 글 <a href="/2015/10/23/php-cli-ansi-colors/">PHP를 CLI에서 사용시 ANSI Colors 적용하기</a>에서 php cli에서 ANSI를 사용해서 출력하는 것에 대해 설명했었다. 이번엔 ANSI text를 HTML로 변환하는 것에 대해서 설명하려고 한다.
이게 왜 필요할까? ANSI는 shell에서만 색상이 적용되므로 해당 내용을 text 파일로 저장해서 다른 곳에서 열어보면 ANSI code가 그대로 보이거나 일반 text로 보인다. 따라서 결과물을 색상을 포함해서 다른 곳에 공유하기가 어렵다.
나의 경우는 ANSI를 html로 변환해서 chrome에서 열고 pdf로 출력헤서 사용했다.</p>

<p>그럼 본론으로 들어가서 어떻게 하면 되는가? 여러가지 방법이 있다. PHP를 사용하는 방법, Bash script를 사용하는 방법, 특정 프로그램을 사용하는 방법 등 많지만 오늘은 그 중에서 몇가지만 소개하려고 한다.</p>

<p>우선 지난 번에 PHP에서 ANSI를 생성하는 것을 설명했으니 PHP 부터 보자.</p>

<p><a href="https://github.com/sensiolabs/ansi-to-html">ansi-to-html</a> 라이브러리를 사용해서 변환할 수 있다. 자세한 설명은 해당 사이트를 참고하면 자세히 나와 있다.</p>

<p>다음은 Bash script.</p>

<p><a href="http://pablomarin-garcia.blogspot.kr/2011/04/converting-ansi-to-html-how-to-convert.html">converting ANSI to HTML. How to convert to html the colored shell output</a>를 참고하면 Perl CPAN을 사용하는 방법과 <a href="http://www.pixelbeat.org/scripts/ansi2html.sh">ansi2html.sh from pixelbeat</a> Bash script를 사용하는 방법을 안내하고 있다.
하지만 이 스크립트는 크게 권장하고 싶지는 않다. 간단한 내용엔 문제가 되지 않는데 text 양이 많아지니 너무 느렸다(300kb 가량).</p>

<p>마지막으로 <a href="https://github.com/theZiz/aha">aha</a>를 사용하는 방법이다. 링크를 따라가면 github의 aha repository를 볼 수 있다. 설명은 설치 방법만 나와 있는데 아주 심플하다. 그래서 아래에 직접 사용한 방법을 조금 더 설명하겠다.</p>

<p>centos 기준으로 아래와 같이 설치가 가능하다. 우분투라면 <code>sudo apt-get install aha</code>로 설치가 가능하다고 설명하는 사람이 있는데 확인은 못했다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>su -
<span class="nv">$ </span>git clone https://github.com/theZiz/aha.git
<span class="nv">$ </span>make
<span class="nv">$ </span>install
</code></pre></div>
<p>사용법은 help를 보면 아래와 같이 나온다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">Ansi Html Adapter Version 0.4.8.0
aha takes SGR-colored Input and prints W3C conform HTML-Code
use: aha &lt;options&gt; <span class="o">[</span>-f file<span class="o">]</span>
     aha <span class="o">(</span>--help<span class="p">|</span>-h<span class="p">|</span>-?<span class="o">)</span>
aha reads the Input from a file or stdin and writes HTML-Code to stdout
options: --black,      -b: Black Background and White <span class="s2">&quot;standard color&quot;</span>
         --pink,       -p: Pink Background
         --stylesheet, -s: Use a stylesheet instead of inline styles
         --iso X,    -i X: Uses ISO 8859-X instead of utf-8. X must be 1..16
         --title X,  -t X: Gives the html output the title <span class="s2">&quot;X&quot;</span> instead of
                           <span class="s2">&quot;stdin&quot;</span> or the filename
         --line-fix,   -l: Uses a fix <span class="k">for</span> inputs using control sequences to
                           change the cursor position like htop. It<span class="s1">&#39;s a hot fix,</span>
<span class="s1">                           it may not work with any program like htop. Example:</span>
<span class="s1">                           echo q | htop | aha -l &gt; htop.htm</span>
<span class="s1">         --word-wrap,  -w: Wrap long lines in the html file. This works with</span>
<span class="s1">                           CSS3 supporting browsers as well as many older ones.</span>
<span class="s1">         --no-header,  -n: Don&#39;</span>t include header into generated HTML,
                           useful <span class="k">for</span> inclusion in full HTML files.
Example: aha --help <span class="p">|</span> aha --black &gt; aha-help.htm
         Writes this <span class="nb">help </span>text to the file aha-help.htm

Copyleft Alexander Matthes aka Ziz 2015
         zizsdl@googlemail.com
         http://ziz.delphigl.com/tool_aha.php
This application is subject to the MPL or LGPL.
</code></pre></div>
<p>간단한 사용법은 다음과 같다. 기타 옵션들은 몇가지 안되니 바로 보면 된다(사실상 사용할 일이 거의 없을 거 같다).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ls -ahl <span class="p">|</span> aha &gt; result.html

<span class="c"># 또는</span>

<span class="nv">$ </span>aha -f <span class="o">{</span>ANSI 파일<span class="o">}</span> &gt; result.html
</code></pre></div>
<p>나는 이 방법을 사용했다. 일단 c로 만들어져서 그런지 속도가 아주 빠르다. 하지만 한가지 단점이 있다. 표준 ANSI만 지원하는 것 같다. aixterm 에서 사용하는 속성들은 결과에서 무시되었다. 예를들어 글자색은 30-37 만 사용 가능하다.</p>

<p>구글에서 ansi to html 이라고 검색하면 보다 다양한 방법들이 있으니 필요하다면 한번 검색해보길 바란다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 7 firewalld vs iptables]]></title>
    <link href="http://blog.asamaru.net/2015/10/16/centos-7-firewalld/"/>
    <updated>2015-10-16T14:33:14+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/16/centos-7-firewalld</id>
    <content type="html"><![CDATA[<p>CentOS 7부터 방화벽으로 iptables를 사용하지 않고 firewalld를 사용한다. <code>/etc/sysconfig/iptables</code> 파일도 존재하지 않는다. 따라서 <code>firewall-cmd</code>를 사용해서 방화벽을 설정해야 한다(x windows에서는 firewall-config를 사용한다고하나 콘솔만 사용해봐서 firewall-config는 어떻게 생겼는지 모르겠다).</p>

<p><a href="https://access.redhat.com/documentation/ko-KR/Red_Hat_Enterprise_Linux/7/html/Migration_Planning_Guide/ch04s11.html#idp7905344">Redhat Products &amp; Servies의 4.11. 보안 및 액세스 제어</a>에 아래와 같이 설명되어 있다.</p>

<blockquote>
<p><strong>4.11.1. 새로운 방화벽 (firewalld)</strong></p>

<p>Red Hat Enterprise Linux 6에서 방화벽 기능은 iptables 유틸리티에 의해 제공되어 명령행이나 그래픽 설정 도구, system-config-firewall에서 설정되었습니다. Red Hat Enterprise Linux 7에서 방화벽 기능은 iptables에 의해 제공되지만 관리자는 동적 방화벽 데몬, firewalld, 설정 도구를 통해 iptables와 상호 작용합니다. 설정 도구에는 firewall-config, firewall-cmd, firewall-applet이 있으며 이는 Red Hat Enterprise Linux 7 기본값 설치에 포함되어 있지 않습니다.</p>

<p>firewalld는 동적이기 때문에 언제든지 설정을 변경할 수 있고 바로 실행됩니다. 방화벽을 다시 로딩할 필요가 없으므로 기존 네트워크 연결에서 의도하지 않은 중단이 발생하지 않습니다.</p>

<p>Red Hat Enterprise Linux 6와 7 간의 방화벽에서의 주요 차이점은 다음과 같습니다:</p>

<ul>
<li><p>방화벽 설정에 대한 자세한 내용은 /etc/sysconfig/iptables에 저장되어 있지 않고 이 파일이 존재하지도 않습니다. 대신 설정 상세 정보는 /usr/lib/firewalld 및 /etc/firewalld 디렉토리에 있는 다양한 파일에 저장됩니다.</p></li>
<li><p>Red Hat Enterprise Linux 6의 방화벽 시스템에서는 설정 변경 사항이 있을 때 마다 모든 규칙이 삭제되고 다시 적용되어 firewalld는 설정 차이만을 적용합니다. 그 결과 firewalld는 기존 연결을 중단하지 않고 런타임 동안 설정을 변경할 수 있습니다.</p></li>
</ul>
</blockquote>

<p>또한 <a href="http://www.slideshare.net/sukkim737/oracle-enterprise-linux-new-featurefirewalld">firewalld concept and configuration</a>에 보면 &quot;firewalld의 필요성&quot;에 대해 설명하고 있다(6 page). 편의를 위해 해당 부분만 아래에 안내한다.</p>

<blockquote>
<p><strong>firewalld 의 필요성</strong></p>

<ul>
<li>기존 iptables의 한계

<ul>
<li>룰 변경시 서비스 중지 및 설정 변경</li>
<li>오픈스택이나 KVM과 같은 가상화 호스트에서는 네트워크 변 화가 수시로 발생되므로 필터링 정책에 변경이 필요</li>
<li>응용프로그램 자체에서 필터링 정책을 구성하는 경우 iptables 정책과 충돌되는 등의 문제 야기</li>
</ul></li>
<li><p>firewalld가 필요한 이유?</p>

<ul>
<li>KVM , openstack 과 같은 가상화, 클라우드 환경하에서의 필 터링 정책 동적 추가 가능</li>
<li>DBUS API를 통한 정보 공유를 통해 정책 충돌 문제 해결</li>
</ul></li>
<li><p>DBUS란? 어플리케이션간의 통신을 지원하는 인터페이스</p></li>
</ul>
</blockquote>

<p>마지막으로 <a href="https://www.linux.co.kr/home2/board/subbs/board.php?bo_table=lecture&amp;wr_id=1860&amp;sca=&amp;page=0">Doly의 CentOS7 강좌30 12. 네트워크 보안설정 12.2 iptables 서비스 (1/3)</a>에서는 아래와 같이 안내하고 있다.</p>

<blockquote>
<p><strong>12.2. iptables 서비스</strong></p>

<p>firewalld는 분명 CentOS7의 아주 혁신적인 기능중의 하나이다. 하지만 필자는 본 서적을 집필하면서 인터페이스가 편리 하나 많은 부분에서 부족함을 느꼈다. 특히 소스IP를 명시하는 부분이 명확하지 않다. 방화벽의 기본은 출발지 IP, 프로토콜, 포트 도착지 IP, 프로토콜, 포트를 기본으로 방화벽 규칙을 만들어간다. 하지만, firewalld는 출발지 IP와 목적지 IP에 대한 정의가 명확하지 않다. 리눅스 스킬이 중급 이상이라면 이러한 이유로 firewalld 서비스를 제거하고 예전 iptables 서비스로 돌아가길 권장하고 싶다.</p>
</blockquote>

<p>사실 &quot;소스IP를 명시하는 부분이 명확하지 않다.&quot; 라는 부분은 글쓴이의 정확한 의도를 알 수 없어 단언하기는 힘들지만 틀린 부분이 있을 수 있다고 생각한다. firewalld를 사용하더라도 소스 IP를 지정할 수 없는 것은 아니다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">firewall-cmd --permanent --zone<span class="o">=</span>public --add-rich-rule<span class="o">=</span><span class="s1">&#39;rule family=&quot;ipv4&quot; source address=&quot;1.2.3.4/32&quot; port protocol=&quot;tcp&quot; port=&quot;80&quot; accept&#39;</span>
</code></pre></div>
<p>위 명령에서 보는 것과 같이 <code>rich-rule</code>를 사용해서 소스 IP를 지정할 수 있다. 그리고 지정된 내역을 보는 방법은 <code>firewall-cmd</code>을 사용하면 되지만 개인적으로는 <code>cat /etc/firewalld/zones/public.xml</code>를 사용해서 확인하는게 더 편한 것 같다. 사실은 아직 <code>firewall-cmd</code>를 능숙하게 사용하지를 못해서 어떻게하면 보기 쉽게 나오는지 잘 모르겠다(몇가지 명령을 시도해 봤는데 내용이 너무 많이 나온다.).</p>

<p>결론적으로 <strong>무조건 firewalld를 사용해야 하는 것은 아니다.</strong> firewalld를 중지시키고 iptables를 설치해서 기존처럼 관리하는 것도 가능하다. 아래의 명령을 실행하면 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>systemctl stop firewalld
<span class="nv">$ </span>systemctl mask firewalld

<span class="nv">$ </span>yum install iptables-services
<span class="nv">$ </span>systemctl <span class="nb">enable </span>iptables

<span class="nv">$ </span>service iptables save
</code></pre></div>
<p><strong>firewalld를 사용할지 iptables를 사용할지는 자신의 선택이다.</strong></p>

<p>현재 시점에서의 내 생각은 firewalld로 이전하는 것이다. 아직은 사용이 익숙치 않아 정확한 이전이 가능할지는 모르겠다. 이제부터 방법을 하나씩 찾아봐야 할 것이다. 하지만 Redhat에서 설명하는 것 처럼 결국은 iptables와 상호 작용하는 형태라고는 해도 접근 지점이 firewalld로 변경되었으며 앞으로도 그럴 것이기 때문이다. 주로 개발업무를 하다보니 서버를 전문적으로 운영했다고는 할 수 없으나 나름의 경험으로 볼 때 일시적인 대응은 결국 대세를 따르도록 변하게 된다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 7 minimal 설치]]></title>
    <link href="http://blog.asamaru.net/2015/10/14/centos-7-minimal-install/"/>
    <updated>2015-10-14T11:46:55+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/14/centos-7-minimal-install</id>
    <content type="html"><![CDATA[<h2 id="minimal-설치">Minimal 설치</h2>

<p>설치를 시작하면 아래와 같은 화면이 나온다. 그냥 Enter를 치면된다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-1.png" alt="centos-7-minimal-install-1"></p>

<p>커서를 옮겨 &quot;Install CentOS 7&quot;을 선택한다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-2.png" alt="centos-7-minimal-install-2"></p>

<p>언어를 한국어로 선택한다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-3.png" alt="centos-7-minimal-install-3"></p>

<p>설치 대상을 선택해서 드라이브를 선택한다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-4.png" alt="centos-7-minimal-install-4"></p>

<p>파티션을 직접 설정하고 싶다면 &quot;파티션을 설정합니다.&quot;를 체크하고 완료한다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-5.png" alt="centos-7-minimal-install-5"></p>

<p>직접 설정하기로 했다면 왼쪽 하단의 &quot;+&quot;를 누르면 아래와 같이 파티션과 용량을 선택할 수 있는 화면이 나온다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-6.png" alt="centos-7-minimal-install-6"></p>

<p>파티션과 용량은 자신에게 맞게 설정하면 된다. 관련해서는 <a href="/2015/10/14/centos-7-install-partitioning/">Centos 7 설치시 파티셔닝</a>을 참고하길 바란다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-7.png" alt="centos-7-minimal-install-7"></p>

<p>완료를 선택하면 확인 창이 나온다. 확인 후 이상이 없다면 &quot;변경 사항을 적용&quot;을 선택한다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-8.png" alt="centos-7-minimal-install-8"></p>

<p>이제 설치가 시작된다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-9.png" alt="centos-7-minimal-install-9"></p>

<p>설치가 되는 동안 &quot;Root 암호&quot;를 선택해서 암호를 입력한다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-10.png" alt="centos-7-minimal-install-10"></p>

<p>설치가 완료되면 Consol이 나타난다. 여기서는 root로 로그인하면 되는데 비밀번호는 설치과정에서 입력했던 비밀번호를 사용하면 된다.</p>

<p><img src="/img/2015-10-14-centos-7-minimal-install-11.png" alt="centos-7-minimal-install-11"></p>

<p>일단 설치는 완료.</p>

<h2 id="초기-설정">초기 설정</h2>

<p>Minimal 설치 과정에서 네트워크 설정을 하지 않았다면 네트워크부터 설정해야 한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vi /etc/sysconfig/network-scripts/ifcfg-enp0s3
</code></pre></div>
<p>네트워크 설정 파일을 열어 필요한 부분을 수정한다. 단, <code>ifcfg-enp0s3</code> 부분은 장비에 따라 다르게 나올 수 있다.
기본적으로 dhcp를 사용하도록 되어 있을텐데 dhcp를 그대로 사용한다면 <code>ONBOOT=no</code> 부분을 <code>ONBOOT=yes</code>으로 바꿔주기만 하면된다. dhcp를 사용하지 않는다면 사용할 IP를 지정한다.</p>

<p>네트워크를 재시작하여 네트워크를 활성화한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>service network restart
</code></pre></div>
<p>설정에 이상이 없다면 이제 네트워크를 사용할 수 있다. 이제부터는 ssh를 통해서 접속해서 작업하는게 편하다. 그런데 그러려면 해당 IP를 알아야하고(dhcp 사용시) ssh server가 설치되어야 한다.</p>

<p>아이피부터 확인하자.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ifconfig -a
</code></pre></div>
<p>그런데 위 명령을 입력하면 <code>command not found</code> 오류가 난다. centos 7에서는 이것도 기본 설치에서 제외되어 있는 듯 하다(기억이 잘나지 않지만 7 미만 버전에서는 이건 기본 설치 되어 있었던 것 같은데). 일단 다른 명령으로 ip를 확인하자. 굳이 ifconfig를 당장 써야 겠다면 <a href="http://www.unixmen.com/ifconfig-command-found-centos-7-minimal-installation-quick-tip-fix/">‘Ifconfig’ Command Not Found In CentOS 7 Minimal Installation – A Quick Tip To Fix It</a>를 참고하자.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ip addr
</code></pre></div>
<p>이제는 ssh server를 설치하자. 어짜피 ifconfig 등을 사용할테니 net-tools도 함께 설치하자. 그리고 ssh server를 켜고 재부팅시 자동으로 시작되도록 수정한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>yum install -y openssh-server net-tools

<span class="nv">$ </span>service sshd start
Redirecting to /bin/systemctl restart  sshd.service

<span class="nv">$ </span>chkconfig sshd on
알림: <span class="s1">&#39;systemctl enable sshd.service&#39;</span>에 요청을 전송하고 있습니다.
</code></pre></div>
<p>위 내용에서 보이듯이 <code>service sshd start</code> 명령 실행시 <code>/bin/systemctl restart  sshd.service</code>으로 대체되었다고 나온다. 그 아래 <code>chkconfig sshd on</code> 명령 실행시에도 마찬가지다. 이유는 CentOS 7 부터 initd 대신 systemd가 기본으로 사용된다. 따라서 안내된 명령이 정확한 명령이다. 위 내용은 이 부분을 보여주기 위해서 일부러 CentOS 7 미만에서 사용되던 명령을 보여준 것이다. systemd에 대해서는 <a href="http://lunatine.net/about-systemd/">systemd 살펴보기</a>를 참고하자.</p>

<p>이제는 ssh client로 접속도 가능하다. 직접 콘솔을 사용하는 것보다 client로 접속해서 처리하는게 간편하니 ssh client로 접속해서 작업하자. 아직 다른 계정을 만들지 않았으므로 root로 접속하면 된다. 그냥 콘솔에서 하겠다면 그냥 해도 된다.</p>

<p>이제는 최신 버전으로 패키지를 업데이트 한다. 최신 버전의 CentOS를 받아서 설치했더라도 패키지들의 업데이트가 있을테니 업데이트하는게 좋다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>yum update -y
</code></pre></div>
<p>이것으로 가장 기본적인 설치까지 완료되었다. 말그대로 초기세팅만 했은니 사용을 위해서는 여러가지 작업을 따로 해야한다. 이 부분은 용도에 따라 달라질 수 있으니 상황에 맞게 작업하면 된다. 다만 여기서는 길어져서 설명하진 않지만 방화벽 설정, ssh 설정 등 사용을 위한 기본적인 설정은 하는게 좋다. 이와 관련해서는 따로 포스팅하도록 하겠다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Centos 7 설치시 파티셔닝]]></title>
    <link href="http://blog.asamaru.net/2015/10/14/centos-7-install-partitioning/"/>
    <updated>2015-10-14T11:44:41+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/14/centos-7-install-partitioning</id>
    <content type="html"><![CDATA[<p>Linux 설치 과정에서 고민되는 것 중 하나가 파티션닝이다. 크게 중요하지 않은 상황이라면 자동으로 설정해주는 것을 그대로 사용하는 것이 편하긴하다. 설치 후에도 파티션을 변경할 수 있는 경우도 있으나 일반적으로 Linux를 서버로 사용하는 경우 동적으로 변경하는 상황은 흔치 않기 때문에 처음 설치시 신중하게 설정하는 것이 좋다.</p>

<p>파티셔닝은 서버의 사용 용도 등에 따라 파티션별 파일시스템의 종류와 용량이 많은 차이를 보일 수 있으므로 참고만 하고 자신이 직접 고민을 해보는 것이 좋을 것이다.</p>

<p>아래의 내용은 <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Installation_Guide/sect-disk-partitioning-setup-x86.html#sect-custom-partitioning-x86">RED HAT ENTERPRISE LINUX 7 Installation Guide : Manual Partitioning</a>을 기준으로 정리하고자 한다(CentOS 7 기준이지만 대부분의 Linux에서도 비슷할 것이다). 따라서 자세한 내용을 보려면 해당 문서를 자세히 읽어보기를 권한다(아래는 간단하게 필요한 부분만 발췌헤서 간단히 개인적인 의견을 적은 것이다).</p>

<h2 id="파티션의-분할">파티션의 분할</h2>

<p>&#39;6.13.4.5. Recommended Partitioning Scheme&#39;에서 권장하는 파티션 분할은 아래와 같다.</p>

<ul>
<li>/boot partition - recommended size at least 500 MB</li>
<li>/ (root) partition - recommended size of 10 GB</li>
<li>/home partition - recommended size at least 1 GB</li>
<li>swap partition - recommended size at least 1 GB</li>
</ul>

<p>위의 파티셔닝은 말그대로 그냥 권장일뿐 상황에 따라서 바뀔 수 있다. 예를들어 나는 간단한 서버인 경우
home 파티션을 구분하지 않고 boot와 swap만 지정하고 나머지 모두를 /에 할달해서 사용한다(관리 편의상).</p>

<p>그런데 swap은 사람들마다 용량에 대한 의견에 차이가 많은 파티션 중 하나다. 우선 참고할만한 글은 아래와 같다.</p>

<ul>
<li><a href="http://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%8A%A4%EC%99%91%EB%A9%94%EB%AA%A8%EB%A6%AC_%ED%81%AC%EA%B8%B0_%EA%B6%8C%EA%B3%A0">리눅스 스왑메모리 크기 권고
</a></li>
<li><a href="https://www.centos.org/docs/5/html/Deployment_Guide-en-US/ch-swapspace.html">CentOS 5 Documentation : Swap Space</a></li>
<li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Installation_Guide/sect-disk-partitioning-setup-x86.html#sect-custom-partitioning-x86">RED HAT ENTERPRISE LINUX 7 Installation Guide : Manual Partitioning</a> 중 &#39;6.13.4.5. Recommended Partitioning Scheme&#39;</li>
</ul>

<p>아래는 RED HAT ENTERPRISE LINUX 7 Installation Guide에 안내된 내용을 가져온 것이다. 일반적인 상황이라면 아래의 기준치를 참고해서 정하면된다. 하지만 서비스를 위한 서버라면 일반적으로 swap 자체가 사용되는 상황을 최대한 없애야 하기 때문에 swap 용량을 많이 책정할 이유는 없다.</p>

<table><thead>
<tr>
<th>Amount of RAM in the system</th>
<th>Recommended swap space</th>
<th>Recommended swap space if allowing for hibernation</th>
</tr>
</thead><tbody>
<tr>
<td>less than 2 GB</td>
<td>2 times the amount of RAM</td>
<td>3 times the amount of RAM</td>
</tr>
<tr>
<td>2 GB - 8 GB</td>
<td>Equal to the amount of RAM</td>
<td>2 times the amount of RAM</td>
</tr>
<tr>
<td>8 GB - 64 GB</td>
<td>0.5 times the amount of RAM</td>
<td>1.5 times the amount of RAM</td>
</tr>
<tr>
<td>more than 64 GB</td>
<td>workload dependent</td>
<td>hibernation not recommended</td>
</tr>
</tbody></table>

<h2 id="파일시스템의-선택">파일시스템의 선택</h2>

<p>CentOS 7은 기본 파일시스템으로 xfs를 사용한다(CentOS 6의 경우 ext4가 기본 파일시스템 이었다). xfs는 데비안 계열의 배포판에서 오래전부터 기본 파일시스템으로 사용하던 것으로 대용량 파일을 지원하며 오랜시간 타 리눅스 배포판에서 사용되면서 안정성이 입증되었다고 판단한 것으로 보인다. 다른 파일시스템도 지원하므로 선택은 자유다. 자세한 내용은 메뉴얼에도 나와있고 찾아보면 많은 자료를 쉽게 찾을 수 있다.
나의 경우는 파일시스템의 경우 특별한 이유가 있지 않는한 해당 OS에서 기본으로 사용하는 파일시스템을 사용한다.</p>

<h2 id="정리">정리</h2>

<p>앞서 설명할때는 고민을 많이 해야 한다고 했는데 글을 적고 보니 너무 간단한 느낌이다. 사실 아주 고성능과 고가용성이 필요한 서버가 아니라면 위의 내용 정도만 생각해줘도 크게 무리는 없다는 생각이다. 자세히 설명하자면 파티션별 사이즈, 파일시스템 하나 하나에 대해서 설명해야 하는데 그러려면 책이 한권이다. 따라서 그 이상이 필요하다면 메뉴얼을 참고하면 관련 사항들을 하나씩 더 찾아보기 바란다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NIC I/F 번호(eth*)를 변경]]></title>
    <link href="http://blog.asamaru.net/2015/10/08/change-centos-6-nic-i-slash-f-number-eth-star/"/>
    <updated>2015-10-08T12:06:26+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/08/change-centos-6-nic-i-slash-f-number-eth-star</id>
    <content type="html"><![CDATA[<p>NIC 교체 및 추가 시 MAC 정보와 H/W 정보가 변경되어 /etc/sysconfig/network-script/ifcfg-ethX 파일이 증가한다.
이때 기존의 I/F 번호를 변경하려면 /etc/udev/rules.d/70-persistent-net.rules의 기존 정보 삭제 및 신규 I/F의 NAME을 변경하고 Rebooting 하면 된다.</p>
]]></content>
  </entry>
  
</feed>
