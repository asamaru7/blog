<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-12-04T17:21:05+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mysql_secure_installation 자동화]]></title>
    <link href="http://blog.asamaru.net/2015/12/04/mysql-secure-installation-automation/"/>
    <updated>2015-12-04T12:35:49+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/04/mysql-secure-installation-automation</id>
    <content type="html"><![CDATA[<p>이전 글 <a href="2015/12/04/installing-mariadb-on-centos-7/">MariaDB 최신 버전 설치(yum) - CentOS 7</a>에서 MariaDB를 설치하면서 <code>mysql_secure_installation</code> 명령을 자동화하는 부분을 언급했었다. 이 글에서는 이를 설명하려고 한다. 우선 바로 만들어둔 bash shell script를 보자.</p>

<p><strong>mysql_secure_installation_automation.sh</strong></p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c"># https://gist.github.com/Mins/4602864</span>

yum -y install expect

<span class="c"># Not required in actual script</span>
<span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>

<span class="nv">SECURE_MYSQL</span><span class="o">=</span><span class="k">$(</span>expect -c <span class="s2">&quot;</span>
<span class="s2">set timeout 3</span>
<span class="s2">spawn mysql_secure_installation</span>
<span class="s2">expect \&quot;Enter current password for root (enter for none):\&quot;</span>
<span class="s2">send \&quot;$MYSQL\r\&quot;</span>
<span class="s2">expect \&quot;Change the root password?\&quot;</span>
<span class="s2">send \&quot;n\r\&quot;</span>
<span class="s2">expect \&quot;Remove anonymous users?\&quot;</span>
<span class="s2">send \&quot;y\r\&quot;</span>
<span class="s2">expect \&quot;Disallow root login remotely?\&quot;</span>
<span class="s2">send \&quot;y\r\&quot;</span>
<span class="s2">expect \&quot;Remove test database and access to it?\&quot;</span>
<span class="s2">send \&quot;y\r\&quot;</span>
<span class="s2">expect \&quot;Reload privilege tables now?\&quot;</span>
<span class="s2">send \&quot;y\r\&quot;</span>
<span class="s2">expect eof</span>
<span class="s2">&quot;</span><span class="k">)</span>

<span class="nb">echo</span> <span class="s2">&quot;$SECURE_MYSQL&quot;</span>
</code></pre></div>
<p>이 스크립트는 <a href="https://gist.github.com/Mins/4602864">mysql_secure_installation automation</a> 스크립트를 참고하여 CentOS에 맞게 조금 수정한 것이다.</p>

<p>위 스크립트를 mysql_secure_installation_automation.sh 파일로 저장했다면 아래와 같이 실행하면 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>chmod <span class="m">700</span> mysql_secure_installation_automation.sh
<span class="nv">$ </span>./mysql_secure_installation_automation.sh
</code></pre></div>
<p>특별히 설명할 것도 없지만 간략하게나마 원리를 설명하자면 <code>expect</code>라는 도구를 사용해서 사용자 입력을 대신하도록 하는 것이다. 이를 응용하면 <code>mysql_secure_installation</code> 외에도 여러가지 상황에 적용할 수 있다. 나의 경우는 <code>expect</code>를 이용해서 ssh 비밀번호 자동 입력 기능을 만들어 사용하고 있었다. 사실 ssh의 경우는 key를 등록하는 방식으로 비밀번호 없이 로그인이 가능하고 비밀번호를 외부로 노출하는 것이 보안상 문제가 있지만 간단하게 접속이 필요하고 보안상의 이슈가 없는 곳에서 유용하게 사용하고 있다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MariaDB 최신 버전 설치(yum) - CentOS 7]]></title>
    <link href="http://blog.asamaru.net/2015/12/04/installing-mariadb-on-centos-7/"/>
    <updated>2015-12-04T08:37:25+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/04/installing-mariadb-on-centos-7</id>
    <content type="html"><![CDATA[<p>CentOS 7에서의 <a href="https://mariadb.org/">MariaDB</a>의 기본적인 설치는 아주 간단하다. yum epel 저장소가 추가된 상태에서 아래와 같이 설치가 가능하다(epel이 없어도 동일할 것으로 생각되나 이 글에서의 주요 내용이 아니기 때문에 테스트 해보지는 않았다).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>yum install -y mariadb mariadb-server
<span class="nv">$ </span>systemctl <span class="nb">enable </span>mariadb.service
<span class="nv">$ </span>systemctl start mariadb.service
<span class="nv">$ </span>mysql_secure_installation
</code></pre></div>
<p>기본 설치는 끝이다. 이제부터 mariadb을 설정하는 부분이 남았지만 이 부분은 서버 상황에 따라 모두 다르니 여기서는 다루지 않는다. 그리고 한가지 더. <code>mysql_secure_installation</code>를 실행하면 자신의 상황에 맞게 설정하기 위해 몇가지를 물어본다. 그런데 이게 거의 일정하고 설치 자동화를 할 때 입력창이 나오면 처리가 귀찮아진다. 이 부분을 자동화하는 부분에 대해서는 <a href="/2015/12/04/mysql-secure-installation-automation/">mysql_secure_installation 자동화</a>에서 따로 글을 남긴다.</p>

<p>이제부터가 본격적인 이 글에서 하고자하는 이야기다.</p>

<p>위의 방법으로 설치하면 현재 기준으로 5.5.44 버전이 설치된다. 하지만 최신 버전은 10.1.9다. 그렇다면 최신 버전을 설치하려면 어떻게 해야하는가? 아래의 과정을 보자.</p>

<p>우선 yum에 mariadb 저장소를 추가한다. <code>http://yum.mariadb.org/10.1/centos7-amd64</code>는 현재 최신 버전과 CentOS7을 기준으로한 주소다. <a href="http://yum.mariadb.org">http://yum.mariadb.org</a> 를 열어보면 다른 기준에서 사용할 수 있는 레포지토리들도 확인할 수 있다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;[mariadb]&quot;</span> &gt; /etc/yum.repos.d/MariaDB.repo
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;name = MariaDB&quot;</span> &gt;&gt; /etc/yum.repos.d/MariaDB.repo
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;baseurl = http://yum.mariadb.org/10.1/rhel7-amd64&quot;</span> &gt;&gt; /etc/yum.repos.d/MariaDB.repo
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB&quot;</span> &gt;&gt; /etc/yum.repos.d/MariaDB.repo
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;gpgcheck=1&quot;</span> &gt;&gt; /etc/yum.repos.d/MariaDB.repo
</code></pre></div>
<p>더 간단한 방법도 있다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>wget -O /etc/yum.repos.d/MariaDB.repo http://mariadb.if-not-true-then-false.com/rhel/<span class="k">$(</span>rpm -E %rhel<span class="k">)</span>/<span class="k">$(</span>uname -i<span class="k">)</span>/10_1
</code></pre></div>
<p>이후는 기존과 동일하다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>yum install -y mariadb mariadb-server
<span class="nv">$ </span>systemctl <span class="nb">enable </span>mariadb.service
<span class="nv">$ </span>systemctl start mariadb.service
<span class="nv">$ </span>mysql_secure_installation
</code></pre></div>
<p>단, 10.1.8 버전 이상일 경우만 위와 같이 처리가 가능한 것으로 보인다(<a href="https://mariadb.com/kb/en/mariadb/systemd/">MariaDB Systemd</a>).</p>

<p>따라서 10.0 버전대를 설치한다면  아래와 같이 하면 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>yum install -y mariadb mariadb-server
<span class="nv">$ </span>systemctl <span class="nb">enable </span>mysql.service
<span class="nv">$ </span>systemctl start mysql.service
<span class="nv">$ </span>mysql_secure_installation
</code></pre></div>
<p>하지만 약간의 차이가 있다. systemctl에서 사용하는 service 명이 다르다. 왜 다른지는 모르겠지만 설치를 했는데 서비스 등록이 되지 않아서 처음엔 당황스러웠다. 이 부분도 처음과 동일하게 사용하고 싶다면 alias를 사용하는 방법이 있다(<a href="https://www.centos.org/forums/viewtopic.php?f=47&amp;t=47373">service name alias? mariadb-&gt;mysql - how?</a>).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&quot;Alias=mysql.service&quot;</span> &gt; /usr/lib/systemd/system/mariadb.service
</code></pre></div>
<p>이렇게 해주면 mariadb라는 이름으로 service를 등록할 수 있다. 큰 의미가 없으니 굳이 적용할 필요는 없으나 혼선을 없애기 위해서라면 적용하는 것도 나쁘지는 않을 듯하다.</p>

<p>자.. 그런데 위 설치 방법대로 따라하면 아래와 같은 화면을 만나게 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>systemctl <span class="nb">enable </span>mysql.service
mysql.service is not a native service, redirecting to /sbin/chkconfig.
Executing /sbin/chkconfig mysql on
The unit files have no <span class="o">[</span>Install<span class="o">]</span> section. They are not meant to be enabled
using systemctl.
Possible reasons <span class="k">for</span> having this kind of units are:
1<span class="o">)</span> A unit may be statically enabled by being symlinked from another unit<span class="s1">&#39;s</span>
<span class="s1">   .wants/ or .requires/ directory.</span>
<span class="s1">2) A unit&#39;</span>s purpose may be to act as a helper <span class="k">for</span> some other unit which has
   a requirement dependency on it.
3<span class="o">)</span> A unit may be started when needed via activation <span class="o">(</span>socket, path, timer,
   D-Bus, udev, scripted systemctl call, ...<span class="o">)</span>.
</code></pre></div>
<p>내용을 보면 mariadb가 systemd에 등록되지 않고 chkconfig로 initd에 등록된다. 앞서 설명했던 5.5/10.1 버전 설치와는 다른 결과다. CentOS의 레포지토리를 이용해서 설치하면 <code>/usr/lib/systemd/system/mariadb.service</code> 파일이 함께 설치되는데 MariaDB 레포지토리로 설치하면 이 파일이 설치되지 않는다(확인해보니 다른 몇가지도 차이가 있다).</p>

<p>이 부분은 MariaDB 10.0이 systemd 지원을 아직 제대로 하지 않아서 그런 것 같다(테스트는 해보지 않았지만 찾아보니 Fedora 22 이상부터는 바로 지원이 되는 것으로 보인다).</p>

<p>그냥 이렇게 사용해도 문제는 되지 않지만 기존과 동일하게 systemd로 사용하고 싶다면 10.1 버전을 사용하면 된다.</p>

<hr>

<p>10.0을 굳이 써야 한다면 다음과 같이 처리할 수는 있으나 권장하지는 않는다. 이왕이면 최신 버전을 사용하자.</p>

<p>이미 위 명령을 입력했었다면 아래와 같이 제거하자. 아직 설치하지 않았다면 이 과정은 생략한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>systemctl disable mysql.service
mysql.service is not a native service, redirecting to /sbin/chkconfig.
Executing /sbin/chkconfig mysql off
</code></pre></div>
<p>아직 설치를 하지 않았다면 10.1과 유사하게 아래의 과정을 처리한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;[mariadb]&quot;</span> &gt; /etc/yum.repos.d/MariaDB.repo
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;name = MariaDB&quot;</span> &gt;&gt; /etc/yum.repos.d/MariaDB.repo
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;baseurl = http://yum.mariadb.org/10.0/rhel7-amd64&quot;</span> &gt;&gt; /etc/yum.repos.d/MariaDB.repo
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB&quot;</span> &gt;&gt; /etc/yum.repos.d/MariaDB.repo
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">&quot;gpgcheck=1&quot;</span> &gt;&gt; /etc/yum.repos.d/MariaDB.repo
</code></pre></div>
<p>10.1과 유사하게 아래의 방법도 가능하다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>wget -O /etc/yum.repos.d/MariaDB.repo http://mariadb.if-not-true-then-false.com/rhel/<span class="k">$(</span>rpm -E %rhel<span class="k">)</span>/<span class="k">$(</span>uname -i<span class="k">)</span>/10
</code></pre></div>
<p>이제 mariadb 10.0을 설치한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>yum install -y mariadb mariadb-server
</code></pre></div>
<p>아래의 내용으로 <code>/usr/lib/systemd/system/mariadb.service</code> 파일을 만든다. 이 스크립트는 5.5 설치시에 생성되었던 <code>/usr/lib/systemd/system/mariadb.service</code> 파일을 가져다가 조금 수정했다. 그대로 사용하려니 정상적으로 동작하지 않았다. <code>/usr/libexec/mariadb-prepare-db-dir</code> 파일을 필요로해서 동일하게 넣어주었으나 구동은 되나 실행 스크립트가 종료되지 않고 <code>systemctl stop</code>으로 종료 할 수도 없었다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># It&#39;s not recommended to modify this file in-place, because it will be</span>
<span class="c"># overwritten during package upgrades.  If you want to customize, the</span>
<span class="c"># best way is to create a file &quot;/etc/systemd/system/mariadb.service&quot;,</span>
<span class="c"># containing</span>
<span class="c">#   .include /lib/systemd/system/mariadb.service</span>
<span class="c">#   ...make your changes here...</span>
<span class="c"># or create a file &quot;/etc/systemd/system/mariadb.service.d/foo.conf&quot;,</span>
<span class="c"># which doesn&#39;t need to include &quot;.include&quot; call and which will be parsed</span>
<span class="c"># after the file mariadb.service itself is parsed.</span>
<span class="c">#</span>
<span class="c"># For more info about custom unit files, see systemd.unit(5) or</span>
<span class="c"># http://fedoraproject.org/wiki/Systemd#How_do_I_customize_a_unit_file.2F_add_a_custom_unit_file.3F</span>

<span class="c"># For example, if you want to increase mariadb&#39;s open-files-limit to 10000,</span>
<span class="c"># you need to increase systemd&#39;s LimitNOFILE setting, so create a file named</span>
<span class="c"># &quot;/etc/systemd/system/mariadb.service.d/limits.conf&quot; containing:</span>
<span class="c">#   [Service]</span>
<span class="c">#   LimitNOFILE=10000</span>

<span class="c"># Note: /usr/lib/... is recommended in the .include line though /lib/...</span>
<span class="c"># still works.</span>
<span class="c"># Don&#39;t forget to reload systemd daemon after you change unit configuration:</span>
<span class="c"># root&gt; systemctl --system daemon-reload</span>

<span class="o">[</span>Unit<span class="o">]</span>
<span class="nv">Description</span><span class="o">=</span>MariaDB database server
<span class="nv">After</span><span class="o">=</span>syslog.target
<span class="nv">After</span><span class="o">=</span>network.target

<span class="o">[</span>Service<span class="o">]</span>
<span class="c">#Type=simple</span>
<span class="nv">Type</span> <span class="o">=</span> forking
<span class="nv">User</span><span class="o">=</span>mysql
<span class="nv">Group</span><span class="o">=</span>mysql
<span class="nv">ExecStart</span> <span class="o">=</span> /etc/rc.d/init.d/mysql start
<span class="nv">ExecStop</span> <span class="o">=</span> /etc/rc.d/init.d/mysql stop

<span class="c">#ExecStartPre=/usr/libexec/mariadb-prepare-db-dir %n</span>
<span class="c"># Note: we set --basedir to prevent probes that might trigger SELinux alarms,</span>
<span class="c"># per bug #547485</span>
<span class="c">#ExecStart=/usr/bin/mysqld_safe --basedir=/usr</span>
<span class="c">#ExecStartPost=/usr/libexec/mariadb-wait-ready $MAINPID</span>

<span class="c"># Give a reasonable amount of time for the server to start up/shut down</span>
<span class="nv">TimeoutSec</span><span class="o">=</span>300

<span class="c"># Place temp files in a secure directory, not /tmp</span>
<span class="nv">PrivateTmp</span><span class="o">=</span><span class="nb">true</span>

<span class="o">[</span>Install<span class="o">]</span>
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</code></pre></div>
<p>이후의 과정은 동일하다. 단, 10.0 설치에서 설명했던 <code>mysql.service</code> 대신 10.1 처럼 <code>mariadb.service</code>을 사용한다. 해당 파일을 만들어 줬으므로.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>systemctl daemon-reload

<span class="nv">$ </span>systemctl <span class="nb">enable </span>mariadb.service
<span class="nv">$ </span>systemctl start mariadb.service
<span class="nv">$ </span>mysql_secure_installation
</code></pre></div>
<p>이제 설치가 끝났다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx : 414 Request-URI Too Large 오류]]></title>
    <link href="http://blog.asamaru.net/2015/12/02/nginx-414-request-uri-too-large/"/>
    <updated>2015-12-02T16:17:54+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/02/nginx-414-request-uri-too-large</id>
    <content type="html"><![CDATA[<p>Nginx를 사용하는 중에 아주 긴 URL의 요청이 들어올 경우 <code>414 Request-URI Too Large</code> 오류가 나는 경우가 있다. 이는 말 그대로 URL 요청이 제한된 길이보다 길기 때문에 오류가 발생하는 것이다. 일반적인 웹 서버들은 8kb를 최대 길이로 설정되어 있는 것이 보통이다. 실제로 Nginx의 경우도 기본은 8kb이다. 하지만 URL의 길이는 서버에서 받아주는 길이도 관련이 있지만 웹 브라우저에서도 제한이 있다. 예를들어 오래된 브라우저들은 2kb 가량의 제한이 있다. 하지만 최신 브라우저들은 8kb로 제한하는 것으로 알고 있다.</p>

<p>하지만 나의 경우는 이 값을 1kb로 설정해 둔 상태로 조금 긴 Url에서 해당 오류가 발생했다. 그래서 2kb로 늘려 두었다.</p>

<p>그러면 Nginx에서는 이 값을 어떻게 조정할 수 있을까? 바로 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#large_client_header_buffers">large_client_header_buffers</a>를 사용하면 된다. 예를들면 아래와 같이 사용한다(디폴트 값을 예시로 넣었다).</p>
<div class="highlight"><pre><code class="language-nginx" data-lang="nginx"><span class="k">http</span> <span class="p">{</span>
  <span class="kn">large_client_header_buffers</span> <span class="mi">4</span> <span class="mi">8k</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-nginx" data-lang="nginx"><span class="k">http</span> <span class="p">{</span>
  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">large_client_header_buffers</span> <span class="mi">4</span> <span class="mi">8k</span><span class="p">;</span>    
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#large_client_header_buffers">공식 메뉴얼</a>에는 아래와 같이 설명되어 있다.</p>

<blockquote>
<p>Syntax: large_client_header_buffers number size;
Default: large_client_header_buffers 4 8k;
Context: http, server</p>
</blockquote>

<p>Sets the maximum number and size of buffers used for reading large client request header. A request line cannot exceed the size of one buffer, or the 414 (Request-URI Too Large) error is returned to the client. A request header field cannot exceed the size of one buffer as well, or the 400 (Bad Request) error is returned to the client. Buffers are allocated only on demand. By default, the buffer size is equal to 8K bytes. If after the end of request processing a connection is transitioned into the keep-alive state, these buffers are released.</p>

<p>여기서 조금 애매한 부분이 number 값인데 명확히 어떤 역할인지를 아직 잘 모르겠다. 찾아보니 number * size가 최대 사이즈라고 하는데 테스트 해보니 그건 아닌 것 같다(number가 2이고 size가 1k인 상황에서 1024자를 넘어가니 414 오류가 발생했다).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx(stable / mainline) 설치 - CentOS 6.5 / 7]]></title>
    <link href="http://blog.asamaru.net/2015/11/27/installing-nginx-on-centos-6-dot-5-slash-7/"/>
    <updated>2015-11-27T15:49:16+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/27/installing-nginx-on-centos-6-dot-5-slash-7</id>
    <content type="html"><![CDATA[<p><a href="http://nginx.org/">Nginx</a>는 <a href="https://ko.wikipedia.org/wiki/Nginx">위키피디아</a>에서 아래와 같이 설명하고 있다.</p>

<blockquote>
<p>Nginx(엔진 x라 읽는다)는 웹 서버 소프트웨어로, 가벼움과 높은 성능을 목표로 한다. 웹 서버, 리버스 프록시 및 메일 프록시 기능을 가진다.</p>

<p>Netcraft의 2011년 1월 웹서버 설문조사에 따르면, nginx는 전체 도메인에서 4번째(7.50%)로 많이 쓰이는 웹서버이며, 활성화된 웹 사이트에 대한 통계에서도 역시 4번째(8.23%)로 많이 사용된다[1].</p>

<p>Nginx는 요청에 응답하기 위해 비동기 이벤트 기반 구조를 가진다. 이것은 아파치 HTTP 서버의 스레드/프로세스 기반 구조를 가지는 것과는 대조적이다. 이러한 구조는 서버에 많은 부하가 생길 경우의 성능을 예측하기 쉽게 해준다.</p>
</blockquote>

<p>기존에는 Apache를 사용하고 있었다. Apache의 다양한 기능 때문이라기 보다는 익숙함 때문이었다. 그런데 예전부터 <a href="http://nginx.org/">Nginx</a>에 대한 사람들의 평가(Apache의 튜닝 상태에 따라 다른 결과를 보이기도 한다)를 볼 때마다 언젠가는 갈아타야지 싶었는데 최근에야 이 생각을 실천하게 되었다. 그레서 <a href="http://nginx.org/">Nginx</a>를 설치하는 과정을 정리하고자 한다.</p>

<hr>

<p>CentOS에서 Nginx의 설치는 크게 소스를 컴파일해서 설치하는 방법과 YUM을 통해 설치하는 방법이 있다. Nginx의 경우 Apache와 다르게 모듈을 추가할 경우엔 무조건 소스 설치를 해야한다(모듈을 포함시켜 컴파일 해야 한다). 따라서 mod_pagespeed나 pagespeed 등을 사용하고자 하는 경우에는 소스 설치를 해야 한다. 오늘은 YUM 설치를 기준으로 설명하고자 하니 모듈을 추가해서 설치하는 방법은 아래의 링크들을 참고하자.</p>

<ul>
<li><a href="http://www.nginxtips.com/how-to-install-mod_security-on-nginx/">How to install Mod_Security on Nginx</a>
<a href="https://developers.google.com/speed/pagespeed/module/build_ngx_pagespeed_from_source">Build ngx_pagespeed From Source</a></li>
<li><a href="http://d2.naver.com/helloworld/192785">NGINX 모듈 제작하기</a></li>
</ul>

<p>사실 기본적인 설치는 <a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/">공식 메뉴얼</a>에 아주 잘 설명되어 있고 간단하다. 내용을 옮겨 적자면 아래와 같다.</p>

<p><code>/etc/yum.repos.d/nginx.repo</code> 파일을 생성해서 아래의 내용을 넣는다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=0
enabled=1
</code></pre></div>
<p>그리고는 아래와 같이 yum 으로 설치한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo yum install nginx
</code></pre></div>
<p>혹시 EPEL을 이용해서 설치하고 싶다면 <code>/etc/yum.repos.d/nginx.repo</code> 파일을 생성할 필요없이 아래와 같이하면 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo yum install epel-release
sudo yum install nginx
</code></pre></div>
<p>끝이다. 정말 간단하다. 설명할 것도 없다. 하지만 사실 이 글을 적는 이유는 이제부터다.</p>

<p>Nginx는 기본적으로 두가지 버전이 존재한다. stable 버전과 mainline 버전이다. 사실상 최신 버전은 mainline 이다. 2015-11-27일 기준으로 stable은 nginx-1.8.0, mainline은 1.9.7이다. 말그대로 stable 버전이 안정 버전이므로 사용이 권장되기는 하나 mainline도 불안정한 것은 아니다.</p>

<p><a href="http://serverfault.com/a/715126">What’s the difference between the “mainline” and “stable” branches of nginx?</a>의 설명대로라면 mainline을 더 권장한다. stable 버전이라고 버그가 없는 것이 아니며 버그 패치는 mainline에 먼저 된다는 이유 때문이다.</p>

<p>그래서 나는 mainline으로 설치하기로 했다. 설치 방법은 위의 stable과 별반 다르지 않으나 repository의 url만 차이가 난다.</p>

<p><code>/etc/yum.repos.d/nginx.repo</code> 파일을 생성해서 아래의 내용을 넣는다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/mainline/centos/\$releasever/\$basearch/
gpgcheck=0
enabled=1
</code></pre></div>
<p>그리고는 아래와 같이 yum 으로 설치한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo yum install nginx
</code></pre></div>
<p>이것 또한 아주 간단하다. 약간의 부가 작업을 포함해서 bash shell 스크립트를 하나 만들어 뒀다.</p>

<p>nginx.install.sh</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="k">function</span> printTitle <span class="o">{</span>
    <span class="nb">echo</span> -e <span class="s2">&quot;\e[1;97m=======================================\e[0m&quot;</span>
    <span class="nb">echo</span> -e <span class="s2">&quot;\e[1;97m* $1\e[0m&quot;</span>
    <span class="nb">echo</span> -e <span class="s2">&quot;\e[1;97m=======================================\e[0m&quot;</span>
<span class="o">}</span>

<span class="k">function</span> printJob <span class="o">{</span>
    <span class="nb">echo</span> -e <span class="s2">&quot;\e[94m* $1\e[0m&quot;</span>
<span class="o">}</span>

<span class="k">function</span> printSubJob <span class="o">{</span>
    <span class="nb">echo</span> -e <span class="s2">&quot;\e[96m\t$1\e[0m&quot;</span>
<span class="o">}</span>

printTitle <span class="s2">&quot;Nginx 설치&quot;</span>

printJob <span class="s2">&quot;httpd.service 종료&quot;</span>
systemctl stop httpd.service

printJob <span class="s2">&quot;httpd.service 제거&quot;</span>
yum remove -y httpd
systemctl disable httpd.service

printJob <span class="s2">&quot;Nginx 설치&quot;</span>
<span class="k">if</span> <span class="o">[</span> ! -e /etc/yum.repos.d/nginx.repo <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    printSubJob <span class="s2">&quot;nginx repository 추가&quot;</span>
    <span class="nb">echo</span> <span class="s2">&quot;[nginx]&quot;</span> &gt; /etc/yum.repos.d/nginx.repo
    <span class="nb">echo</span> <span class="s2">&quot;name=nginx repo&quot;</span> &gt;&gt; /etc/yum.repos.d/nginx.repo
    <span class="nb">echo</span> <span class="s2">&quot;baseurl=http://nginx.org/packages/mainline/centos/\$releasever/\$basearch/&quot;</span> &gt;&gt; /etc/yum.repos.d/nginx.repo
    <span class="c">#echo &quot;baseurl=http://nginx.org/packages/centos/\$releasever/\$basearch/&quot; &gt;&gt; /etc/yum.repos.d/nginx.repo</span>
    <span class="nb">echo</span> <span class="s2">&quot;gpgcheck=0&quot;</span> &gt;&gt; /etc/yum.repos.d/nginx.repo
    <span class="nb">echo</span> <span class="s2">&quot;enabled=1&quot;</span> &gt;&gt; /etc/yum.repos.d/nginx.repo
<span class="k">fi</span>

printSubJob <span class="s2">&quot;nginx package 설치&quot;</span>
yum install -y nginx

printJob <span class="s2">&quot;Nginx 서비스 활성&quot;</span>
systemctl <span class="nb">enable </span>nginx.service

printJob <span class="s2">&quot;Nginx 서비스 시작&quot;</span>
systemctl start nginx.service

printJob <span class="s2">&quot;방화벽 설정&quot;</span>
<span class="k">if</span> <span class="o">[</span> <span class="sb">`</span>firewall-cmd --zone<span class="o">=</span>public --list-all<span class="p">|</span>grep <span class="s2">&quot;services&quot;</span><span class="p">|</span>grep <span class="s2">&quot;http&quot;</span> <span class="p">|</span> wc -l<span class="sb">`</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    printSubJob <span class="s2">&quot;http/https 개방&quot;</span>
    firewall-cmd --permanent --zone<span class="o">=</span>public --add-service<span class="o">=</span>http
    firewall-cmd --permanent --zone<span class="o">=</span>public --add-service<span class="o">=</span>https

    printSubJob <span class="s2">&quot;방화벽 rule reload&quot;</span>
    firewall-cmd --reload
<span class="k">fi</span>
</code></pre></div>
<p>위 소스는 CentOS 7에서 firewalld를 사용하는 것을 기준으로 만들어진 것이니 참고하기 바란다. 그리고 원래 내가 사용하는 소스에서 불필요한 부분을 제거하고 넣은 것이라 <code>print***</code> 함수 같은 부분이 잘못 되었을 수 있는데 오류가 난다면 관련 부분을 모두 제거하면 된다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ANSI text를 HTML로 변환하기]]></title>
    <link href="http://blog.asamaru.net/2015/10/26/ansi-to-html/"/>
    <updated>2015-10-26T14:38:36+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/26/ansi-to-html</id>
    <content type="html"><![CDATA[<p>지난 글 <a href="/2015/10/23/php-cli-ansi-colors/">PHP를 CLI에서 사용시 ANSI Colors 적용하기</a>에서 php cli에서 ANSI를 사용해서 출력하는 것에 대해 설명했었다. 이번엔 ANSI text를 HTML로 변환하는 것에 대해서 설명하려고 한다.
이게 왜 필요할까? ANSI는 shell에서만 색상이 적용되므로 해당 내용을 text 파일로 저장해서 다른 곳에서 열어보면 ANSI code가 그대로 보이거나 일반 text로 보인다. 따라서 결과물을 색상을 포함해서 다른 곳에 공유하기가 어렵다.
나의 경우는 ANSI를 html로 변환해서 chrome에서 열고 pdf로 출력헤서 사용했다.</p>

<p>그럼 본론으로 들어가서 어떻게 하면 되는가? 여러가지 방법이 있다. PHP를 사용하는 방법, Bash script를 사용하는 방법, 특정 프로그램을 사용하는 방법 등 많지만 오늘은 그 중에서 몇가지만 소개하려고 한다.</p>

<p>우선 지난 번에 PHP에서 ANSI를 생성하는 것을 설명했으니 PHP 부터 보자.</p>

<p><a href="https://github.com/sensiolabs/ansi-to-html">ansi-to-html</a> 라이브러리를 사용해서 변환할 수 있다. 자세한 설명은 해당 사이트를 참고하면 자세히 나와 있다.</p>

<p>다음은 Bash script.</p>

<p><a href="http://pablomarin-garcia.blogspot.kr/2011/04/converting-ansi-to-html-how-to-convert.html">converting ANSI to HTML. How to convert to html the colored shell output</a>를 참고하면 Perl CPAN을 사용하는 방법과 <a href="http://www.pixelbeat.org/scripts/ansi2html.sh">ansi2html.sh from pixelbeat</a> Bash script를 사용하는 방법을 안내하고 있다.
하지만 이 스크립트는 크게 권장하고 싶지는 않다. 간단한 내용엔 문제가 되지 않는데 text 양이 많아지니 너무 느렸다(300kb 가량).</p>

<p>마지막으로 <a href="https://github.com/theZiz/aha">aha</a>를 사용하는 방법이다. 링크를 따라가면 github의 aha repository를 볼 수 있다. 설명은 설치 방법만 나와 있는데 아주 심플하다. 그래서 아래에 직접 사용한 방법을 조금 더 설명하겠다.</p>

<p>centos 기준으로 아래와 같이 설치가 가능하다. 우분투라면 <code>sudo apt-get install aha</code>로 설치가 가능하다고 설명하는 사람이 있는데 확인은 못했다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>su -
<span class="nv">$ </span>git clone https://github.com/theZiz/aha.git
<span class="nv">$ </span>make
<span class="nv">$ </span>install
</code></pre></div>
<p>사용법은 help를 보면 아래와 같이 나온다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">Ansi Html Adapter Version 0.4.8.0
aha takes SGR-colored Input and prints W3C conform HTML-Code
use: aha &lt;options&gt; <span class="o">[</span>-f file<span class="o">]</span>
     aha <span class="o">(</span>--help<span class="p">|</span>-h<span class="p">|</span>-?<span class="o">)</span>
aha reads the Input from a file or stdin and writes HTML-Code to stdout
options: --black,      -b: Black Background and White <span class="s2">&quot;standard color&quot;</span>
         --pink,       -p: Pink Background
         --stylesheet, -s: Use a stylesheet instead of inline styles
         --iso X,    -i X: Uses ISO 8859-X instead of utf-8. X must be 1..16
         --title X,  -t X: Gives the html output the title <span class="s2">&quot;X&quot;</span> instead of
                           <span class="s2">&quot;stdin&quot;</span> or the filename
         --line-fix,   -l: Uses a fix <span class="k">for</span> inputs using control sequences to
                           change the cursor position like htop. It<span class="s1">&#39;s a hot fix,</span>
<span class="s1">                           it may not work with any program like htop. Example:</span>
<span class="s1">                           echo q | htop | aha -l &gt; htop.htm</span>
<span class="s1">         --word-wrap,  -w: Wrap long lines in the html file. This works with</span>
<span class="s1">                           CSS3 supporting browsers as well as many older ones.</span>
<span class="s1">         --no-header,  -n: Don&#39;</span>t include header into generated HTML,
                           useful <span class="k">for</span> inclusion in full HTML files.
Example: aha --help <span class="p">|</span> aha --black &gt; aha-help.htm
         Writes this <span class="nb">help </span>text to the file aha-help.htm

Copyleft Alexander Matthes aka Ziz 2015
         zizsdl@googlemail.com
         http://ziz.delphigl.com/tool_aha.php
This application is subject to the MPL or LGPL.
</code></pre></div>
<p>간단한 사용법은 다음과 같다. 기타 옵션들은 몇가지 안되니 바로 보면 된다(사실상 사용할 일이 거의 없을 거 같다).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ls -ahl <span class="p">|</span> aha &gt; result.html

<span class="c"># 또는</span>

<span class="nv">$ </span>aha -f <span class="o">{</span>ANSI 파일<span class="o">}</span> &gt; result.html
</code></pre></div>
<p>나는 이 방법을 사용했다. 일단 c로 만들어져서 그런지 속도가 아주 빠르다. 하지만 한가지 단점이 있다. 표준 ANSI만 지원하는 것 같다. aixterm 에서 사용하는 속성들은 결과에서 무시되었다. 예를들어 글자색은 30-37 만 사용 가능하다.</p>

<p>구글에서 ansi to html 이라고 검색하면 보다 다양한 방법들이 있으니 필요하다면 한번 검색해보길 바란다.</p>
]]></content>
  </entry>
  
</feed>
