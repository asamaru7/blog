<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Php | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-09-10T20:07:12+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Htmlspecialchars_decode와 Html_entity_decode의 문자열 처리의 다른 점]]></title>
    <link href="http://blog.asamaru.net/2015/09/10/htmlspecialchars-decode-html-entity-decode-spaces/"/>
    <updated>2015-09-10T14:27:01+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/10/htmlspecialchars-decode-html-entity-decode-spaces</id>
    <content type="html"><![CDATA[<p>php에서 html 구문을 그대로 출력하기 위해 <a href="http://php.net/manual/kr/function.htmlspecialchars.php">htmlspecialchars</a>를 사용한다. 반대로 출력된 문장(Special HTML entities)을 되돌리기 위해서는 일반적으로 <a href="http://php.net/manual/kr/function.htmlspecialchars-decode.php">htmlspecialchars_decode</a>를 많이 사용한다. 그런데 이 함수를 사용하는데 문제가 있다.
htmlspecialchars_decode는 <code>&amp;nbsp;</code>를 공백으로 다시 되돌려 주지 않는다.</p>

<p>다시 htmlspecialchars로 돌아가서 메뉴얼을 보면 아래와 같이 변환된다고 설명되어 있다.</p>

<ul>
<li>&lsquo;&amp;&rsquo;(앰퍼샌드)는 &lsquo;<code>&amp;amp;</code>'가 됩니다</li>
<li>&lsquo;&ldquo;&rsquo;(겹따옴표)는 ENT_NOQUOTES를 설정하지 않았을 때 &lsquo;&quot;'가 됩니다.</li>
<li>&lsquo;&rsquo;&lsquo;(홑따옴표)는 ENT_QUOTES가 설정되었을 때만 &rsquo;&#039;&lsquo;가 됩니다.</li>
<li>&lsquo;&lt;&rsquo;(미만)은 &lsquo;<code>&amp;lt;</code>'가 됩니다.</li>
<li>&lsquo;>&rsquo;(이상)은 &lsquo;<code>&amp;gt;</code>'가 됩니다.</li>
</ul>


<p>보다시피 엄밀히 말하자면 htmlspecialchars는 공백을 변환시키지 않는다. 따라서 대응되는 함수인 htmlspecialchars_decode는 <code>&amp;nbsp;</code> 공백 문자열을 되돌리지도 않는다.</p>

<p>그럼 <code>&amp;nbsp;</code>와 같은 것은 어떻게 처리를 해야할까?
<a href="http://php.net/manual/en/function.html-entity-decode.php">html_entity_decode</a>를 사용하면 된다. 이 함수는 <a href="http://php.net/manual/kr/function.htmlentities.php">htmlentities</a>와 대응되는 함수이다.</p>

<p>그럼 htmlentities 함수는 무엇인가? 메뉴얼에 따르면 다음과 같다.</p>

<blockquote><p>htmlentities()는 HTML 문자 엔티티에 존재하는 모든 문자를 엔티티로 변환하는 점을 제외하면, htmlspecialchars()와 완전히 동일합니다.</p></blockquote>

<p>중요한 부분은 모든 문자를 변환한다는 점이다. 이 부분이 htmlspecialchars와의 차이라고 한다.</p>

<p>정리하자면</p>

<blockquote><p>htmlspecialchars와 htmlentities는 유사하나 htmlentities가 더 많은 문자를 변환한다.
htmlspecialchars_decode와 html_entity_decode는 유사하나 html_entity_decode가 더 많은 문자를 되돌린다.</p></blockquote>

<p>따라서 결론은 <code>&amp;nbsp;</code>와 같은 문자열까지 모두 decode 하려면 html_entity_decode를 사용하면 된다.</p>

<h2>주의</h2>

<p>자.. 이렇게 해피앤딩이 되면 좋겠지만 몇가지 주의 사항이 있다. html_entity_decode 메뉴얼을 보면 다음과 같은 설명이 있다.</p>

<blockquote><p>You might wonder why trim(html_entity_decode(&lsquo;&nbsp;&rsquo;)); doesn&rsquo;t reduce the string to an empty string, that&rsquo;s because the &lsquo;&nbsp;&rsquo; entity is not ASCII code 32 (which is stripped by trim()) but ASCII code 160 (0xa0) in the default ISO 8859-1 encoding.</p></blockquote>

<p>그렇다. html_entity_decode를 사용해서 <code>&amp;nbsp;</code>를 변환하면 공백이 일반적인 공백과는 다른 공백이다. 이게 왜 문제가 되느냐? 아래의 예시를 보자.</p>

<pre><code class="php">&lt;?php
$str = trim(html_entity_decode("&amp;nbsp;X&amp;nbsp;"));
echo (strcmp($str, 'X') == 0) ? 'ok' : 'oops';
</code></pre>

<p>쉽게 생각하면 &lsquo;ok'가 나올것 같지만 위에 설명했던 것과 같이 'oops'가 나온다. 그럼 어떻게 해결을 해야할까?</p>

<p>메뉴얼에서 ASCII code 160 (0xa0)로 변경된다고 하니 이것을 참고해서 조금 고쳐보자.</p>

<pre><code class="php">&lt;?php
$str = trim(str_replace("\xa0", "", html_entity_decode("&amp;nbsp;X&amp;nbsp;")));
echo (strcmp($str, 'X') == 0) ? 'ok' : 'oops';
</code></pre>

<p>이제 해결이 되었을까? 아니다. 결과는 oops이다.(사실 default_charset에 따라 ok가 나올 수도 있다.) 이유는 위에 메뉴얼에 있다.
&lsquo;default ISO 8859-1&rsquo; 인코딩일 때 0xa0로 변환된다고 되어 있다. 사실 나의 환경은 &lsquo;UTF-8'이다. 대부분 그럴 것이라고 생각한다. 일단 맞는지 확인해 보자. 아래와 같이 default_charset을 ISO-8859-1에 맞추고 실행해보자.</p>

<pre><code class="php">&lt;?php
$str = trim(str_replace("\xa0", "", html_entity_decode(iconv('UTF-8', 'ISO-8859-1', "&amp;nbsp;X&amp;nbsp;"))));
echo (strcmp($str, 'X') == 0) ? 'ok' : 'oops';
</code></pre>

<p>결과는 메뉴얼대로 &lsquo;ok&rsquo; 이다. 그럼 &lsquo;UTF-8'에서는 어떻게 하나? 아래의 코드를 보자.</p>

<pre><code class="php">&lt;?php
$str = trim(str_replace("\xc2\xa0", "", html_entity_decode("&amp;nbsp;X&amp;nbsp;")));
echo (strcmp($str, 'X') == 0) ? 'ok' : 'oops';
</code></pre>

<p>드디어 &lsquo;ok'가 나온다. 중요한 차이는 &ldquo;\xc2\xa0&rdquo; 이다. UTF-8에서는 &ldquo;\xc2\xa0"는 <a href="http://www.utf8-chartable.de/unicode-utf8-table.pl?start=128&amp;number=128&amp;utf8=string-literal&amp;unicodeinhtml=hex">UTF-8 encoding table and Unicode characters</a>에서 확인해보면 UTF-8에서의 "NO-BREAK SPACE"라고 되어 있다.</p>

<p>참 별것 아닌것 같은 함수가 잘모르고 사용하다보면 예상치 못한 문제들을 일으킨다. 사실 <code>&amp;nbsp;</code>만 처리하면 된다면 더 간단하게 <code>str_replace('&amp;nbsp;', ' ', $str)</code>로 해결해도 된다. 하지만 프로그램에선 항상 어떤 값이 들어올지 모르는 것이니 보다 명확하게 처리하는 것이 낫지 않을까?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP에서 Byte-escaped(\xFF)된 문자열 Decode하기]]></title>
    <link href="http://blog.asamaru.net/2015/09/02/decoding-byte-escaped-strings-in-php/"/>
    <updated>2015-09-02T21:49:21+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/02/decoding-byte-escaped-strings-in-php</id>
    <content type="html"><![CDATA[<p>어제 회사 직원 한명이 협력사에서 데이터 전달을 위해 생성해서 알려준 URL에서 데이터를 받지 못해 고생을 하고 있었다. 협력사는 PC용 어플리케이션을 만드는 회사(Delphi 사용)로 웹에 대해서 잘 모른다.</p>

<p>처리하고자 하는 일은 다음과 같았다. PC용 어플리케이션에서 버튼을 누르면 해당 어플리케이션에서 가지고 있던 데이터를 특정 URL로 호출(전달)해주는 것이었다.</p>

<p>처음엔 데이터를 &ldquo;뭐뭐 주세요&rdquo; 했더니 그냥 넘겨주는 바람에 특수문자가 들어가 내용이 정상적으로 전달되지 않았다. 당연히 POST 방식으로 값을 전달해주면 문제가 없겠지만 그렇게는 더 어렵다고하니&hellip; 그냥 GET으로 달라고 했다. 그 바람에 이런 일들이 벌어진 것이다.</p>

<p>그리하여 우여곡절 끝에 문자열을 인코딩해서 보내달라는 요청을하고 받은 결과가 다시 문제가 되었다. 분명 인코딩은 되어 있는데 일반적으로 웹에서 쓰는 인코딩이 아니었다.</p>

<blockquote><p>\xb4\xd9\xbf\xf8\xc5\xd7\xc5\xa9</p></blockquote>

<p>뭐 이런식이다. 어딘가 낯익은 모양이면서도 흔히 보지못한 형태였다.</p>

<p>검색을 해보니 javascript escape sequences라고 부르는 사람도 있고 Byte-escaped string이라고 하기도 하고.. 어쨌든 byte 단위로 변환된 문자열이다.</p>

<p>이 문장을 decode 하려면 다음의 코드를 참조하면 된다. (인터넷에서 다른 소스를 참조해서 조금 개선했다.)</p>

<pre><code class="php">$string = "\xb4\xd9\xbf\xf8\xc5\xd7\xc5\xa9";
echo preg_replace_callback(
    '/\\\x([0-9a-f]{2})/i',
    function($matches) {
        return chr(hexdec($matches[1]));
    },
    $string
);
</code></pre>

<p>어땠든 이렇게 decode를 했는데도 글자가 깨졌다. 이런&hellip; 문자열이 UTF-8이 아니라 EUC-KR이다.
그래서 조금더 추가. 여기서 UHC는 euc-kr과 거의 유사하다. 조금 더 확장되었다고 알고있는데 오래전 기억이라 확실치 않다.</p>

<pre><code class="php">$string = "\xb4\xd9\xbf\xf8\xc5\xd7\xc5\xa9";
echo iconv("UHC", "UTF-8", preg_replace_callback(
    '/\\\x([0-9a-f]{2})/i',
    function($matches) {
        return chr(hexdec($matches[1]));
    },
    $string
));
</code></pre>

<p>이렇게 해피앤딩이 되면 좋겠지만 현실을 그렇지 않다. 문제는 이 인코딩이 특수문자는 인코딩하지 않는다는 것.(비 ascii 코드만 인코딩)
따라서 웹에서 데이터로 URL에 사용해서는 안되는 &amp;, # 등이 그대로 남아있어 데이터가 잘려서 넘어오는 문제는 해결되지 않는다. 가장 좋은 해결책은 urlencode를 해서 넘겨 벋는 것이지만 협력사를 내맘대로 할 수는 없고&hellip;</p>

<p>자체적인 해결을 위한 해결법(꼼수)은 다음과 같다.
특히 #이 가장 큰 문제를 일으키므로 초출된 URL에서 데이터를 즉시 처리하지 않고 javascript로 현재 브라우저의 URL을 받아 다른 처리 페이지로 직접 넘겨서 파싱한다. 이렇게하면 일이 많이 번거로워지지만 협력사의 변경없이 여기서 모두 해결된다.
다만.. urlencode만 제대로 해줘도 되는걸 이런 꼼수를 써가며 억지로 해야하는가? 하는&hellip;</p>

<p>이왕 이 일로 글을 적는 김에 몇가지 함수도 덤으로&hellip;
php에서 url 인코딩에 사용하는 함수다. 당연히 urlencode 함수등을 사용하면되나 javascript에서 인코딩된 문자열을 그대로 전달받는 경우 등에 사용할 수 있다. 쉽게 말해서 javascript 문자열 인코딩 함수 php 대응 함수다.</p>

<pre><code class="php">/**
 * @desc javascript의 encodeURIComponent함수와 같은기능으로 문자열을 변환한다.
 * @param mixed $str 처리할 배열변수나 단일변수
 * @param String $fromEncofing 입력 인코딩
 * @return mixed 변환된 변수 그대로 반환
 * @exam $arr = String::encodeURI($arr);
 *       String::encodeURI($arr);
 */
static public function encodeURI(&amp;$str, $fromEncofing = null)
{
    if (is_array($str)) {
        String::arrayProc($str, 'String::encodeURI');
        return $str;
    }

    if (!is_null($fromEncofing)) {
        $trans = iconv($fromEncofing, "UTF-8", $str); // UHC 확장 완성형 한글
    }
    $trans = rawurlencode($trans);

    $str = $trans;
    return $str;
}

/**
 * @desc javascript의 decodeURIComponent함수와 같은기능으로 문자열을 변환한다.
 * @param mixed $str 처리할 배열변수나 단일변수
 * @param String $toEncofing 반환 인코딩
 * @return mixed 변환된 변수 그대로 반환
 * @exam $arr = String::decodeURI($arr);
 *       String::decodeURI($arr); //리턴받지 않아도 입력변수에 저장되어 나옴.
 */
static public function decodeURI(&amp;$str, $toEncofing = null)
{
    if (is_array($str)) {
        String::arrayProc($str, 'String::decodeURI');
        return $str;
    }

    //  euc-kr의 경우 확장완성형 한글에 대한 처리가 불가능함(예 : ㅂ ㅞ ㄺ)
    //  return iconv("UTF-8", "EUC-KR", rawurldecode($text));
    $str = rawurldecode($str);
    if (!is_null($toEncofing)) {
        $str = iconv("UTF-8", $toEncofing, $str);
    }
    return $str;
}

/**
 * @desc javascript의 escape함수로 인코딩된 문자를 디코딩한다.(encodeURIComponent추천)
 * @param String $str 처리할 배열변수나 단일변수
 * @param String $toEncofing 반환 인코딩
 * @return mixed 변환된 변수 그대로 반환
 * @exam $decStr = String::unescape($str);
 */
static public function unescape($text, $toEncofing = 'UTF-8')
{
    //return urldecode(preg_replace_callback('/%u([[:alnum:]]{4})/', array('self', 'tostring'), $text));
    return urldecode(
        preg_replace_callback(
            '/%u([[:alnum:]]{4})/',
            create_function(
                '$text',
                "echo '123'; return iconv('UTF-16LE', '" . $toEncofing . "', chr(hexdec(substr(\$text[1], 2, 2))).chr(hexdec(substr(\$text[1], 0, 2))));"
            ),
            $text
        )
    );
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phpstorm8 Phpunit 설치]]></title>
    <link href="http://blog.asamaru.net/2015/08/30/phpstorm8-phpunit-install/"/>
    <updated>2015-08-30T07:07:32+09:00</updated>
    <id>http://blog.asamaru.net/2015/08/30/phpstorm8-phpunit-install</id>
    <content type="html"><![CDATA[<p>phpstorm8 phpunit 세팅법</p>

<ul>
<li>PHPStorm</li>
<li>preferences > php > phpunit > + > By remote interpreter</li>
<li>remote server 추가 : ssh로 접속 설정</li>
<li>path to phpunit.phar 선택 > path to phpunit.phar : /czdev/vagrant/work/phpunit.phar</li>
<li>Default configuration file : /home/web/makeus/CZFramework/tests/phpunit.xml</li>
<li><p>Default bootstrap file : /home/web/makeus/CZFramework/tests/bootstrap.php</p></li>
<li><p>해당 서버에서 작업 : 로컬 경로와 서버의 경로가 같아야 실행에 문제가 없음
<code>bash
su -
cd /
mkdir /czdev/vagrant/work/ : 로컬과 같은 경로 생성
wget https://phar.phpunit.de/phpunit.phar
ln -s /home/web ./ : 로컬 소스 경로 맞춤
</code></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
