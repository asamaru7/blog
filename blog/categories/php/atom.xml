<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-12-10T08:38:17+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[selinux + PHP : Session Permission denied 오류]]></title>
    <link href="http://blog.asamaru.net/2015/12/02/selinux-plus-php-session-permission-denied-error/"/>
    <updated>2015-12-02T12:53:59+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/02/selinux-plus-php-session-permission-denied-error</id>
    <content type="html"><![CDATA[<p>서버를 새로 세팅하면서 CentOS 7에서 selinux와 함께 PHP 5.6을 설치했다. 기존에는 selinux를 사용하지 않도록 했었는데 이번에는 사용하도록 설정해서 설치를 완료했다. 그런데 세션을 사용하려고 <code>session_start();</code>를 하면 아래와 유사한 오류가 발생했다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">FastCGI sent in stderr: &quot;PHP message: PHP Warning: session_start(): open(/var/lib/php/session/sess_sk456vdemnp391spiv3i622i96, O_RDWR) failed: Permission denied
</code></pre></div>
<p>당연히 원인은 selinux이다. selinux가 적용된 상태라면 아무리 777 권한을 부여해도 접근을 할 수 없다. 그 해결법은 <a href="http://stackoverflow.com/a/33030627">(nginx/selinux) Permission denied error for sessions but files are created</a>에 잘 설명되어 있다.</p>

<p>결과적으로 아래의 방법을 통해 문제를 해결할 수 있다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mkdir /var/lib/php/session
<span class="nv">$ </span>mkdir /var/lib/php/wsdlcache
<span class="nv">$ </span>chmod <span class="m">777</span> /var/lib/php/session /var/lib/php/wsdlcache

<span class="nv">$ </span>restorecon -v <span class="s2">&quot;/var/lib/php/session&quot;</span>
<span class="nv">$ </span>semanage fcontext -a -t httpd_sys_rw_content_t /var/lib/php/session
<span class="nv">$ </span>restorecon -v <span class="s2">&quot;/var/lib/php/wsdlcache&quot;</span>
<span class="nv">$ </span>semanage fcontext -a -t httpd_sys_rw_content_t /var/lib/php/wsdlcache
</code></pre></div>
<p>mkdir과 chmod는 필요 없을 수 있다. 나의 경우는 아예 폴더도 만들어져 있지 않아서 폴더를 생성하고 권한도 함께 지정했다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[protobuf (Protocol Buffers)를 PHP에서 사용하기]]></title>
    <link href="http://blog.asamaru.net/2015/11/25/protobuf-protocol-buffers/"/>
    <updated>2015-11-25T19:53:52+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/25/protobuf-protocol-buffers</id>
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>는 무엇일까?
공식 사이트에서 아래와 같이 설명하고 있다.</p>

<blockquote>
<p>Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.</p>
</blockquote>

<p>간단히 말하면 언어와 플랫폼에 중립적이며 확장 가능한 구조화된 데이터 직렬화 도구라고 할 수 있겠다. XML과 유사하지만 더 작고, 더 빠르며, 더 단순하다고 소개하고 있다.</p>

<p>이번 글에서는 <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a> 자체에 대한 연구가 목적이 아니므로 참고할 만한 글을 아래에 소개하는 것으로 자세한 설명을 대체한다.</p>

<ul>
<li><p><a href="https://developers.google.com/protocol-buffers/docs/overview">Protocol Buffers Developer Guide</a></p></li>
<li><p><a href="https://github.com/eishay/jvm-serializers/wiki">Benchmark comparing serialization libraries on the JVM</a></p></li>
<li><p><a href="http://www.cgcii.co.kr/index.php?document_srl=2017&amp;mid=board_eLHH13">Tips - C++, C#, protobuf, JSON직렬화 성능 얼마나 차이날까?</a></p></li>
<li><p><a href="http://egloos.zum.com/javawork/v/2720889">Google Protocol Buffers 기본 사용법</a></p></li>
<li><p><a href="http://knight76.tistory.com/1366">구글 프로토콜 버퍼 (Google Protocl Buffer)</a></p></li>
</ul>

<hr>

<p>본론으로 들어가자면 이번에 개인적인 작업을 하는 과정에서 <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>를 사용할 일이 생겼다. 정확히 이야기하자면 Google Play를 대상으로 몇가지 실험을 하고 있다. 그런데 이 작업을 하다보니 Google Play 서버와 통신을 하려면 <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>를 사용 해야만 했다. <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>가 너무 길어서 이하에서는 그냥 PB라고 하겠다.</p>

<p>이번 작업에 필요한 몇가지 요소들을 지원하는 오픈소스 라이브러리들이 몇가지 있었으나 개발이 오래동안 멈춰진 것들이 대부분이라 기존 오픈소스들을 참고해서 직접 구현하기로 했다(사실 이 부분이 나의 최대 실수다. 생각보다 작업이 만만치 않아 시간을 많이 소요했다). 기존 오픈소스들은 java와 python, ruby로 구성된 것이 많았다. 그런데 나는 PHP로 구성하고 싶었다. 지금 생각하면 왜 그런 결정을 했는지 모르겠다. python이야 아직 익숙치 않아 패스하더라도 java로 작업하면 생각보다 빠르게 작업이 완료될 수 있었는데... 이야기가 갑자기 옆으로 샜는데 다시 본론으로...</p>

<p>어쨌든 PHP로 PB를 사용하는 것부터 시작해야 했다. 그런데 PB는 기본적으로 C++, JAVA, PYTHON을 지원한다. PHP를 공식 지원하지 않으므로 지원 라이브러리부터 찾아야 한다.</p>

<p>아래의 사이트들을 참고하자. 이 외에도 찾아보면 여러가지가 있다.</p>

<ul>
<li><a href="http://stuporglue.org/using-google-protcol-buffers-with-php-and-protoc-gen-php/">Using Google Protcol Buffers with PHP and protoc-gen-php</a></li>
<li><a href="http://phptrends.com/dig_in/protobuf">Php Trends.com : protobuf</a></li>
</ul>

<p>PHP에서 PB를 사용하는 오픈소스 중 그런대로 가장 이름이 알려진 프로젝트는 <a href="https://github.com/drslump/Protobuf-PHP">drslump/Protobuf-PHP</a> 였다(주관적인 생각이다). 그런데 설치 과정과 사용법이 간단하게 설명되어 있었지만 실제로는 그리 간단하지 않았다. 그래서 일단 접어두고 다른 라이브러리들도 하나씩 테스트 했다. 두서없이 작업하다보니 일일이 기록을 남기지 못했다. 잘 정리해 두었다면 비교에 도움이 되었을텐데 그 당시에는 정신이 없었다. 생각대로 되지 않아 닥치는대로 막 적용을 해보고 있었던지라.</p>

<p>결국 현재는 <a href="https://github.com/chobie/protoc-gen-php">chobie/protoc-gen-php</a>로 정착했다. 사실 이 라이브러리도 문제가 많긴하다. php에 모듈을 별도 설치해야하고 기타 의존 라이브러리도 설치해야 한다(간단하게 사용하려고 php를 선택한 것인데). 그리고 이 라이브러리는 <a href="https://pecl.php.net/package/protocolbuffers">PECL:protocolbuffers</a>에 등록되어 있어서 PECL을 사용해 설치도 가능하다. 하지만 나는 직접 설치했다. 이 라이브러리가 업데이트가 된지 오래되서 오류가 있는 부분을 몇가지 수정해서 사용하게 되면서 모듈을 그대로 사용할 수 없었다.</p>

<p>아래는 사용에 필요한 모듈들을 설치하는 과정을 bash shell로 작성해 둔 것이다. 실제 사용시에는 자신의 환경에 맞춰서 사용하면 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

su -c <span class="s2">&quot;yum install -y php56w-mbstring php56w-bcmath&quot;</span>

<span class="c"># protobuf 설치</span>
<span class="c"># https://github.com/chobie/protoc-gen-php</span>
su -c <span class="s2">&quot;yum install -y protobuf-compiler&quot;</span>

<span class="c"># https://github.com/chobie/php-protocolbuffers</span>
<span class="nb">cd </span>libs/bin/
git clone https://github.com/chobie/php-protocolbuffers.git
<span class="nb">cd </span>php-protocolbuffers
su -c <span class="s2">&quot;yum install -y php56w-devel&quot;</span>
phpize
./configure
make
su -c <span class="s2">&quot;make install ; echo \&quot;extension=protocolbuffers.so\&quot; &gt;&gt; /etc/php.ini&quot;</span>
</code></pre></div>
<p>아래는 composer.json 설정 부분이다.</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&quot;require&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;asamaru7/protoc-gen-php&quot;</span><span class="p">:</span> <span class="s2">&quot;~0.1.1&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>갑자기 모듈명이 asamaru7로 변경된 것에 유의하자. <a href="https://github.com/chobie/protoc-gen-php">chobie/protoc-gen-php</a>의 fork 프로젝트에서 변경 부분을 내가 따로 fork한 프로젝트에 merge하고 내가 필요한 부분을 수정해서 <a href="https://packagist.org/packages/asamaru7/protoc-gen-php">Packagist</a>에 등록했다.</p>

<p>다음으로 proto 파일로 실제 php 파일을 만드는 과정이다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">protoc <span class="se">\</span>
    --plugin<span class="o">=</span>protoc-gen-php<span class="o">=</span><span class="s1">&#39;../vendor/asamaru7/protoc-gen-php/bin/protoc-gen-php&#39;</span> <span class="se">\</span>
    --proto_path<span class="o">=</span><span class="s1">&#39;/home/web/project/libs/protobuf/&#39;</span> <span class="se">\</span>
    --php_out<span class="o">=</span><span class="s1">&#39;:../Class/Protobuf&#39;</span> <span class="se">\</span>
    <span class="s1">&#39;/home/web/project/libs/protobuf/logs.proto&#39;</span>
</code></pre></div>
<p>이상하게 <code>--proto_path</code>를 사용함에도 full path를 지정해만 정상적으로 생성이 된다. 자주 사용할 부분이 아니므로 일단 패스했다.</p>

<p>마지막으로 php에서의 사용.</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">$ch = curl_init();</span>
<span class="x">curl_setopt($ch, CURLOPT_URL, &quot;https://android.clients.google.com/~~&quot;);</span>
<span class="x">curl_setopt($ch, CURLOPT_HEADER, 0);</span>
<span class="x">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span>
<span class="x">curl_setopt($ch, CURLOPT_POST, 1);</span>
<span class="x">curl_setopt($ch, CURLOPT_POSTFIELDS, $request-&gt;serializeToString());</span>
<span class="x">curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);</span>
<span class="x">curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);</span>
<span class="x">curl_setopt($ch, CURLOPT_HTTPHEADER, [</span>
<span class="x">    &quot;Content-type: application/x-protobuffer&quot;</span>
<span class="x">]);</span>
<span class="x">$content = curl_exec($ch);</span>
<span class="x">curl_close($ch);</span>
</code></pre></div>
<p><code>$request-&gt;serializeToString()</code> 이 부분이 중요한 부분이다. <code>$request</code>는 protoc에 의해 생성된 class의 인스턴스다. 전송시에는 <code>serializeToString()</code>를 사용해서 직렬화하는 것이다.</p>

<p>다음은 수신시.</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">$response = \Response::parseFromString($content);</span>
</code></pre></div>
<p><code>parseFromString()</code>를 사용해서 수신된 PB 직렬화 데이터를 역직렬화 할 수 있다.</p>

<hr>

<p>그런데 가급적 PHP에서는 PB를 사용하지 말자. &quot;이제까지 사용 방법을 설명해놓고 이게 무슨 말이야?&quot;라고 생각할 수 있는데 이유를 설명하겠다.</p>

<p>이번에 설명한 라이브러리뿐 아니라 <a href="https://github.com/drslump/Protobuf-PHP">drslump/Protobuf-PHP</a> 외에도 테스트한 모든 라이브러리가 group type을 지원하지 않는다. PB v2에서 deprecated 된 type이긴 하지만 Google Play에서는 group type을 사용하고 있었다. 다행히 내가 하고자하는 부분에서는 group이 필요없어서 proto 파일에서 제거하고 작업했지만 group type을 사용하게 되면 오류가 난다. 내가 테스트 해보지 못한 라이브러리에서 지원하는 것이 있을지는 모르겠지만 내가 본 것은 없다. 또한 int의 길이 문제과 같이 데이터 타입에 대한 처리에 신경을 써줘야하는 부분들이 있다.</p>

<p>pure php로 만들어진 라이브러리가 아닌 이상 어짜피 외부 모듈의 설치가 필요하니 아예 이 부분을 python이나 java로 처리하는게 나을지도 모른다. 게다가 pure php로 제작된 모듈은 성능 상의 문제에 대한 이야기도 있다(어짜피 나의 경우는 성능은 중요하지 않은 경우이지만).</p>

<p>그 외에도 작업중에 PB 때문에 고생한 것을 생각하면... 정말 권하고 싶지 않다. 사실 내가 사용을 잘못해서 그런 것일 수 있지만... 어쨌든 JSON 등에 비해 PHP에서의 이득은 없는 것 같다.</p>

<p>그럼에도 나의 경우처럼 상대 서버가 PB를 사용해서 어쩔 수 없다면 위 글을 참고하길 바란다.</p>

<hr>

<p>이번 작업에 대해서는 자세히 설명하고자 하면 너무 길어져서 중간중간 필요한 부분만 적었다. 그러다 보니 &quot;이게 무슨 말인가?&quot;라는 생각이 들 수 있는데 양해 바란다. 이해가 안되는 부분은 질문한다면 따로 설명하도록 하겠다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP를 CLI에서 사용시 ANSI Colors 적용하기]]></title>
    <link href="http://blog.asamaru.net/2015/10/23/php-cli-ansi-colors/"/>
    <updated>2015-10-23T20:46:06+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/23/php-cli-ansi-colors</id>
    <content type="html"><![CDATA[<p>php를 CLI(shell 환경)에서 사용시 처리 과정을 확인하기 위한 로그나 결과를 <code>echo</code> 등을 사용해서 출력하는 방법을 사용할 것이다.</p>

<p>보통 shell script 작성시 python이나 bash script를 많이 사용하지만 php 프로그램과 연결된 작업을 해야 하거나 php가 손에 익어서 편할 경우 등 여러가지 이유로 php를 shell에서 사용하는 경우도 많다.</p>

<p>실제로 나는 가급적 프로세스 처리는 bash를 사용하고 간단한 작업은 python으로 하려고 하지만 php가 아무래도 손에 익은지라 조금 복잡한 작업은 php 프로그램과 무관하더라고 php를 사용하는 경우가 많다.</p>

<p>나는 이런 작업 과정에서 출력되는 내용을 보기 좋게 표현하는 부분이 항상 불만이었다. 몇 줄 안나오는 문제면 상관없지만 다량의 로그가 출력되는 작업시에는 중요한 부분을 조금더 잘 보이게 할 방법이 필요했다. 그래서 여러 줄을 띄우거나 탭을 들여쓰는 등의 방법을 주로 사용했었다.</p>

<p>그런데 오늘도 이런 작업을 하던 중에 갑자기 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape code</a> 중 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">ANSI Color</a>가 생각났다(왜 이제야 이런 것이 있다는 것을 떠 올렸는지 모르겠다). 직접 구현해도 되겠지만 아무래도 귀찮을 듯해서 검색을 해봤더니 생각보다 많은 자료를 찾을 수 있었다. 역시 사람들은 비슷한 생각을 하나보다.</p>

<p>아래는 이번에 찾은 자료들의 목록이다.</p>

<ul>
<li><a href="http://www.if-not-true-then-false.com/2010/php-class-for-coloring-php-command-line-cli-scripts-output-php-output-colorizing-using-bash-shell-colors/">PHP CLI Colors – PHP Class Command Line Colors (bash)</a></li>
<li><a href="https://gist.github.com/superbrothers/3431198">superbrothers/ansi-color.php</a></li>
<li><a href="http://softkube.com/blog/generating-command-line-colors-with-php">Generating Command Line Colors with PHP</a></li>
<li><a href="http://blog.ianty.com/php/ansicolor/">PHP port of Term::ANSIColor</a></li>
</ul>

<p>나는 이 중에서 맨마지막의 <a href="http://blog.ianty.com/php/ansicolor/">PHP port of Term::ANSIColor</a>를 선택했다. 필요에 맞게 아주 약간의 수정을 해서 사용해 봤는데 다양한 형식을 지원해서 나름 만족스럽다.</p>

<p>혹시 php를 CLI에서 사용할 일이 있다면 한번쯤 사용해 보기를 추천한다. 위의 라이브러리들을 굳이 쓰지 않더라도 소스 코드를 조금만 보면 ANSI를 적용하는 방법을 알 수 있으니 보기 좋은 결과물을 원할때 써보기 바란다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP의 DateTime을 Java (Android)로 전달하기]]></title>
    <link href="http://blog.asamaru.net/2015/09/17/datetime-from-php-to-java-android/"/>
    <updated>2015-09-17T18:45:26+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/17/datetime-from-php-to-java-android</id>
    <content type="html"><![CDATA[<p>안드로이드 앱을 개발하게되면 많은 경우에 서버와의 데이터 연결이 필요하다. 대부분의 데이터 타입은 이 과정에서 큰 문제를 일으키지 않는다(데이터 타입만 명확히 한다면). 하지만 DateTime은 조금 까다로울 수 있다. 프로그램에서 시간은 TimeZone을 가지고 있기 때문에 이 부분을 명확히 하지 않으면 의도치 않은 시간으로 표시된다. 게다가 형식이 맞지 않는다면 제대로 전달되지 않을 수도 있다.</p>

<blockquote>
<p>네이버 D2에 있는 <a href="http://d2.naver.com/helloworld/645609">Java의 날짜와 시간 API</a>를 보면 Java에서의 Date 처리가 불편하다는 얘기가 있다.</p>
</blockquote>

<p>이번 작업에서는 서버는 PHP를 사용하고 있는 상황이었고 클라이언트는 <a href="http://androidannotations.org/">AndroidAnnotations</a>의 <a href="https://github.com/excilys/androidannotations/wiki/Rest-API#rest">Rest-API</a>를 사용했다. 수신 데이터의 파싱은 <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/json/GsonHttpMessageConverter.html">GsonHttpMessageConverter</a>를 사용하는 상황이다. 이 글의 주제에서 벗어나므로 <a href="http://androidannotations.org/">AndroidAnnotations</a>나 <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/json/GsonHttpMessageConverter.html">GsonHttpMessageConverter</a>에 대한 부분은 설명하지 않겠다.</p>

<p>GsonHttpMessageConverter를 사용해서 데이터를 파싱하는 경우 대상이되는 class의 멤버변수의 데이터 타입에 맞추어 데이터를 채워준다. 당연히 전송되는 데이터가 JSON 형식이어야 한다. 다른 데이터 타입의 경우 앞서 설명한 것과 같이 데이터 타입만 맞춰준다면 아주 쉽게 데이터를 받을 수 있다(그것이 이것을 사용하는 주요 목적이다). 그런데 DateTime 타입은 조금 신경을 써줘야 한다.</p>

<p>자 그럼 서버에서 데이터를 보낼 수 있는 방법에 어떤 것이 있을까? 가장 일반적인 방법으로는 timestamp(int), string, Date가 있다. 어떤 것을 쓰더라도 무방하지만 앞서 얘기한 것처럼 GsonHttpMessageConverter를 써서 간단히 데이터를 정확한 형식으로 받는 것이 편리하기 때문에 전송시 데이터 타입을 맞추는 것이 좋다.</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">// string 타입으로 전송</span>
<span class="x">$date = &quot;2015-09-17 10:00:00&quot;;</span>
<span class="x">// int 타입으로 전송</span>
<span class="x">$date = (new \DateTime(&quot;2015-09-17 10:00:00&quot;))-&gt;getTimestamp();</span>
<span class="x">// Date 타입으로 전송</span>
<span class="x">$date = (new \DateTime(&quot;2015-09-17 10:00:00&quot;))-&gt;setTimeZone(new \DateTimeZone(&#39;UTC&#39;))-&gt;format(&#39;Y-m-d\TH:i:s\Z&#39;);</span>
</code></pre></div>
<p>위의 코드를 보면 PHP에서 전송할 때 넘겨줄 데이터의 예시를 타입별로 제시했다. 앞서 강조했던대로 안드로이드 클라이언트에서 GsonHttpMessageConverter를 이용해 Date 타입으로 바로 받으려면 마지막에 있는 &quot;Date 타입으로 전송&quot; 방식을 사용하면 된다.</p>

<p>해당 부분을 보면 두가지 처리를 해주고 있다. 첫번째로 TimeZone을 설정한 것이고, 두번째로 Date Format을 지정한 것이다. 사실 이 부분들을 잘 몰라서 삽질을 조금 했었다. 처음엔 Date Format을 어떻게 전달해야할지 몰라 해맸다. 제대로 수신을 하지 못했던 것이다. Format을 맞추고 나니 이젠 보낸 시간과 받은 시간이 달랐다. 이 부분은 TimeZone의 문제이므로 TimeZone을 지정해서 해결했다. TimeZone에 사용한 UTC는 <a href="https://ko.wikipedia.org/wiki/%ED%98%91%EC%A0%95_%EC%84%B8%EA%B3%84%EC%8B%9C">협정 세계시</a>라는 뜻이다. 이것과 세트로 format에서 끝에 \Z를 붙여 데이터가 <a href="https://ko.wikipedia.org/wiki/ISO_8601">ISO 8601</a>에 따라 UTC를 따르고 있음을 표시한 것이다.</p>

<p>결론적으로 위의 형식을 사용하면 GSON으로 바로 받아도 정확한 시간을 사용할 수 있다.</p>

<p>사실 위의 경우는 GsonHttpMessageConverter를 사용한다는 상황을 가정한 것으로 이것을 사용하지 않고 직접 데이터를 받아 GSON을 통해 파싱한다면 아래의 방법을 쓸 수도 있다. Format을 보면 알겠지만 UTC Date여야 한다(정확한 시간 처리를 위해). &quot;yyyy-MM-dd HH:mm:ss&quot;이 Format을 쓸 수도 있으나 TimeZone 명시되지 않으므로 시간이 다르게 보일 수 있다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Gson</span> <span class="n">gson</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">GsonBuilder</span><span class="o">().</span><span class="na">setDateFormat</span><span class="o">(</span><span class="s">&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssZ&quot;</span><span class="o">).</span><span class="na">create</span><span class="o">();</span>
</code></pre></div>
<p>아래는 추가적으로 다른 타입으로 수신했을 때 안드로이드 클라이언트에서 Date 타입으로 변환하고자 할때 사용할 수 있는 참고 코드들이다.</p>

<p>** string 타입으로 수신시 **
<code>java
try {
    String dateTime = &quot;2015-09-17 10:00:00&quot;;
    SimpleDateFormat dateParser = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.KOREA);
    Date date = dateParser.parse(dateTime);
} catch (ParseException e) {
    e.printStackTrace();
}
</code></p>

<p>** timestamp(int) 타입으로 수신시 **</p>

<p>PHP에서의 TimeStamp는 초단위(s)지만 Java에서는 밀리초(ms) 단위이므로 1000을 곱해서 넣어 주어야 한다.
그리고 Java에서는 Date가 Deprecated되어 <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html">Calendar</a>를 더 권장한다고 한다. <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Date.html">정확하게는 완전히 Deprecated된 것은 아니고 일부 생성자가 그렇다는 것</a>이지만 <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Calendar.html">Calendar</a>가 더 다양한 기능을 제공하므로 더 권장된다는 것이다. 자세한 이유는 검색해보면 많이 나온다.</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Calendar 사용</span>
<span class="n">Calendar</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
<span class="n">c</span><span class="o">.</span><span class="na">setTimeInMillis</span><span class="o">(</span><span class="n">timestamp</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
<span class="n">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getTime</span><span class="o">();</span>

<span class="c1">// OR</span>

<span class="c1">// Date 사용</span>
<span class="n">Date</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Date</span><span class="o">(</span><span class="n">timestamp</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">);</span>
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP에서 soundex / metaphone key 구하기]]></title>
    <link href="http://blog.asamaru.net/2015/09/14/soundex-slash-metaphone-key-in-php/"/>
    <updated>2015-09-14T21:19:33+09:00</updated>
    <id>http://blog.asamaru.net/2015/09/14/soundex-slash-metaphone-key-in-php</id>
    <content type="html"><![CDATA[<p>앞선 포스팅에서 <a href="/2015/09/14/calculate-distance-between-two-strings-in-php-levenshtein/">levenshtein()</a> 함수, <a href="/2015/09/14/calculate-distance-between-two-strings-in-php-similar-text">similar_text()</a>에 대해 알아보았다.
이런 문자열 비교 함수는 아니지만 문자열의 soundex key를 구하여 발음이 유사한 단어들을 찾을 수 있도록 도와주는 soundex() 함수와 이보다 더 정확한 결과를 반환한다고 하는 metaphone() 함수에 대해서 알아보자.</p>

<h2 id="soundex란">soundex란?</h2>

<blockquote>
<p>Soundex란 발음이 유사한 서로다른 철자의 단어를 그룹화하여 철자 입력 오류를 보정하기 위한 색인시스템으로 초기에는 주로 사람이름을 검색하기 위한 용도로 사용되었으나 인터넷 검색이 활성화되면서 다양한 분야에서 응용되고 있다. 대표적인 Soundex Appliation은 “US Bureau of the Censu s”의 것이며, AT&amp;T의 Standard soundex algorithm도 있다.
(츨처 : <a href="http://www.nicklib.com/nlp/2297">http://www.nicklib.com/nlp/2297</a>)</p>
</blockquote>

<h2 id="soundex-함수"><a href="http://php.net/manual/en/function.soundex.php">soundex()</a> 함수</h2>

<p><a href="http://php.net/manual/en/function.soundex.php">php 메뉴얼의 설명</a>에 따르면 soundex() 함수는 발음이 유사한 단어들이 같은 soundex 키를 생성하므로, 발음은 알고 있지만 스펠은 모르는 단어를 데이터베이스에서 쉽게 찾을 수 있다. soundex 함수는 문자로 시작하는 4문자 문자열을 반환한다.</p>

<p>이 soundex 함수는 &quot;The Art Of Computer Programming, vol. 3: Sorting And Searching&quot;, Addison-Wesley (1973), 391-392쪽에서 Donald Knuth가 기술한 것이다.</p>

<h3 id="기본-사용법">기본 사용법</h3>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">string soundex ( string $str )</span>
</code></pre></div>
<h3 id="함수-인자">함수 인자</h3>

<h4 id="str">str</h4>

<p>입력 문자열</p>

<h3 id="반환값">반환값</h3>

<p>soundex 키를 문자열로 반환한다.</p>

<h3 id="예시">예시</h3>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Euler&quot;</span><span class="p">)</span>       <span class="o">==</span> <span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Ellery&quot;</span><span class="p">);</span>    <span class="c1">// E460</span>
<span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Gauss&quot;</span><span class="p">)</span>       <span class="o">==</span> <span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Ghosh&quot;</span><span class="p">);</span>     <span class="c1">// G200</span>
<span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Hilbert&quot;</span><span class="p">)</span>     <span class="o">==</span> <span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Heilbronn&quot;</span><span class="p">);</span> <span class="c1">// H416</span>
<span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Knuth&quot;</span><span class="p">)</span>       <span class="o">==</span> <span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Kant&quot;</span><span class="p">);</span>      <span class="c1">// K530</span>
<span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Lloyd&quot;</span><span class="p">)</span>       <span class="o">==</span> <span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Ladd&quot;</span><span class="p">);</span>      <span class="c1">// L300</span>
<span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Lukasiewicz&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">soundex</span><span class="p">(</span><span class="s2">&quot;Lissajous&quot;</span><span class="p">);</span> <span class="c1">// L222</span>
</code></pre></div>
<h2 id="metaphone-함수"><a href="http://php.net/manual/en/function.metaphone.php">metaphone()</a> 함수</h2>

<p><a href="http://php.net/manual/en/function.metaphone.php">php 메뉴얼의 설명</a>에 따르면 metaphone() 함수는 soundex()처럼 유사한 발음의 단어에 대해 동일한 키를 생성다. 이 함수는 영어 발음의 기본 법칙을 사용하는 soundex()보다 훨씬 정확하다. 메타폰 생성 키는 가변 길이를 가진다.</p>

<p>metaphone은 Lawrence Philips <lphilips at verity dot com>가 개발하였였고 이는 [&quot;Practical Algorithms for Programmers&quot;, Binstock &amp; Rex, Addison Wesley, 1995]에 수록되어 있다.</p>

<h3 id="기본-사용법">기본 사용법</h3>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">string metaphone ( string $str [, int $phonemes ] )</span>
</code></pre></div>
<h3 id="함수-인자">함수 인자</h3>

<h4 id="str">str</h4>

<p>입력 문자열.</p>

<h4 id="phonemes">phonemes</h4>

<p>이 매개 변수는 음소 문자로 반환된 metaphone key의 길이를 제한한다. 0이 디폴트 값으로 제한하지 않음을 의미한다.</p>

<h3 id="반환값">반환값</h3>

<p>메타폰 키를 문자열로 반환한다.</p>

<h2 id="응용-아이디어">응용 아이디어</h2>

<p>알파벳 문자열의 유사도를 개선하는데에 응용할 수도 있을 것 같다. 문자열을 soundex나 metaphone key로 변환하여 문자열 유사도를 비교하면 조금 더 개선된 유사도를 구할 수 있을 것 같다. 정확히는 다른 의미가 되지만 발음이 유사한 문장을 유사 문장으로 인정하는 효과를 얻을 수 있을 것이다.</p>

<p>사실 중요한 문제는 soundex나 metaphone 뿐만 아니라 Double Metaphone, Caverphone 같은 알고리즘은 알파벳 문자에 대한 음성 특징을 추출하는 것으로 한글에는 사용할 수 없다. 하지만 한글을 초/중/종성으로 분리하고 발음 기호로 변환하는 부분을 추가 처리하면 한글에도 응용할 수 있을 것으로 보인다.</p>

<p>게대가 한글을 영어 발음으로 변환하는 오픈소스들도 찾아보니 있다.(<a href="https://metacpan.org/pod/Lingua::KO::Munja">https://metacpan.org/pod/Lingua::KO::Munja</a>)</p>

<p>추후에 기회가 된다면 직접 구현 해봐야겠다.</p>
]]></content>
  </entry>
  
</feed>
