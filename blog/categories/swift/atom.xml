<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-12-04T13:46:58+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift : Async - Background Threads - GCD(Grand Central Dispatch)]]></title>
    <link href="http://blog.asamaru.net/2015/11/24/swift-background-threads-gcd-grand-central-dispatch/"/>
    <updated>2015-11-24T07:35:18+09:00</updated>
    <id>http://blog.asamaru.net/2015/11/24/swift-background-threads-gcd-grand-central-dispatch</id>
    <content type="html"><![CDATA[<p>오늘은 swift에 비동기 처리에 사용하는 <a href="https://github.com/duemunk/Async">Async</a>라는 라이브러리를 소개하고자 한다. <a href="https://github.com/duemunk/Async">Async</a>는 &quot;Syntactic sugar in Swift for asynchronous dispatches in Grand Central Dispatch&quot;라고 소개되어 있다. <a href="https://github.com/duemunk/Async">Async</a>를 소개하기 전에 swift에서의 기본적인 비동기 처리에 대해 먼저 설명한다.</p>

<p>swift는 비동기(Asynchronous) 처리에 사용하는 <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/">GCD(Grand Central Dispatch)</a>를 사용할 수 있다. GCD(Grand Central Dispatch)는 C로 구성된 스레드 관리 기술로 iOS4 부터 지원한다. NSThread, NSOperation 보다 쉽게 쉽게 사용할 수 있다.</p>

<p>스레드는 다양한 병렬 작업에 사용하지만 특히 앱 개발시에는 더욱 자주 사용하게 된다. 안드로이드와 iOS는 UI처리 등의 앱의 실행을 main 스레드에서 처리한다. 그런데 이 main 스레드에서 무거운 작업을 하게 된다면 UI의 갱신이 지연되므로 화면의 멈춤 현상이 발생한다. 특히 안드로이드의 경우는 main 스레드에서 네트워크 처리 등을 할 수 없도록 제한이 걸려있다(제한을 풀 수 있으나 ANR 문제 등으로 결국은 사용하지 못하는 것과 같다). 이러한 문제를 해결하기 위해서는 스레드의 사용이 필수다.</p>

<p>그럼 <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/">GCD(Grand Central Dispatch)</a>에 대해서 알아보자.</p>

<p>GCD는 기본적으로 아래의 queue를 가지고 있다.</p>

<ul>
<li><p><strong>Main</strong>: tasks execute serially on your application’s main thread</p></li>
<li><p><strong>Concurrent</strong>: tasks are dequeued in FIFO order, but run concurrently and can finish in any order.</p></li>
<li><p><strong>Serial</strong>: tasks execute one at a time in FIFO order</p></li>
</ul>

<p>GCD에 대한 자세한 설명은 워낙에 많으니 자세히 설명하지 않고 간단한 예시만 보여주고자 한다.</p>

<p>일단 swift 이전에 objective-c에서는 아래와 같이 사용한다.</p>
<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
    <span class="c1">// do some task</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
        <span class="c1">// update some UI</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p>동일한 동작을 swift에서 사용하면 아래와 같다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="n">priority</span> <span class="o">=</span> <span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>
<span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// do some task</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// update some UI</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>block object의 표현만 차이가 날 뿐 사실상 거의 차이가 없다.</p>

<p>위 코드를 간단히 설명하자면 global queue에서 작업을 수행하고 main queue에서 UI 변경 작업을 하도록 한 코드다.</p>

<p>뭐 크게 사용이 어렵지도 않고 크게 불편하지는 않다. 하지만 이런 과정을 더욱 쉽게 구성할 수 있도록 도와주는 것이 <a href="https://github.com/duemunk/Async">Async</a>다. 상세한 예시는 해당 사이트를 방문하면 다양하게 소개하고 있다.</p>

<p>그 중에서 Async의 장점을 잘 보여주는 예시를 하나 소개한다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="n">seconds</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">Async</span><span class="p">.</span><span class="n">main</span><span class="p">(</span><span class="nl">after</span><span class="p">:</span> <span class="n">seconds</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Is called after 0.5 seconds&quot;</span><span class="p">)</span>
<span class="p">}.</span><span class="n">background</span><span class="p">(</span><span class="nl">after</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;At least 0.4 seconds after previous block, and 0.9 after Async code is called&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>&quot;Is called after 0.5 seconds&quot; 메시지를 main 스레드에서 0.5초 뒤에 출력한 후 0.4초 뒤 background 스레드에서 &quot;At least 0.4 seconds after previous block, and 0.9 after Async code is called&quot;를 출력하는 예시다. 이 예시를 보면 알 수 있듯이 <a href="https://github.com/duemunk/Async">Async</a>는 chaining을 지원하며 스레드를 작업 완료에 따라 순차적으로 실행 할 수 있도록 도와준다.</p>

<p>스레드 작업을 취소하는 예시 하나만 더 아래에 소개한다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// Cancel blocks not yet dispatched</span>
<span class="k">let</span> <span class="n">block1</span> <span class="o">=</span> <span class="n">Async</span><span class="p">.</span><span class="n">background</span> <span class="p">{</span>
    <span class="c1">// Heavy work</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="mf">.1000</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;A \(i)&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">let</span> <span class="n">block2</span> <span class="o">=</span> <span class="n">block1</span><span class="p">.</span><span class="n">background</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;B – shouldn&#39;t be reached, since cancelled&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">Async</span><span class="p">.</span><span class="n">main</span> <span class="p">{</span>
    <span class="c1">// Cancel async to allow block1 to begin</span>
    <span class="n">block1</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span> <span class="c1">// First block is _not_ cancelled</span>
    <span class="n">block2</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span> <span class="c1">// Second block _is_ cancelled</span>
<span class="p">}</span>
</code></pre></div>
<p>위에서 소개한 것처럼 <a href="https://github.com/duemunk/Async">Async</a>는 swift에서의 thread 작업을 아주 쉽게 할 수 있도록 도와준다.</p>

<p>한가지 라이브러리를 더 소개하자면 위 라이브러리와는 성격이 조금 다르지만 안드로이드의 AsyncTask 같은 작업이 필요하다면 <a href="https://github.com/ReactKit/SwiftTask">SwiftTask</a>를 참고해보면 도움이 될 것 같다. <a href="https://github.com/ReactKit/SwiftTask">SwiftTask</a>는 &quot;Promise + progress + pause + cancel + retry for Swift.&quot;라고 소개하고 있다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods의 Swift compiler flags(DEBUG) 설정하기]]></title>
    <link href="http://blog.asamaru.net/2015/10/22/setting-swift-compiler-flags-in-cocoapods/"/>
    <updated>2015-10-22T11:28:37+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/22/setting-swift-compiler-flags-in-cocoapods</id>
    <content type="html"><![CDATA[<p><a href="http://blog.asamaru.net/2015/10/21/xcode-create-sub-module-using-cocoapods/">Xcode에서 CocoaPods를 이용해 sub module 만들기</a>라는 글에서 Sub Module을 만드는 방법을 설명했었다. 그런데 이렇게 연결된 Module을 사용하는 과정에서 불편한 부분이 생겼다. 다름아닌 <code>#if DEBUG</code>를 Sub Module에서 적용이 되지 않는 것이다. 이 부분은 생각해보면 당연하다 별개의 Module을 빌드에서 연결하는 것이니 <code>DEBUG</code> 상수를 사용하기 위한 설정을 별도로 해야 하는 것이다(<code>DEBUG</code> 상수 설정 방법은 <a href="http://seorenn.blogspot.kr/2014/11/xcode-swift-debug.html">Swift 프로젝트의 디버그(DEBUG) 플래그</a>을 참고하면 된다). 그래서 CocoaPods에서 추가해준 프로젝트에 <code>DEBUG</code> 관련 설정을 해주니 원하는대로 <code>#if DEBUG</code>를 사용할 수 있었다. 그런데 여기서 모든 문제가 해결된 것이 아니었다. <code>pod update</code> 실행시 Module이 재설치 되면서 관련 설정이 다시 초기화 되는 것이다. 이걸 매번 해줄 수도 없고... 그래서 조금 찾아보니 <a href="http://marginalfutility.net/2015/10/11/swift-compiler-flags/">Setting Swift compiler flags in CocoaPods</a>라는 글에서 해결 방법을 제시하고 있었다.</p>

<p>결론을 이야기하자면 <code>Podfile</code>에서 <code>post_install</code>을 사용해서 <code>DEBUG</code> 상수를 자동으로 추가하도록 하는 것이다. <code>Podfile</code>에 아래의 내용을 추가하면 된다.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">post_install</span> <span class="k">do</span> <span class="o">|</span><span class="n">installer</span><span class="o">|</span>
    <span class="n">installer</span><span class="o">.</span><span class="n">pods_project</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">target</span><span class="o">|</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;{원하는 모듈명}&#39;</span>
            <span class="n">target</span><span class="o">.</span><span class="n">build_configurations</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
                <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;Debug&#39;</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">build_settings</span><span class="o">[</span><span class="s1">&#39;OTHER_SWIFT_FLAGS&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="s1">&#39;-DDEBUG&#39;</span>
                    <span class="k">else</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">build_settings</span><span class="o">[</span><span class="s1">&#39;OTHER_SWIFT_FLAGS&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 2.0에서 상속 가능한 Singleton 생성하기]]></title>
    <link href="http://blog.asamaru.net/2015/10/21/swift-2-dot-0-singleton/"/>
    <updated>2015-10-21T16:28:03+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/21/swift-2-dot-0-singleton</id>
    <content type="html"><![CDATA[<p>오늘은 swift에서 Singleton 객체를 생성하는 방법을 설명하고자 한다.</p>

<p>우선 Objective-C에서는 어떻게 생성하는지는 아래를 보면 알 수 있다.</p>

<p>우선 Singleton Class 정의.</p>
<div class="highlight"><pre><code class="language-ObjC" data-lang="ObjC"><span class="k">@implementation</span> <span class="nc">SingletonCls</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">sharedManager</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">SingletonCls</span> <span class="o">*</span><span class="n">staticManager</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>

    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">staticManager</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">staticManager</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div>
<p>그리고 사용시.</p>
<div class="highlight"><pre><code class="language-ObjC" data-lang="ObjC"><span class="p">[</span><span class="n">SingletonCls</span> <span class="n">sharedManager</span><span class="p">];</span>
</code></pre></div>
<p>그럼 Swift에서는 어떻게 하는지를 살펴보자. 사실 아주 간단하다.</p>

<p>Singleton Class 정의.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">class</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">let</span> <span class="n">sharedInstance</span> <span class="o">=</span> <span class="n">SingletonCls</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<p>그리고 사용시.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">SingletonCls</span><span class="p">.</span><span class="n">sharedInstance</span>
</code></pre></div>
<p>그런데 오늘 하고자하는 이야기는 이게 아니다. 기본적인 Singleton Class를 정의하는 것은 검색하면 많이 나온다. 하지만 내가 필요했던 것은 상속이 가능한 Swift Singleton Class다. 아래의 예를 보자.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">class</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">let</span> <span class="n">sharedInstance</span> <span class="o">=</span> <span class="n">SingletonCls</span><span class="p">()</span>

    <span class="k">var</span> <span class="nl">X</span><span class="p">:</span><span class="n">Int</span><span class="o">?</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nl">SingletonClsChild</span> <span class="p">:</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nl">Y</span><span class="p">:</span><span class="n">Int</span> <span class="o">=</span> <span class="mi">9</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">A</span> <span class="o">=</span> <span class="n">SingletonClsChild</span><span class="p">.</span><span class="n">sharedInstance</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">print</span><span class="p">((</span><span class="n">A</span> <span class="kt">as</span><span class="o">!</span> <span class="n">SingletonClsChild</span><span class="p">).</span><span class="n">Y</span><span class="p">);</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">test.SingletonCls
Could not cast value of type &#39;test.SingletonCls&#39; (0x10d89d2e0) to &#39;test.SingletonClsChild&#39; (0x10d89d390).
</code></pre></div>
<p>위 코드는 실행하면 오류가 난다. <code>SingletonClsChild.sharedInstance</code>의 결과가 <code>SingletonCls</code> 인스턴스이기 때문이다.</p>

<p>우선 이 문제를 해결하기 위한 기본 코드부터 보자. <a href="http://www.scriptscoop.net/t/23f5fc2cdd82/swift-singleton-inheritance.html">Swift: Singleton Inheritance</a>에 나온 코드를 약간 수정했다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">public</span> <span class="k">class</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">var</span> <span class="n">_singleton_instance</span> <span class="o">=</span> <span class="p">[</span><span class="nl">String</span><span class="p">:</span> <span class="n">SingletonCls</span><span class="p">]()</span>
    <span class="n">public</span> <span class="k">class</span> <span class="k">var</span> <span class="nl">shareInstance</span><span class="p">:</span><span class="n">SingletonCls</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">classname</span> <span class="o">=</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">_singleton_instance</span><span class="p">[</span><span class="n">classname</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">_singleton_instance</span><span class="p">[</span><span class="n">classname</span><span class="p">])</span><span class="o">!</span>
            <span class="p">}</span>
            <span class="k">let</span> <span class="n">singletonObject</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">()</span>
            <span class="n">_singleton_instance</span><span class="p">[</span><span class="n">classname</span><span class="p">]</span> <span class="o">=</span> <span class="n">singletonObject</span>
            <span class="k">return</span> <span class="n">singletonObject</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">required</span> <span class="n">public</span> <span class="k">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">public</span> <span class="k">class</span> <span class="nl">SingletonClsChild</span> <span class="p">:</span> <span class="n">SingletonCls</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">SingletonCls</span><span class="p">.</span><span class="n">sharedInstance</span>
<span class="n">SingletonClsChild</span><span class="p">.</span><span class="n">sharedInstance</span>
</code></pre></div>
<p>위 코드에서 제시한 방법을 사용하면 상속이 가능한 Singleton Class를 정의할 수 있다. 사실 여기에 약간의 기능이 더 추가되어 있다. 호출하는 Class에 따라 각각의 Instance를 생성해서 보관하는 부분이다. 예를 들어 아래의 코드를 보자.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">public</span> <span class="k">class</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">var</span> <span class="n">_singleton_instance</span> <span class="o">=</span> <span class="p">[</span><span class="nl">String</span><span class="p">:</span> <span class="n">SingletonCls</span><span class="p">]()</span>
    <span class="n">public</span> <span class="k">class</span> <span class="k">var</span> <span class="nl">shareInstance</span><span class="p">:</span><span class="n">SingletonCls</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">classname</span> <span class="o">=</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">_singleton_instance</span><span class="p">[</span><span class="n">classname</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">_singleton_instance</span><span class="p">[</span><span class="n">classname</span><span class="p">])</span><span class="o">!</span>
            <span class="p">}</span>
            <span class="k">let</span> <span class="n">singletonObject</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">()</span>
            <span class="n">_singleton_instance</span><span class="p">[</span><span class="n">classname</span><span class="p">]</span> <span class="o">=</span> <span class="n">singletonObject</span>
            <span class="k">return</span> <span class="n">singletonObject</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">required</span> <span class="n">public</span> <span class="k">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">var</span> <span class="nl">X</span><span class="p">:</span><span class="n">Int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="n">public</span> <span class="k">class</span> <span class="nl">SingletonClsChild</span> <span class="p">:</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nl">Y</span><span class="p">:</span><span class="n">Int</span> <span class="o">=</span> <span class="mi">9</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">A</span> <span class="o">=</span> <span class="n">SingletonClsChild</span><span class="p">.</span><span class="n">shareInstance</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">X</span><span class="p">);</span>
<span class="n">print</span><span class="p">((</span><span class="n">A</span> <span class="kt">as</span><span class="o">!</span> <span class="n">SingletonClsChild</span><span class="p">).</span><span class="n">Y</span><span class="p">);</span>
<span class="n">A</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">let</span> <span class="n">B</span> <span class="o">=</span> <span class="n">SingletonCls</span><span class="p">.</span><span class="n">shareInstance</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">X</span><span class="p">);</span>
</code></pre></div>
<p>결과.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1
9
1
</code></pre></div>
<p>결과를 보면 맨 마지막 값이 2가 아닌 1이 나오는 것을 확인 할 수 있다. 이것은 Singleton이 만들어 졌으나 <code>SingletonCls</code>와 <code>SingletonClsChild</code>가 각각 만들어 졌음을 뜻한다.</p>

<p>이런 추가적인 부분을 제외하고 기본적인 형태만 사용하고자 할 경우에는 아래와 같이 하면 된다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">public</span> <span class="k">class</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">var</span> <span class="nl">_singleton_instance</span><span class="p">:</span> <span class="n">SingletonCls</span><span class="o">?</span>
    <span class="n">public</span> <span class="k">class</span> <span class="k">var</span> <span class="nl">shareInstance</span><span class="p">:</span><span class="n">SingletonCls</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_singleton_instance</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_singleton_instance</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">_singleton_instance</span><span class="o">!</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">required</span> <span class="n">public</span> <span class="k">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">SingletonCls</span><span class="p">.</span><span class="n">sharedInstance</span>
</code></pre></div>
<p>위 코드를 기준으로 오류가 나던 코드를 다시 만들어 보자.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">public</span> <span class="k">class</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">var</span> <span class="nl">_singleton_instance</span><span class="p">:</span> <span class="n">SingletonCls</span><span class="o">?</span>
    <span class="n">public</span> <span class="k">class</span> <span class="k">var</span> <span class="nl">shareInstance</span><span class="p">:</span><span class="n">SingletonCls</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_singleton_instance</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">_singleton_instance</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">_singleton_instance</span><span class="o">!</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">required</span> <span class="n">public</span> <span class="k">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">var</span> <span class="nl">X</span><span class="p">:</span><span class="n">Int</span><span class="o">?</span>
<span class="p">}</span>

<span class="n">public</span> <span class="k">class</span> <span class="nl">SingletonClsChild</span> <span class="p">:</span> <span class="n">SingletonCls</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nl">Y</span><span class="p">:</span><span class="n">Int</span> <span class="o">=</span> <span class="mi">9</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">A</span> <span class="o">=</span> <span class="n">SingletonClsChild</span><span class="p">.</span><span class="n">shareInstance</span><span class="p">;</span>
<span class="n">A</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">X</span><span class="p">);</span>
<span class="n">print</span><span class="p">((</span><span class="n">A</span> <span class="kt">as</span><span class="o">!</span> <span class="n">SingletonClsChild</span><span class="p">).</span><span class="n">Y</span><span class="p">);</span>
</code></pre></div>
<p>아래와 같은 결과가 출력된다. 원하던 결과를 얻었다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">test.SingletonClsChild
Optional(1)
9
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 2.1에서의 오류 처리(do try catch)]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/swift-2-dot-1-try-catch/"/>
    <updated>2015-10-05T21:19:47+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/swift-2-dot-1-try-catch</id>
    <content type="html"><![CDATA[<p>애플이 2015.06.08.에 <a href="https://developer.apple.com/swift/blog/?id=29">&#39;세계개발자회의(WWDC) 2015&#39;에서 스위프트 2.0을 공개</a> 했지만 최근 다시 iOS 작업을 시작하면서 이제서야 swift 2.0을 사용하게 되었다. 그런데 이제 2.0 보려고 하는데 벌써 Xcode 7.1 beta 2가 나오면서 swift 2.1이 공개되었다.</p>

<p>오늘은 swift의 내용 중에서 오류 처리에 관련된 내용을 살펴보고자 한다. 아래의 내용은 <a href="http://qiita.com/koher/items/0c60b13ff0fe93220210">Swift 2.0 の try, catch ファーストインプレッション</a>와 공식 메뉴얼(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html">Error Handling</a>)의 내용을 참고하여 정리한 것이다.</p>

<p>공식 메뉴얼(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html">Error Handling</a>)에서는 swift 2.0이 아닌 swift 2.1로 안내하고 있으니 그냥 2.1을 기준으로 살펴보고자 한다(확실하지는 않지만 대충 알아본 결과 2.1에서의 변화에 Error Handling 부분은 포함되지 않는 것 같다).</p>

<p>메뉴얼의 내용을 빌어 Error Handling의 필요성에 대해 설명하자면 다음과 같다.</p>

<blockquote>
<p>일부 작업은 항상 완전한 실행을 보증하거나 유용한 출력을 생성하지 않는다. Optionals를 사용하여 값의 유무를 전달함으로써 작업의 성공/실패 유무를 판단할 수 있지만 작업이 실패 할 때 코드가 적절히 응답 할 수 있도록 함으로써 오류의 원인을 이해하는 데 도움을 줄 수 있다. 예를들어 디스크상의 파일을 읽어서 처리하는 작업에서 발생할 수 있는 오류는 &#39;존재하지 않는 파일&#39;, &#39;읽기 권한 없음&#39;, &#39;호환되는 형식이 아님&#39; 등의 여러가지가 존재할 수 있다. 이러한 경우처럼 오류의 원인에 따라 다양한 대응이 필요한 경우라면 오류의 정보를 정확히 전달함으로써 오류를 복구하는데 도움을 줄 수 있다.</p>
</blockquote>

<p><strong>Swift 2.0 이후부터는 Error Handling(런타임 상에서 오류를 발견하여 응답하고 복구하는 과정)을 위해 throwing, catching, propagating(전파), 런타임에서 복구할 수 있는 오류를 조작(manipulating recoverable errors at runtime) 할 수 있도록 지원한다.</strong></p>

<h2 id="오류의-사용자-정의">오류의 사용자 정의</h2>

<p>Swift에서는 ErrorType protocol라는 빈 protocol을 사용하여 오류를 표시한다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">enum</span> <span class="nl">VendingMachineError</span><span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">InvalidSelection</span>
    <span class="k">case</span> <span class="n">InsufficientFunds</span><span class="p">(</span><span class="nl">coinsNeeded</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">OutOfStock</span>
<span class="p">}</span>
</code></pre></div>
<p>이렇게 생성된 Error는 아래와 같이 발생시킬 수 있다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">throw</span> <span class="n">VendingMachineError</span><span class="p">.</span><span class="n">InsufficientFunds</span><span class="p">(</span><span class="nl">coinsNeeded</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div>
<p>조금더 자세히 보자면 ErrorType은 enum으로 정의될 수 있다. Swift에서 try, catch는 항상 ErrorType를 throw 한다. Java에서는 오류 유형을 클래스로 취급하므로 종류마다 클래스를 정의하므로 개수가 많아지고 오류를 처리에 따라 묶어서 관리하기 어렵다. 하지만 Swift의 ErrorType는 관련 오류를 enum으로 정리할 수 있기 때문에 정리가 쉽다.</p>

<p>예들들어 String을 Int로 변환하는 함수를 가정할 경우 발생할 수 있는 오류는 String이 nil이거나 숫자로 변환될 수 없는 문자열일 수 있다. 이를 ErrorType 로 구현하면 다음과 같이 정의할 수 있다.
<code>swift
enum ParseError : ErrorType {
    case Nil // nil 인 경우
    case IllegalFormat // Int로 해석 할 수 없었던 경우
}
</code></p>

<p>ErrorType는 오류의 종류를 나타낼뿐만 아니라 오류 정보를 함께 가질 수 있다.
위의 예시에서 IllegalFormat 오류일 때 해당 String이 무엇이었는지를 함께 넘겨주고 싶을 수 있다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">enum</span> <span class="nl">ParseError</span> <span class="p">:</span> <span class="n">ErrorType</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Nil</span>
    <span class="k">case</span> <span class="n">IllegalFormat</span> <span class="p">(</span><span class="n">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>이 방식의 좋은 점은 오류의 종류에 따라 다른 유형의 인자를 가질 수 있어 Type Safe하게 값을 얻어낼 수 있다는 것이다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">switch</span> <span class="n">error</span> <span class="p">{</span>
    <span class="k">case</span><span class="p">.</span> <span class="nl">Nil</span> <span class="p">:</span>
        <span class="n">print</span> <span class="p">(</span> <span class="s">&quot;The text is nil.&quot;</span><span class="p">)</span>
    <span class="k">case</span><span class="p">.</span> <span class="n">IllegalFormat</span> <span class="p">(</span><span class="k">let</span> <span class="n">string</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">print</span> <span class="p">(</span> <span class="s">&quot;Illegal format : \ (string)&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Objective-C의 NSError에서도 오류 정보를 가질 수 있지만, Type 정보가 사라져 버리기 때문에 Type Safe 하지 않다.</p>

<h2 id="오류-제어">오류 제어</h2>

<p>오류가 발생하면 문제를 보정하는 방법을 시도하거나 사용자에게 알림으로써 오류를 처리해야 한다. Swift에서는 오류를 처리 할 수있는 네 가지 방법이 있다.</p>

<ul>
<li>Throwing Functions을 이용한 오류 전파(Propagating Errors Using Throwing Functions)</li>
<li>Do-Catch를 이용한 오류 처리(Handling Errors Using Do-Catch)</li>
<li>Error를 Optional Values로 변환(Converting Errors to Optional Values)</li>
<li>오류 전파 비활성화(Disabling Error Propagation)</li>
</ul>

<p>각각의 처리 방법을 하나씩 알아보자.</p>

<h3 id="throwing-functions을-이용한-오류-전파-propagating-errors-using-throwing-functions">Throwing Functions을 이용한 오류 전파(Propagating Errors Using Throwing Functions)</h3>

<p>함수, 메소드, 초기화시에 오류가 throw될 수 있음을 표시하려면 함수 선언시 인자 뒤에 throws 키워드를 추가할 수 있다. 아래의 예시를 보면 이해가 편할 것이다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="n">canThrowErrors</span><span class="p">()</span> <span class="n">throws</span> <span class="o">-&gt;</span> <span class="n">String</span>

<span class="k">func</span> <span class="n">cannotThrowErrors</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span>
</code></pre></div>
<p><code>canThrowErrors</code> 함수 내부에서 오류가 발생하면 이 오류는 자신을 호출한 함수로 전파된다.</p>

<h3 id="do-catch를-이용한-오류-처리-handling-errors-using-do-catch">Do-Catch를 이용한 오류 처리(Handling Errors Using Do-Catch)</h3>

<p>오류를 제어 하고자하는 코드의 블록이 있을 경우는 do-catch를 사용할 수 있다. 문법 상의 차이는 있지만 다른 언어에서의 try-catch와 유사하므로 코드를 보는 것이 이해가 더 빠를 것으로 생각된다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="n">vendingMachine</span> <span class="o">=</span> <span class="n">VendingMachine</span><span class="p">()</span>
<span class="n">vendingMachine</span><span class="p">.</span><span class="n">coinsDeposited</span> <span class="o">=</span> <span class="mi">8</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="n">try</span> <span class="n">buyFavoriteSnack</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span> <span class="nl">vendingMachine</span><span class="p">:</span> <span class="n">vendingMachine</span><span class="p">)</span>
<span class="p">}</span> <span class="n">catch</span> <span class="n">VendingMachineError</span><span class="p">.</span><span class="n">InvalidSelection</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Invalid Selection.&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="n">catch</span> <span class="n">VendingMachineError</span><span class="p">.</span><span class="n">OutOfStock</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Out of Stock.&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="n">catch</span> <span class="n">VendingMachineError</span><span class="p">.</span><span class="n">InsufficientFunds</span><span class="p">(</span><span class="k">let</span> <span class="n">coinsNeeded</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p><code>buyFavoriteSnack</code> 함수는 try에 의해 호출되며 오류가 발생하면 오류의 타입에 해당하는 catch에 의해 제어된다. 다른 예시를 하나 살펴보자.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">do</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">number</span> <span class="o">=</span> <span class="n">try</span> <span class="n">toInt</span> <span class="p">(</span><span class="n">label</span><span class="p">.</span> <span class="n">text</span><span class="p">)</span>
    <span class="c1">// number를 사용한 처리</span>
<span class="p">}</span> <span class="n">catch</span> <span class="n">ParseError</span><span class="p">.</span> <span class="n">Nil</span> <span class="p">{</span>
    <span class="n">print</span> <span class="p">(</span> <span class="s">&quot;The text is nil.&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="n">catch</span> <span class="n">ParseError</span><span class="p">.</span> <span class="n">IllegalFormat</span> <span class="p">(</span><span class="k">let</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span> <span class="p">(</span> <span class="s">&quot;Illegal format : \ (string)&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="error를-optional-values로-변환-converting-errors-to-optional-values">Error를 Optional Values로 변환(Converting Errors to Optional Values)</h3>

<p><code>try?</code> 구문을 이용해서 오류를 optional value로 변환할 수 있다. 예를들어 어떤 값을 반환하는 함수가 있을 때 내부에서 오류가 발생하면 오류를 무시하고 nil이 반환된 것과 동일하게 처리할 수 있다. 역시 아래의 예시를 보자.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="n">someThrowingFunction</span><span class="p">()</span> <span class="n">throws</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="n">someThrowingFunction</span><span class="p">()</span>
<span class="k">let</span> <span class="nl">y</span><span class="p">:</span> <span class="n">Int</span><span class="o">?</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">try</span> <span class="n">someThrowingFunction</span><span class="p">()</span>
<span class="p">}</span> <span class="n">catch</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">nil</span>
<span class="p">}</span>
</code></pre></div>
<p>아래와 같이 사용하는 것도 가능하다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">fetchData</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Data</span><span class="o">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="n">fetchDataFromDisk</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span> <span class="p">}</span>
    <span class="k">if</span> <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="n">fetchDataFromServer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nb">nil</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="오류-전파-비활성화-disabling-error-propagation">오류 전파 비활성화(Disabling Error Propagation)</h3>

<p>실질적으로는 런타임시 오류를 발생시키지 않는 throwing 함수나 메서드를 사용할 경우가 있다. 이 경우 <code>try!</code>(forced-try)를 사용하여 throwing 함수나 메서드를 호출할 수 있다. <code>try!</code>를 사용하여 throwing 함수나 메서드를 호출하면 error 전파가 비활성화 되고 에러를 던지지 않는 런타임
assertion 안에서의 호출로 랩핑된다. 따라서 만일 실제로 에러가 thrown 되면, 런타임 에러를 만나게 된다. 아래의 예시를 보자.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="n">photo</span> <span class="o">=</span> <span class="n">try</span><span class="o">!</span> <span class="n">loadImage</span><span class="p">(</span><span class="s">&quot;./Resources/John Appleseed.jpg&quot;</span><span class="p">)</span>
</code></pre></div>
<p><code>loadImage(_:)</code> 함수의 경우 Resources에서 이미지를 호출하고 있으므로 런타임 상에서 오류가 발생하지 않는다(빌드시 이미지가 포함되므로). 이런 경우 <code>try!</code>를 사용하여 오류 제어를 줄일 수 있다.</p>

<h2 id="clearn-up-actions-지정-specifying-clearn-up-actions">Clearn-Up Actions 지정 (Specifying Clearn-Up Actions)</h2>

<p><code>defer</code>를 사용하면 코드의 실행이 코드 블럭을 벗어나기 전에 일련의 작업을 수행하게 할 수 있다. 다시말해 오류의 발생과 무관하게 반드시 실행되어야할 작업을 지정할 수 있다. 다른 언어의 finally와 유사하다고 볼 수 있다. 예를들면 열려진 파일을 닫거나, 수동으로 할당된 메모리를 해제하는 작업이 될 수 있다.</p>

<p>defer 내부의 구문은 제어흐픔을 벗어나게 할 수 있는 break, return, throw 등을 포함해서는 안된다. 또한 defer는 기술된 순서의 역순으로 실행된다. 다시말해 마지막에 있는 defer부터 실행되어 올라온다.</p>

<p>아래의 예시는 파일을 열어서 내용을 읽어서 처리하며 defer를 사용하여 오류 발생과 무관하게 파일을 닫아주도록 하고 있다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">processFile</span><span class="p">(</span><span class="nl">filename</span><span class="p">:</span><span class="n">String</span><span class="p">)</span> <span class="n">throws</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">defer</span> <span class="p">{</span>
            <span class="n">close</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="k">let</span> <span class="o">=</span> <span class="n">try</span> <span class="n">file</span><span class="p">.</span><span class="n">readline</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// work with the file</span>
        <span class="p">}</span>
        <span class="c1">// close(file) is called here, at the end of the scope.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 2 : 'lastPathComponent' is unavailable: Use lastPathComponent on NSURL instead. 오류 해결]]></title>
    <link href="http://blog.asamaru.net/2015/10/05/no-more-stringbyappendingpathcomponent-in-xcode-7/"/>
    <updated>2015-10-05T13:14:55+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/05/no-more-stringbyappendingpathcomponent-in-xcode-7</id>
    <content type="html"><![CDATA[<p><a href="/2015/10/05/binary-operator-cannot-be-applied-to-two-uiviewautoresizing-operands/">Swift 2 : Binary operator &#39;|&#39; cannot be applied to two &#39;UIViewAutoresizing&#39; operands 오류 해결</a>에 이어 Swift 2로 넘어가면서 만난 또 다른 오류.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&#39;lastPathComponent&#39; is unavailable: Use lastPathComponent on NSURL instead.
</code></pre></div>
<p>관련해서 찾아보니 <a href="https://forums.developer.apple.com/thread/13580">No more stringByAppendingPathComponent in Xcode 7 beta 5?</a>라는 글이 있었다. 내용을 보니 해당 함수가 없어져서 다른 방법으로 수정해야 한다는 것. 내용중 <a href="https://forums.developer.apple.com/people/tieferbegabt">tieferbegabt</a>라는 사람이 간단히 해결할 수 있는 코드를 올려 놓았다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">extension</span> <span class="n">String</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nl">lastPathComponent</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">self</span> <span class="kt">as</span> <span class="bp">NSString</span><span class="p">).</span><span class="n">lastPathComponent</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nl">pathExtension</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">self</span> <span class="kt">as</span> <span class="bp">NSString</span><span class="p">).</span><span class="n">pathExtension</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nl">stringByDeletingLastPathComponent</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">self</span> <span class="kt">as</span> <span class="bp">NSString</span><span class="p">).</span><span class="n">stringByDeletingLastPathComponent</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nl">stringByDeletingPathExtension</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">self</span> <span class="kt">as</span> <span class="bp">NSString</span><span class="p">).</span><span class="n">stringByDeletingPathExtension</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nl">pathComponents</span><span class="p">:</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">self</span> <span class="kt">as</span> <span class="bp">NSString</span><span class="p">).</span><span class="n">pathComponents</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">func</span> <span class="n">stringByAppendingPathComponent</span><span class="p">(</span><span class="nl">path</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">nsSt</span> <span class="o">=</span> <span class="nb">self</span> <span class="kt">as</span> <span class="bp">NSString</span>
        <span class="k">return</span> <span class="n">nsSt</span><span class="p">.</span><span class="n">stringByAppendingPathComponent</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">func</span> <span class="n">stringByAppendingPathExtension</span><span class="p">(</span><span class="nl">ext</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">nsSt</span> <span class="o">=</span> <span class="nb">self</span> <span class="kt">as</span> <span class="bp">NSString</span>
        <span class="k">return</span> <span class="n">nsSt</span><span class="p">.</span><span class="n">stringByAppendingPathExtension</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Objective-C의 category나 swift의 extension은 개인적으로 정말 좋은 기능이라고 생각한다. 하지만 위의 코드는 임시로 사용하고 가급적 위 코드의 내용을 참고해서 오류가 나는 부분을 직접 변경하는 것을 권장하고 싶다. 어짜피 나중에는 애플에서 권장하는대로 코딩을 해야할테니 정확한 방법을 익히도록 처리하는 것이 좋다는 얘기다.</p>

<p>아래는 내가 사용한 코드의 일부를 예시로 남긴다.</p>
<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// before</span>
<span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">file</span><span class="p">.</span><span class="n">lastPathComponent</span><span class="p">.</span><span class="n">stringByDeletingPathExtension</span>
<span class="c1">// after</span>
<span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="p">((</span><span class="n">file</span> <span class="kt">as</span> <span class="bp">NSString</span><span class="p">).</span><span class="n">lastPathComponent</span> <span class="kt">as</span> <span class="bp">NSString</span><span class="p">).</span><span class="n">stringByDeletingPathExtension</span>
</code></pre></div>]]></content>
  </entry>
  
</feed>
