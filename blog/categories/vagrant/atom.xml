<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vagrant | 이 세상에 하나는 남기고 가자]]></title>
  <link href="http://blog.asamaru.net/blog/categories/vagrant/atom.xml" rel="self"/>
  <link href="http://blog.asamaru.net/"/>
  <updated>2015-12-17T22:09:50+09:00</updated>
  <id>http://blog.asamaru.net/</id>
  <author>
    <name><![CDATA[유영재]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vagrant box repackage(unpacked box에서 box 파일 만들기)]]></title>
    <link href="http://blog.asamaru.net/2015/12/09/vagrant-box-repackage/"/>
    <updated>2015-12-09T08:17:05+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/09/vagrant-box-repackage</id>
    <content type="html"><![CDATA[<p>vagrant box를 생성하는 것에 대해서는 <a href="/2015/10/14/creating-a-vagrant-base-box/">Vagrant BASE Box 만들기(CentOS 7)</a>에서 설명했었다. 이번에도 box를 생성하는 것에 대한 것이지만 대상이 다르다. 기존 글에서는 생성한 가상 머신을 대상으로 box 파일을 만들었지만 아래에서 설명하고자 하는 것은 <code>vagrant box add</code> 명령을 사용하거나 <code>vagrant up</code> 명령을 통해 box 파일을 unpacked(~/.vagrant.d/boxes에 보관)한 것을 다시 배포용(distributable) box 파일로 만드는 것이다.</p>

<p>이 방법이 필요한 경우를 예를 들자면 box를 생성하고 unpacked 했지만 box 파일을 배포 경로(원격/로컬)로 이동하지 않고 지워버린 경우에 사용할 수 있다.</p>

<p>vagrant는 이런 경우를 위해 <code>repackage</code> 명령을 제공한다. <a href="https://docs.vagrantup.com/v2/cli/box.html">VAGRANT DOCS : BOX REPACKAGE</a>에는 아래와 같이 설명되어 있다.</p>

<blockquote>
<p>Command: vagrant box repackage NAME PROVIDER VERSION</p>

<p>This command repackages the given box and puts it in the current directory so you can redistribute it. The name, provider, and version of the box can be retrieved using vagrant box list.</p>

<p>When you add a box, Vagrant unpacks it and stores it internally. The original *.box file is not preserved. This command is useful for reclaiming a *.box file from an installed Vagrant box.</p>
</blockquote>

<p><code>repackage</code> 명령은 NAME, PROVIDER, VERSION 인자 모두를 지정해야 한다. 각 인자에 어떤 정보를 넣는지 알아보자.</p>

<ul>
<li>NAME : <code>vagrant box list</code> 명령으로 확인할 수 있는 box명을 지정한다.</li>
<li>PROVIDER : 가상 머신을 구동하는 PROVIDER를 지정한다.</li>
<li>VERSION : box의 버전을 지정한다.</li>
</ul>

<p>우선 실제로 사용하는 예시를 보자.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant box repackage centos7-dev-1 virtualbox 0
</code></pre></div>
<p>이 명령을 실행하면 box 파일이 실행한 경로에 생성된다.</p>

<p>예시를 보면 어떻게 사용해야 하는지 이해가 될 것이다. NAME은 별다를 것이 없고 PROVIDER의 경우는 일반적으로 <code>virtualbox</code>를 지정한다(box 생성시 virtualbox를 대부분 사용하므로). VERSION의 경우는 별도의 version을 사용하지 않았다면 그냥 0을 입력하면 된다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant Box Packaging 후 "Warning: Authentication failure. Retrying... " 오류가 발생할 경우 해결 방법]]></title>
    <link href="http://blog.asamaru.net/2015/12/03/vagrant-warning-authentication-failure-retrying-dot-dot-dot-after-packaging-box/"/>
    <updated>2015-12-03T20:35:25+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/03/vagrant-warning-authentication-failure-retrying-dot-dot-dot-after-packaging-box</id>
    <content type="html"><![CDATA[<p>vagrant를 사용하면서 직접 box를 만들 경우가 자주 발생하지는 않는다. 하지만 환경 구성을 위해 간혹 작업을 하게되는데 작업 과정에 문제가 생기는 경우가 간혹 있다. 이번에 CentOS 7 환경을 구성하면서 vagrant로 테스트를 진행했었다. 최초 설치 상태로 box를 만들어두고 환경을 구성해보고 문제가 있으면 초기 box로 다시 구성하는 식으로 작업을 했다. 그런데 이번엔 작업을 하면서 이전에 발생하지 않았던 문제가 발생했다.</p>

<p>이전글 <a href="/2015/10/14/creating-a-vagrant-base-box/">Vagrant BASE Box 만들기(CentOS 7)</a>에서 설명했던 것처럼 box 생성 전에 분명 ssh 관련 처리를 해 주었음에도 불구하고 만들어진 box를 사용해서 <code>vagrant up</code>을 하게되면 아래와 같은 결과가 계속 나왔다(여러번 box를 다시 만들어 봤음에도 불구하고).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant up
Bringing machine <span class="s1">&#39;default&#39;</span> up with <span class="s1">&#39;virtualbox&#39;</span> provider...
<span class="o">==</span>&gt; default: Importing base box <span class="s1">&#39;centos7-dev-1&#39;</span>...
<span class="o">==</span>&gt; default: Matching MAC address <span class="k">for</span> NAT networking...
<span class="o">==</span>&gt; default: Setting the name of the VM: <span class="nv">dev7_default_1449141471748_10760</span>
<span class="o">==</span>&gt; default: Clearing any previously <span class="nb">set </span>network interfaces...
<span class="o">==</span>&gt; default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
    default: Adapter 2: <span class="nv">hostonly</span>
<span class="o">==</span>&gt; default: Forwarding ports...
    default: <span class="nv">80</span> <span class="o">=</span>&gt; <span class="m">8080</span> <span class="o">(</span>adapter 1<span class="o">)</span>
    default: <span class="nv">22</span> <span class="o">=</span>&gt; <span class="m">2222</span> <span class="o">(</span>adapter 1<span class="o">)</span>
<span class="o">==</span>&gt; default: Running <span class="s1">&#39;pre-boot&#39;</span> VM customizations...
<span class="o">==</span>&gt; default: Booting VM...
<span class="o">==</span>&gt; default: Waiting <span class="k">for</span> machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2222
    default: SSH username: vagrant
    default: SSH auth method: private key
    default: Warning: Connection timeout. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
    default: Warning: Authentication failure. Retrying...
Timed out <span class="k">while</span> waiting <span class="k">for</span> the machine to boot. This means that
Vagrant was unable to communicate with the guest machine within
the configured <span class="o">(</span><span class="s2">&quot;config.vm.boot_timeout&quot;</span> value<span class="o">)</span> <span class="nb">time </span>period.

If you look above, you should be able to see the error<span class="o">(</span>s<span class="o">)</span> that
Vagrant had when attempting to connect to the machine. These errors
are usually good hints as to what may be wrong.

If you<span class="s1">&#39;re using a custom box, make sure that networking is properly</span>
<span class="s1">working and you&#39;</span>re able to connect to the machine. It is a common
problem that networking isn<span class="err">&#39;</span>t setup properly in these boxes.
Verify that authentication configurations are also setup properly,
as well.

If the box appears to be booting properly, you may want to increase
the timeout <span class="o">(</span><span class="s2">&quot;config.vm.boot_timeout&quot;</span><span class="o">)</span> value.
</code></pre></div>
<p>ssh 인증에 실패하면서 계속 시도하다가 결국 그냥 종료되어 버린다. 사실 가상 머신이 종료된 것은 아니다. ssh로 직접 접속하면 접속은 된다. 이 문제가 발생한 것은 이전이지만 당장 다른 작업들이 급해서 그냥 아래의 방법을 통해 사용중이었다.</p>

<p><strong>Vagrantfile 에 아래의 내용을 추가한다.</strong></p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">config</span><span class="o">.</span><span class="n">ssh</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="s2">&quot;vagrant&quot;</span>
<span class="n">config</span><span class="o">.</span><span class="n">ssh</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="s2">&quot;vagrant&quot;</span>
</code></pre></div>
<p>이 방법은 ssh key를 사용하지 않고 아이디/비밀번호를 입력하는 방식으로 ssh 접속하는 것이다. 사실 이렇게하면 문제는 해결된다. 어짜피 비밀번호에 대한 보안이 중요한 상황도 아니므로 그냥 사용해도 무방하다. 그런데 그냥 사용하기에는 찜찜했다. 특별히 권장하거나 일반적인 방법이 아닌데다가 기존에는 굳이 이렇게하지 않아도 잘 동작하고 있었기 때문이다.</p>

<p>그래서 오늘 많은 검색과 여러가지 방법을 시도한 끝에 해결 방법을 찾았다. 결론은 box 내부에서 처리하는 과정에 문제가 아니라 내 PC의 문제로 보인다. 해결 방법은 다음과 같다.</p>

<p><strong>Vagrantfile 에 아래의 내용을 추가한다.</strong></p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">config</span><span class="o">.</span><span class="n">ssh</span><span class="o">.</span><span class="n">insert_key</span> <span class="o">=</span> <span class="kp">false</span>
</code></pre></div>
<p>아마도 내가 vagrant를 자주 변경하고 실험하는 사이에 뭔가 설정이 꼬인 것 같다. 이 옵션을 해결되는 것으로 볼 때 내 컴퓨터에 잘못된 키가 저장되어 있고 <code>vagrant up</code> 과정에서 가상 머신에 key를 변경해 버려서 위 문제가 발생했던 것으로 보인다.</p>

<p>config.ssh.insert_key는 <a href="https://docs.vagrantup.com/v2/vagrantfile/ssh_settings.html">메뉴얼</a>에 아래와 같이 설명되어 있다.</p>

<blockquote>
<p>config.ssh.insert_key - If true, Vagrant will automatically insert an keypair to use for SSH, replacing the default Vagrant&#39;s insecure key inside the machine &gt; if detected. By default, this is true.</p>

<p>This only has an effect if you don&#39;t already use private keys for authentication or if you are relying on the default insecure key. If you don&#39;t have to take care about security in your project and want to keep using the default insecure key, set this to false.</p>
</blockquote>

<p>검색을 하다보니 이 두가지 방법 외에도 여러가지 방법이 제안되는 것으로 보아 다른 문제로 인해 이런 현상이 나타나는 경우도 있는 것 같다. 어쨌든 위와 같은 문제를 겪는다면 제시한 2가지 방법도 한번 적용해 보면 도움이 될 것으로 생각한다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox 버전업 후 Vagrant synced_folder 설정에서 오류가 날 경우]]></title>
    <link href="http://blog.asamaru.net/2015/12/02/vagrant-cant-mount-shared-folder/"/>
    <updated>2015-12-02T19:39:43+09:00</updated>
    <id>http://blog.asamaru.net/2015/12/02/vagrant-cant-mount-shared-folder</id>
    <content type="html"><![CDATA[<p>vagrant를 사용하면서 로컬과 가상 머신 사이의 파일 전달을 간단히 하려면 synced_folder를 사용하면 된다. 설정도 아주 간단하다. <code>Vagrantfile</code>에 아래의 내용을 추가하면 된다. 당연히 설정값은 자신의 상황에 맞게 지정하면 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">config.vm.synced_folder <span class="s2">&quot;/local/vagrant/share&quot;</span>, <span class="s2">&quot;/vagrant&quot;</span>, owner: <span class="s2">&quot;web&quot;</span>, group: <span class="s2">&quot;usergroup&quot;</span>, mount_options: <span class="o">[</span><span class="s2">&quot;dmode=777,fmode=777&quot;</span><span class="o">]</span>
</code></pre></div>
<p>사실 synced_folder의 단점은 퍼미션에 있다. 나의 경우는 osx 환경에서 centos 가상 머신을 사용하는 상황이라 퍼미션을 유지한 상태로 폴더를 연결하고 싶으나 그렇게는 되지 않는다. 그래서 나는 synced_folder는 파일 전달용으로 사용하고 작업 소스 폴더 등은 NFS를 이용해서 로컬과 가상 머신을 연결한다. 그렇게하면 퍼미션도 유지할 수 있기 때문에 관련 작업시 편하다. 이와 관련해서는 오늘 이야기하고자 하는 부분이 아니므로 일단 넘어가기로 한다.</p>

<p>사실 나도 이렇게 잘 사용하고 있었는데 얼마 전부터 아래와 같은 오류가 나면서 정상적으로 연결이 되지 않았다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">default: /vagrant <span class="o">=</span>&gt; /local/vagrant/share
Failed to mount folders in Linux guest. This is usually because
the <span class="s2">&quot;vboxsf&quot;</span> file system is not available. Please verify that
the guest additions are properly installed in the guest and
can work properly. The <span class="nb">command </span>attempted was:

mount -t vboxsf -o <span class="nv">uid</span><span class="o">=</span><span class="sb">`</span>id -u web<span class="sb">`</span>,gid<span class="o">=</span><span class="sb">`</span>getent group usergroup <span class="p">|</span> cut -d: -f3<span class="sb">`</span>,dmode<span class="o">=</span>777,fmode<span class="o">=</span><span class="m">777</span> vagrant /vagrant
mount -t vboxsf -o <span class="nv">uid</span><span class="o">=</span><span class="sb">`</span>id -u web<span class="sb">`</span>,gid<span class="o">=</span><span class="sb">`</span>id -g usergroup<span class="sb">`</span>,dmode<span class="o">=</span>777,fmode<span class="o">=</span><span class="m">777</span> vagrant /vagrant
</code></pre></div>
<p>synced_folder의 경우 주로 사용하는 작업용 폴더가 아니라서 일단 무시하고 사용하고 있었는데 vagrant up 할 때마다 오류가 보여서 해결하기로 했다.</p>

<p>기존에는 아무 문제가 없었다. 그래서 가만히 생각해보니 얼마전 VirtualBox를 버전업 했다는 사실이 떠올랐다. 그래서 확인해보니 이 부분이 문제를 일으키는 원인이 맞았다. synced_folder의 경우 vboxsf를 사용하는데 VirtualBox가 버전업 되면서 호환이 되지 않았던 것이다(4.3.30 -&gt; 5.0.10). 간단히 생각하면 VBoxGuestAdditions을 다시 설치해주면 된다. 그런데 이렇게 하려니 가상 머신마다 일일이 작업을 해야하기 때문에 귀찮다.</p>

<p>그래서 조금 찾아보니 <a href="https://github.com/mitchellh/vagrant/issues/3341">Vagrant can&#39;t mount shared folder in VirtualBox 4.3.10</a>에 해결 방법이 있었다.</p>

<p>간단히 요약하면 <code>vagrant-vbguest</code> 플러그인을 설치하면 vagrant up 시에 알아서 GuestAdditions을 다시 설치해 준다. 우선 <code>vagrant-vbguest</code> 플러그인을 설치하려면 local에서 아래와 같이 실행한다(osx 기준이다).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant plugin install vagrant-vbguest

Installing the <span class="sb">`</span>vagrant-vbguest<span class="sb">`</span> plugin. This can take a few minutes...
Installed the plugin <span class="s1">&#39;vagrant-vbguest (0.11.0)&#39;</span>!
</code></pre></div>
<p>그리고 다시 vagrant up을 하면 아래와 같이 다시 설치하는 모습을 볼 수 있다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">==</span>&gt; default: Machine booted and ready!
GuestAdditions versions on your host <span class="o">(</span>5.0.10<span class="o">)</span> and guest <span class="o">(</span>4.3.30<span class="o">)</span> <span class="k">do</span> not match.
Loaded plugins: fastestmirror
Repodata is over <span class="m">2</span> weeks old. Install yum-cron? Or run: yum makecache fast
Determining fastest mirrors
 * base: mirror.premi.st
 * extras: mirror.premi.st
 * updates: mirror.premi.st
Package kernel-devel-3.10.0-229.14.1.el7.x86_64 already installed and latest version
Package gcc-4.8.3-9.el7.x86_64 already installed and latest version
Package 1:make-3.82-21.el7.x86_64 already installed and latest version
Package 4:perl-5.16.3-285.el7.x86_64 already installed and latest version
Package bzip2-1.0.6-12.el7.x86_64 already installed and latest version
Nothing to <span class="k">do</span>
Copy iso file /Applications/VirtualBox.app/Contents/MacOS/VBoxGuestAdditions.iso into the box /tmp/VBoxGuestAdditions.iso
mount: /dev/loop0 is write-protected, mounting <span class="nb">read</span>-only
Installing Virtualbox Guest Additions 5.0.10 - guest version is 4.3.30
Verifying archive integrity... All good.
Uncompressing VirtualBox 5.0.10 Guest Additions <span class="k">for</span> Linux............
VirtualBox Guest Additions installer
Removing installed version 4.3.30 of VirtualBox Guest Additions...
Copying additional installer modules ...
Installing additional modules ...
Removing existing VirtualBox non-DKMS kernel modules<span class="o">[</span>  OK  <span class="o">]</span>
Building the VirtualBox Guest Additions kernel modules
Building the main Guest Additions module<span class="o">[</span>  OK  <span class="o">]</span>
Building the shared folder support module<span class="o">[</span>  OK  <span class="o">]</span>
Building the OpenGL support module<span class="o">[</span>  OK  <span class="o">]</span>
Doing non-kernel setup of the Guest Additions<span class="o">[</span>  OK  <span class="o">]</span>
You should restart your guest to make sure the new modules are actually used
</code></pre></div>
<p><a href="https://github.com/mitchellh/vagrant/issues/3341">Vagrant can&#39;t mount shared folder in VirtualBox 4.3.10</a>에서는 <code>sudo ln -s /opt/VBoxGuestAdditions-4.3.10/lib/VBoxGuestAdditions /usr/lib/VBoxGuestAdditions</code> 처리를 통해 심볼릭 링크를 만들어 주고 있지만 나의 경우는 <code>vagrant-vbguest</code> 플러그인이 이 과정도 처리해놔서 별도로 처리하지는 않았다.</p>

<p>하지만 이 과정이 필요하다면 동일하게 처리해 줘야할 수 있다. 나의 경우로 예를들자면 VirtualBox가 5.0.10이므로 <code>sudo ln -s /opt/VBoxGuestAdditions-5.0.10/lib/VBoxGuestAdditions /usr/lib/VBoxGuestAdditions</code>라고 해야한다. 그런데 여기서도 문제가 있을 수 있다. 나의 경우는 최초 설치가 아니라 이미 사용중이었으므로 <code>/usr/lib/VBoxGuestAdditions</code> 파일이 이미 존재하고 이 파일은 <code>/opt/VBoxGuestAdditions-4.3.30/lib/VBoxGuestAdditions</code>의 심볼릭 링크다. 그래서 아래와 같이 처리해 주어야 한다. 당연히 이 과정은 가상 머신에서 실행한다. 하지만</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo su -
<span class="nv">$ </span>rm -f /usr/lib/VBoxGuestAdditions
<span class="nv">$ </span>ln -s /opt/VBoxGuestAdditions-5.0.10/lib/VBoxGuestAdditions /usr/lib/VBoxGuestAdditions
</code></pre></div>
<p>그런데 다시 vagrant up 시에 아래와 같은 오류가 날 수 있다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">GuestAdditions seems to be installed <span class="o">(</span>5.0.10<span class="o">)</span> correctly, but not running.
</code></pre></div>
<p>또는</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">/sbin/mount.vboxsf: mounting failed with the error: No such device
</code></pre></div>
<p>이 경우는 vboxadd 서비스가 부팅시에 자동으로 시작되도록 되어있지 않기 때문이다. 따라서 서비스를 아래와 같이 추가해 주어야 한다. 이 명령 또한 가상 머신에서 실행하는 것이다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>systemctl <span class="nb">enable </span>vboxadd.service
</code></pre></div>
<p>단, 여기서 유의할 점은 위 과정은 CentOS 7 기준이라는 것이다. 따라서 상황에 따라 <code>systemctl</code>에 관련된 부분을 수정해야 한다. 예를들어 CentOS 6.5의 경우라면 아래의 명령을 사용해야 한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>chkconfig --add vboxadd
<span class="nv">$ </span>chkconfig vboxadd on
</code></pre></div>
<p>이제 다 되었다. 기존처럼 synced_folder를 사용할 수 있다.</p>

<p>이 글의 내용을 요약하자면 이렇다. <strong>VirtualBox의 버전업을 한 후 vboxsf가 정상 동작하지 않는다면 VBoxGuestAdditions를 재설치 해야한다. 매번 재설치하는 것이 귀찮다면 <code>vagrant-vbguest</code> 플러그인을 사용한다.</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant Port Forwarding : Mac에서 1024 이하 포트 사용]]></title>
    <link href="http://blog.asamaru.net/2015/10/19/vagrant-port-forwarding-on-mac/"/>
    <updated>2015-10-19T12:24:24+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/19/vagrant-port-forwarding-on-mac</id>
    <content type="html"><![CDATA[<p>Vagrant는 포트 포워딩을 지원한다. VAGRANT DOCS의 <a href="https://docs.vagrantup.com/v2/networking/forwarded_ports.html">FORWARDED PORTS</a> 문서를 보면 설명되어 있다.</p>

<p>간단하게 살펴보자면 아래와 같이 설정할 수 있다.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Vagrant</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="s2">&quot;forwarded_port&quot;</span><span class="p">,</span> <span class="ss">guest</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="ss">host</span><span class="p">:</span> <span class="mi">8080</span>
<span class="k">end</span>
</code></pre></div>
<p>위 설정의 의미는 host(PC)에 8080 포트로 접근하면 guest(VM)의 80 포트로 포워딩 한다는 뜻이다. 따라서 host에서 <code>localhost:8080</code>로 접속하면 guest의 웹 서버에 접근할 수 있다.</p>

<p>사용할 수 있는 옵션은 아래와 같이 설명되어 있다.</p>

<ul>
<li>guest (int) - The port on the guest that you want to be exposed on the host. This can be any port.</li>
<li>guest_ip (string) - The guest IP to bind the forwarded port to. If this is not set, the port will go to the every interface. By default, this is empty.</li>
<li>host (int) - The port on the host that you want to use to access the port on the guest. This must be greater than port 1024 unless Vagrant is running as root (which is not recommended).</li>
<li>host_ip (string) - The IP on the host you want to bind the forwarded port to. If not specified, it will be bound to every IP. By default, this is empty.</li>
<li>protocol (string) - Either &quot;udp&quot; or &quot;tcp&quot;. This specifies the protocol that will be allowed through the forwarded port. By default this is &quot;tcp&quot;.</li>
</ul>

<p>크게 어려운 부분은 없기 때문에 더욱 자세한 설명은 필요없을 듯 하다.</p>

<p>그런데 여기서 한가지 상황을 생각해보자. <code>localhost:8080</code>로 접속하기는 싫고 <code>localhost</code>로 접속하고 싶다면 어떻게 해야 하나? 위의 설명대로라면 아래와 같이 설정하면 된다.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Vagrant</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="s2">&quot;forwarded_port&quot;</span><span class="p">,</span> <span class="ss">guest</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="ss">host</span><span class="p">:</span> <span class="mi">80</span>
<span class="k">end</span>
</code></pre></div>
<p>그런데 위와 같이 설정하면 vagrant 실행시 오류를 만나게 된다. 이와 관련된 정보는 virtualbox 메뉴얼 <a href="https://www.virtualbox.org/manual/ch06.html#nat-limitations">6.3.3. NAT limitations</a>에서 찾을 수 있다.</p>

<blockquote>
<p>Forwarding host ports &lt; 1024 impossible:
On Unix-based hosts (e.g. Linux, Solaris, Mac OS X) it is not possible to bind to ports below 1024 from applications that are not run by root. As a result, if you try to configure such a port forwarding, the VM will refuse to start. ipfw deprecated as of mavericks</p>
</blockquote>

<p>간단히 말하자면 <strong>Unix 계열에서는 1024 이하 포트에 대한 포워딩을 하려면 root 권한이 있어야 한다는 것</strong>.
그렇다면 해결 방법은 나왔다. 간단하게 vagrant 자체를 root 권한으로 실행하면 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo vagrant up
</code></pre></div>
<p>그런데 이렇게하면 vagrant나 virtualbox가 별개로 실행된다(로그인된 계정이 아닌 root계정에서 실행하게 된다). 따라서 virtualbox를 실행해보아도 해당 VM을 볼 수 없을 것이다. 일단 어디에 있는지 보려면 아래의 명령으로 virtualbox를 실행해보자.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ sudo VirtualBox
</code></pre></div>
<p>VirtualBox가 따로 실행되면서 추가된 VM도 볼 수 있다.</p>

<p>나는 다른 방법을 찾을 수 없어 얼마전까지 이렇게 사용해 왔다. 그런데 최근에 다시 vagrant를 설정할 일이 생겨 작업을 하면서 다시 찾아봤더니 그 사이에 해결 방법이 나와 있었다. 게다가 더욱 세련된(?) 방법으로.</p>

<ul>
<li><a href="http://salvatore.garbesi.com/vagrant-port-forwarding-on-mac/">Vagrant Port Forwarding On Mac</a></li>
<li><a href="https://www.danpurdy.co.uk/web-development/osx-yosemite-port-forwarding-for-vagrant/">OSX Yosemite Port Forwarding for Vagrant</a></li>
<li><a href="http://www.dmuth.org/node/1404/web-development-port-80-and-443-vagrant">Web Development on Port 80 and 443 in Vagrant</a></li>
</ul>

<p>여러개의 글을 링크했지만 모두 비슷한 방법이다. 그러나 마지막 글의 경우는 확인이 필요하다. 마지막 글에서 사용하는 ipfw는 요세미티에서 deprecated 되었다는 이야기가 있다. 나머지 두개는 같은 방법인데 간단히 요약하자면 아래와 같다.</p>

<p>우선 vagrant-triggers 플러그인을 설치한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant plugin install vagrant-triggers
</code></pre></div>
<p>Vagrantfile에 아래의 내용을 추가한다. 당연히 원하는 포트가 다르다면 조정해서 추가하면 된다.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="ss">:forwarded_port</span><span class="p">,</span> <span class="ss">guest</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="ss">host</span><span class="p">:</span> <span class="mi">8080</span>
<span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="ss">:forwarded_port</span><span class="p">,</span> <span class="ss">guest</span><span class="p">:</span> <span class="mi">443</span><span class="p">,</span> <span class="ss">host</span><span class="p">:</span> <span class="mi">8443</span>

<span class="n">config</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">after</span> <span class="o">[</span><span class="ss">:provision</span><span class="p">,</span> <span class="ss">:up</span><span class="p">,</span> <span class="ss">:reload</span><span class="o">]</span> <span class="k">do</span>
      <span class="nb">system</span><span class="p">(</span><span class="s1">&#39;echo &quot;</span>
<span class="s1">        rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 8080</span>
<span class="s1">        rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 443 -&gt; 127.0.0.1 port 8443</span>
<span class="s1">        &quot; | sudo pfctl -f - &gt; /dev/null 2&gt;&amp;1; echo &quot;==&gt; Fowarding Ports: 80 -&gt; 8080, 443 -&gt; 8443&quot;&#39;</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">config</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">after</span> <span class="o">[</span><span class="ss">:halt</span><span class="p">,</span> <span class="ss">:destroy</span><span class="o">]</span> <span class="k">do</span>
    <span class="nb">system</span><span class="p">(</span><span class="s2">&quot;sudo pfctl -f /etc/pf.conf &gt; /dev/null 2&gt;&amp;1; echo &#39;==&gt; Removing Port Forwarding&#39;&quot;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>한가지 설명을 더 추가 해야할 것 같다. 위 명령은 pf가 enabled 되어 있을 경우만 제대로 동작한다. 하지만 대부분의 경우 pf가 disabled 되어 있을 것이다. <code>pfctl -ef</code>와 같이 <code>e</code> 옵션을 추가해 주면 pf를 강제로 켜서 실행해 준다. 하지만 이 방법은 vagrant가 <code>halt</code>된 후에도 pf가 enabled된 상태를 유지하므로 뭔가 꺼림직하다. 개선 방법은 <code>halt</code>시 <code>d</code> 옵션을 줘서 다시 pfctl을 disabled 상태로 변경하면 된다. 그런데 이렇게하면 반대로 enabled가 기본인 상태였다면 pf를 disabled 상태로 바꿔버리는 결과를 가져온다. 그래서 이 부분을 해결한 스크립트를 아래에 추가한다. 기존 pf의 상태와 무관하게 룰을 추가하고 사용이 끝나면 해당 룰만 제거하는 것이다.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="ss">:forwarded_port</span><span class="p">,</span> <span class="ss">guest</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="ss">host</span><span class="p">:</span> <span class="mi">8080</span>
<span class="n">config</span><span class="o">.</span><span class="n">vm</span><span class="o">.</span><span class="n">network</span> <span class="ss">:forwarded_port</span><span class="p">,</span> <span class="ss">guest</span><span class="p">:</span> <span class="mi">443</span><span class="p">,</span> <span class="ss">host</span><span class="p">:</span> <span class="mi">8443</span>

<span class="n">config</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">after</span> <span class="o">[</span><span class="ss">:provision</span><span class="p">,</span> <span class="ss">:up</span><span class="p">,</span> <span class="ss">:reload</span><span class="o">]</span> <span class="k">do</span>
      <span class="nb">system</span><span class="p">(</span><span class="s1">&#39;echo &quot;</span>
<span class="s1">        rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 8080</span>
<span class="s1">        rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 443 -&gt; 127.0.0.1 port 8443</span>
<span class="s1">        &quot; | sudo pfctl -Ef - &gt; /dev/null 2&gt; pfctl.token; echo &quot;==&gt; Fowarding Ports: 80 -&gt; 8080, 443 -&gt; 8443&quot;&#39;</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">config</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">after</span> <span class="o">[</span><span class="ss">:halt</span><span class="p">,</span> <span class="ss">:destroy</span><span class="o">]</span> <span class="k">do</span>
    <span class="nb">system</span><span class="p">(</span><span class="s2">&quot;PFCTL_TOKEN=</span><span class="se">\&quot;</span><span class="s2">$(cat pfctl.token |grep Token| awk &#39;{ split($0,numbers,</span><span class="se">\&quot;</span><span class="s2">:</span><span class="se">\&quot;</span><span class="s2">); print numbers[2]; }&#39;| tr -d &#39;[[:space:]]&#39;)</span><span class="se">\&quot;</span><span class="s2">; sudo pfctl -X $PFCTL_TOKEN -f /etc/pf.conf &gt; /dev/null 2&gt;&amp;1; echo </span><span class="se">\&quot;</span><span class="s2">==&gt; Removing Port Forwarding : $PFCTL_TOKEN</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>원리를 간단히 설명하겠다. 우선 pfctl에 있는 옵션 중 <code>E</code> 옵션을 추가했다. 소문자 <code>e</code>와는 다르다.</p>

<ul>
<li>-e : Enable the packet filter.</li>
<li>-E : Enable the packet filter and increment the pf enable reference count.</li>
</ul>

<p><code>E</code>를 사용하면 pf enable reference count를 증가시키고 token을 반환해 준다. 이 토큰을 <code>pfctl.token</code>에 저장해 놨다가 <code>halt</code>시 <code>X</code> 옵션을 통해서 pf에게 disabled 요청을 한다.</p>

<p>이제부터는 80포트와 443 포트가 guest로 포워딩 된다. 이젠 <code>http://127.0.0.1</code>로 접속할 수 있다. 나의 경우엔 DNS에 별도의 도메인을 127.0.0.1로 지정해서 사용중이다. 따라서 <code>http://vagrant.mydomain.com</code>으로 웹 화면을 확인할 수 있다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant BASE Box 만들기(CentOS 7)]]></title>
    <link href="http://blog.asamaru.net/2015/10/14/creating-a-vagrant-base-box/"/>
    <updated>2015-10-14T12:50:15+09:00</updated>
    <id>http://blog.asamaru.net/2015/10/14/creating-a-vagrant-base-box</id>
    <content type="html"><![CDATA[<p>Vagrant에는 <a href="https://atlas.hashicorp.com/boxes/search">Discover Vagrant Boxes</a> 페이지를 제공하는데 여기에는 여러가지 Box가 이미 만들어져 있어 그중 하나를 선택해서 사용할 수 있다. 하지만 여기서 원하는 Box를 찾을 수 없거나 특별히 직접 만들어야 할 경우가 있다. 이 글은 이런 경우에 직접 Box를 만드는 방법에 대해 설명한다. 단, 아래는 OSX에서 작업하는 것을 기준으로 설명한다.</p>

<h2 id="vagrant-설치">Vagrant 설치</h2>

<p><a href="http://docs.vagrantup.com/v2/installation/index.html">INSTALLING VAGRANT</a>의 안내에 따라 <a href="http://www.vagrantup.com/downloads">DOWNLOAD VAGRANT</a>에 가면 OS별로 Vagrant 설치 파일을 다운 받을 수 있다. 설치는 다운 받아서 설치하면 되므로 굳이 설명할 것이 없다.</p>

<p>그리고 필요한 것이 <a href="https://www.virtualbox.org/">VirtualBox</a>인데 이것 또한 그냥 다운 받아 실행하면 설치가 완료되므로 간단하다.</p>

<h2 id="base-box-만들기">Base Box 만들기</h2>

<h3 id="virtualbox-가상-머신-생성">VirtualBox 가상 머신 생성</h3>

<p>Box를 만드려면 VirtualBox 가상 머신이 필요하다. 우선 VirtualBox를 실행해서 &quot;새로 만들기&quot;를 선택하면 아래의 화면이 나타난다. 적절한 이름과 종류를 선택하고 계속을 선택한다. 여기서는 CentOS 7을 설치하는 것을 기준으로 설명한다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-1.png" alt="creating-a-vagrant-base-box-1"></p>

<p>그 다음엔 사용할 메모리 크기를 설정하는 화면이 나오는데 필요에 맞게 설정한다. 나는 1GB를 할당했다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-2.png" alt="creating-a-vagrant-base-box-2"></p>

<p>그 다음엔 가상 하드 드라이브를 설정하는 화면이다. 특별한 경우가 아니라면 &quot;지금 가상 하드 드라이브 만들기&quot;를 선택하면 된다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-3.png" alt="creating-a-vagrant-base-box-3"></p>

<p>디스크 파일 형식의 경우는 기본으로 선택된 VDI를 선택한다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-4.png" alt="creating-a-vagrant-base-box-4"></p>

<p>하드 드라이브의 크기는 특별한 이유가 없다면 동적 할당을 선택하면 된다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-5.png" alt="creating-a-vagrant-base-box-5"></p>

<p>파일 위치 및 크기는 용도에 맞게 설정하면 된다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-6.png" alt="creating-a-vagrant-base-box-6"></p>

<p>여기까지 설정하고 나면 가상 머신이 하나 만들어 진다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-7.png" alt="creating-a-vagrant-base-box-7"></p>

<p>만들어진 가상 머신을 선택하고 설정을 선택하면 아래의 화면이 나온다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-8.png" alt="creating-a-vagrant-base-box-8"></p>

<p>여기서는 필요한 설정을 해주면 되는데 나의 경우엔 플로피디스크, USB, Audio를 사용하지 않도록 하고 네트워크는 &quot;NAT&quot;를 선택했다. &quot;브릿지 어뎁터&quot;를 사용하면 내 컴퓨터의 IP를 함께 사용하지 않고 새로운 IP를 설정할 수 있는데 특수한 경우가 아니라면 일단 NAT를 사용하도록 설정한다. 그리고 NAT를 사용하게되면 가상의 사설 IP가 할당되므로 나중에 SSH 접속을하기 위해서는 포트 포워딩 설정이 필요하다. 아래의 이미지를 참고해서 2222포트를 22포트로 포워딩 되도록 설정한다.</p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-9.png" alt="creating-a-vagrant-base-box-9"></p>

<p><img src="/img/2015-10-14-creating-a-vagrant-base-box-10.png" alt="creating-a-vagrant-base-box-10"></p>

<h3 id="사용할-os-설치">사용할 OS 설치</h3>

<p>이제는 설치할 OS를 지정해 줘야 한다. 설정 화면에서 저장소를 선택하면 컨트롤러 IDE에 CD 드라이브가 보일 것이다. 나는 CentOS 7을 설치할 것이므로 해당 ISO 파일을 다운 받아서 선택해 줬다.</p>

<p>이제 설정을 완료하고 서버를 시작하면 설정 해준 ISO(CD)가 로딩되면서 OS 설치가 시작될 것이다. 내가 설치한 CentOS 7의 설치 과정은 <a href="/2015/10/14/centos-7-minimal-install/">CentOS 7 minimal 설치</a>를 참고하면 된다.</p>

<p>OS에 대한 기본 설치를 마쳤다면 VirtualBox에서 해당 가상 머신을 켠 상태에서 메뉴의 &quot;Devices &gt; Insert Guest Additions CD Image...&quot;를 선택한다. 그 다음엔 콘솔에서 아래의 명령을 수행해서 게스트 확장을 설치한다. 그리고 설치가 정상적으로 완료되었다면 재시작 한다(굳이 할 필요는 없지만 kernel과 관련된 변경이 있는 것으로 보여 재시작 해 줬다).</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>su
<span class="nv">$ </span>mount -r /dev/cdrom /media/
<span class="nv">$ </span>ll /media/
<span class="nv">$ </span>yum install -y bzip2 kernel-devel make gcc perl
<span class="nv">$ </span>/media/VBoxLinuxAdditions.run --nox11
<span class="nv">$ </span>yum clean all

<span class="nv">$ </span>usermod -u <span class="m">471</span> vboxadd
<span class="nv">$ </span>groupmod -g <span class="m">471</span> vboxsf
<span class="c">#lsmod | grep vboxsf</span>

<span class="nv">$ </span><span class="nb">export </span><span class="nv">MAKE</span><span class="o">=</span><span class="s1">&#39;/usr/bin/gmake -i&#39;</span>
<span class="nv">$ </span>/etc/init.d/vboxadd setup
<span class="nv">$ </span><span class="nb">unset </span>MAKE

<span class="nv">$ </span>reboot
</code></pre></div>
<p>간혹 VBoxLinuxAdditions.run을 실행하는 과정에 kernel-devel이 없다는 오류가 날 수 있다. 이 경우엔 오류 메시지에 kernel-devel의 특정 버전을 yum으로 설치하라는 내용이 포함되어 있다. 이 명령을 따라 kernel-devel을 설치하고 VBoxLinuxAdditions.run를 다시 실행하면 오류없이 설치가 된다. </p>

<h3 id="vagrant-관련-설정">Vagrant 관련 설정</h3>

<p>우선 vagrant 계정을 추가한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>/usr/sbin/groupadd -g <span class="m">470</span> vagrant
<span class="nv">$ </span>/usr/sbin/useradd -g vagrant -u <span class="m">470</span> vagrant
<span class="nv">$ </span>passwd vagrant
    <span class="c"># vagrant 를 암호로 입력</span>
<span class="nv">$ </span>chown vagrant.vagrant /home/vagrant/
</code></pre></div>
<p>vagrant 계정에서 root 명량을 수행할 수 있도록 sudo에 추가해 준다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>visudo
    <span class="c"># 아래 내용 추가</span>
Defaults    env_keep +<span class="o">=</span> <span class="s2">&quot;SSH_AUTH_SOCK&quot;</span>
%vagrant        <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span>       NOPASSWD: ALL
Defaults:vagrant !requiretty
</code></pre></div>
<p>sudo에 정상적으로 추가되었는지를 확인하기 위해 아래의 명령을 수행해 본다.
<code>bash
$ su vagrant
$ cd
$ sudo ls -al
</code></p>

<p>vagrant의 ssh key를 추가해 준다. 위의 확인 코드를 수행했다면 /home/vagrant에 위치하고 있을 것이다. 아니라면 해당 폴더로 이동한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mkdir .ssh
<span class="nv">$ </span>curl -k https://raw.github.com/mitchellh/vagrant/master/keys/vagrant.pub &gt; .ssh/authorized_keys
<span class="nv">$ </span>chmod <span class="m">0700</span> .ssh
<span class="nv">$ </span>chmod <span class="m">0600</span> .ssh/authorized_keys
<span class="c"># .ssh/authorized_keys 내용 확인</span>
<span class="nv">$ </span>cat .ssh/authorized_keys
</code></pre></div>
<p>여기서 주의할 것이 있다. authorized_keys 파일이 빈 파일로 저장되는 경우가 있다. 정확한 원인은 확인하지 못했지만 이번에 작업하다보니 이런 경우가 생겼다. 현재로써는 curl의 문제로 보이지만 확실하진 않다. 이 경우엔 일단 파일을 받아야 하니 아래와 같이 wget을 사용해서 받자.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo yum install wget -y
<span class="nv">$ </span>mkdir .ssh
<span class="nv">$ </span>wget --no-check-certificate https://raw.github.com/mitchellh/vagrant/master/keys/vagrant.pub -O .ssh/authorized_keys
<span class="nv">$ </span>chmod <span class="m">0700</span> .ssh
<span class="nv">$ </span>chmod <span class="m">0600</span> .ssh/authorized_keys
<span class="c"># .ssh/authorized_keys 내용 확인</span>
<span class="nv">$ </span>cat .ssh/authorized_keys
</code></pre></div>
<p>이제는 ssh 설정을 조정한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo vi /etc/ssh/sshd_config
    <span class="c"># 아래의 내용을 확인해서 맞춰준다.</span>
Port 22
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys
</code></pre></div>
<p>디스크를 정리해서 용량을 줄인다. 디스크 용량이 부족하다는 오류가 나올 수 있는데 무시하면 된다. 디스크가 가득 찰때까지 내용을 채우기 때문이라고 한다.(<a href="http://stackoverflow.com/a/24956805">http://stackoverflow.com/a/24956805</a>) 이렇게 하면 가상이미지를 Box로 변환시 용량을 줄일 수 있다고 한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/EMPTY <span class="nv">bs</span><span class="o">=</span>1M
sudo rm -f /EMPTY
</code></pre></div>
<p>이제 기본 설정을 마쳤으므로 서버를 종료한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo halt
</code></pre></div>
<h3 id="box-만들기">Box 만들기</h3>

<p>이제 마지막 단계다. OSX의 shell에서 아래 명령을 입력하면 설치된 VirtualBox 목록이 출력된다. 여기서 생성했던 가상 머신의 이름을 확인한다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">VBoxManage list vms
</code></pre></div>
<p>이제 박스를 만든다. &quot;vagrant-centos7-x86_64&quot;는 위에서 확인한 VirtualBox 이름을 넣으면 되고 &quot;centos7-x86_64.box&quot;는 생성할 박스의 이름을 넣으면 된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">vagrant package --output centos7-x86_64.box --base vagrant-centos7-x86_64
</code></pre></div>
<p>혹시 퍼미션 오류가 난다면 아래처럼 sudo를 사용하면 된다. 사실 일반적인 경우라면 당연히 퍼미션 오류가 나지 않는다. 그런데 나의 경우엔 1024 이하의 포트를 포트 포워딩하기 위해 vagrant와 VirtualBox를 root 권한에서 사용하고 있다(OSX에서는 1024 포트를 포트 포워딩하기 위해서는 root 권한이 필요하다). 이런 경우라면 vagrant 명령에서 권한 오류가 날 수 있다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">sudo vagrant package --output centos7-x86_64.box --base vagrant-centos7-x86_64
</code></pre></div>
<h3 id="vagrantfile-만들기">Vagrantfile 만들기</h3>

<p>아래의 명령을 실행하면 Vagrantfile가 만들어 진다. 아래는 두가지 방법을 설명하고 있다. 첫번째는 local에 box을 추가해서 init하는 것이고 두번째는 현재 폴더의 box 파일을 사용해서 init하는 것이다. 어떤 방법을 써도 Vagrantfile는 만들어지니 편한 방법을 사용하면 된다. 어짜피 vagrant up 실행시 박스는 만들어진다. 보통 &quot;~/.vagrant.d/boxes&quot;에 Box 파일이 추가된다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant box add centos7 centos7-x86_64.box
<span class="nv">$ </span>vagrant init centos7
</code></pre></div>
<p>또는</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant init centos7-x86_64.box
<span class="c"># or</span>
<span class="nv">$ </span>vagrant init
</code></pre></div>
<p>여기서 만들어진 파일은 가장 기본 설정만 되어 있으므로 자신에게 맞는 설정을 해주어야 한다. 이 부분은 또 내용이 길기 때문에 다음에 포스팅 하도록 하겠다.</p>

<h3 id="실행해보기">실행해보기</h3>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant up
</code></pre></div>
<p>앞선 과정에서 문제가 없었다면 정상적으로 vagrant가 실행된다. 당연히 최소 실행시에는 box를 다운받는 과정이 있어 실행이 좀 오래 걸린다.</p>

<p>아래의 명령으로 접속이 된다면 일단 성공이다.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant ssh
</code></pre></div>
<p>박스의 종료.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant halt
</code></pre></div>
<p>추가된 box를 제거하려면 아래를 참고하자.</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vagrant destroy

<span class="nv">$ </span>vagrant box list
<span class="nv">$ </span>vagrant box remove centos7-x86_64.box
</code></pre></div>
<p>destroy는 VirtualBox에서 가상 머신을 제거한다. 하지만 추가된 box는 제거되지 않는다. 따라서 box list를 이용해서 box명을 확인해서 box remove를 해주어야 box까지 제거된다. 여기서 제거란 설치된 파일의 제거를 뜻하므로 만들어둔 box파일과 Vagrantfile 파일은 그대로 유지된다.</p>
]]></content>
  </entry>
  
</feed>
